<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Language Specification - Yurt Specification</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../yurt-spec.html">Yurt Specification</a></li><li class="chapter-item expanded "><a href="../intro/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/state_transition_function.html"><strong aria-hidden="true">1.1.</strong> State Transition Function</a></li><li class="chapter-item expanded "><a href="../intro/transactions.html"><strong aria-hidden="true">1.2.</strong> Transactions</a></li></ol></li><li class="chapter-item expanded "><a href="../lang/language_primitives.html" class="active"><strong aria-hidden="true">2.</strong> Language Specification</a></li><li class="chapter-item expanded "><a href="../json/json_intents.html"><strong aria-hidden="true">3.</strong> JSON Representation of Intents</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Yurt Specification</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/essential-contributions/yurt" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="specification-of-yurt"><a class="header" href="#specification-of-yurt">Specification of Yurt</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This document defines the Yurt programming language and its primitives. It serves as a reference for the syntax and the semantics for each of its elements.</p>
<p>Yurt is a high-level, typed, intent expression and modeling language. It provides:</p>
<ul>
<li>mathematical notation-like syntax;</li>
<li>expressive constraints;</li>
<li>support for different kinds of problems (satisfaction, explicit optimization);</li>
<li>extensibility (user-defined macros);</li>
<li>reliability (type checking);</li>
<li>solver-independent modeling;</li>
<li>simple, declarative semantics.</li>
</ul>
<p>Yurt's design is inspired by both <a href="https://www.minizinc.org/">MiniZinc</a> and <a href="https://www.rust-lang.org/">Rust</a>.</p>
<p>This document has the following structure. <a href="#notation">Notation</a> introduces the syntax notation used throughout the specification. <a href="#overview-of-an-intent-model">Overview of an Intent Model</a> provides a high-level overview of Yurt intent models. <a href="#syntax-overview">Syntax Overview</a> covers syntax basics. <a href="#high-level-intent-structure">High-level Intent Structure</a> covers high-level structure: items, multi-file models, namespaces, and scopes. <a href="#types">Types</a> introduces available types. <a href="#expressions">Expressions</a> covers expressions. <a href="#items">Items</a> describes the top-level items in detail.</p>
<h2 id="notation"><a class="header" href="#notation">Notation</a></h2>
<p>The specification of the Yurt programming language presented in this document follows the <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">BNF format</a>. The basics of the BNF used are as follows:</p>
<ul>
<li>Non-terminals are written between angle brackets, e.g. <code>&lt;item&gt;</code>.</li>
<li>Terminals are written in double quotes, e.g. <code>&quot;solve&quot;</code>. A double quote terminal is written as a sequence of three double quotes: <code>&quot;&quot;&quot;</code>.</li>
<li>Optional items are written in square bracket, e.g. <code>[ &quot;,&quot; ]</code></li>
<li>Sequences of zero or more items are written with parentheses and a star, e.g. <code>( &quot;,&quot; &lt;ident&gt; )*</code></li>
<li>Sequences of one or more items are written with parentheses and a plus, e.g. <code>( &quot;,&quot; &lt;ident&gt; )+</code>.</li>
<li>Non-empty lists are written with an item, a separator/terminator terminal, and three dots. For example, <code>&lt;expr&gt; &quot;,&quot; ...</code> is short for <code>&lt;expr&gt; ( &quot;,&quot; &lt;expr&gt; )* [ &quot;,&quot; ]</code>. The final terminal is always optional in non-empty lists.</li>
</ul>
<h2 id="overview-of-an-intent-model"><a class="header" href="#overview-of-an-intent-model">Overview of an Intent Model</a></h2>
<p>Conceptually, a Yurt problem specification has two parts:</p>
<ol>
<li>The <em>model</em>: the main part of the problem specification, which describes the structure of a particular class of problems.</li>
<li>The data: the input data for the model, which specifies one particular problem with this class of problems.</li>
</ol>
<p>The pairing of a model with a particular data set is a <em>model instance</em>.</p>
<p>The model and data may be separated, or the data may be &quot;hard-wired&quot; into the model.</p>
<p>There are two broad classes of problems: satisfaction and optimization. In satisfaction problems all solutions are considered equally good, whereas in optimization problems the solutions are ordered according to an objective and the ai is to find a solution whose objective is optimal. <a href="#solve-items">Solve Items</a> specifies how the class of problem is chosen.</p>
<h2 id="syntax-overview"><a class="header" href="#syntax-overview">Syntax Overview</a></h2>
<h3 id="character-set"><a class="header" href="#character-set">Character set</a></h3>
<p>Yurt input files must be encoded as UTF-8 and may have the extension <code>*.yrt</code>.</p>
<p>Yurt is case sensitive and has no layout restrictions. That is, pieces of whitespace containing spaces, tabs, and newlines are all equivalent to each other.</p>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>A <code>//</code> indicates that the rest of the line is a comment.</p>
<h3 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h3>
<p>Identifiers have the following syntax:</p>
<pre><code class="language-bnf">&lt;ident&gt; ::= _?[A-Za-z][A-Za-z0-9]*     % excluding keywords
</code></pre>
<p>A number of keywords are reserved and cannot be used as identifiers. The keywords are: <code>as</code>, <code>bool</code>, <code>constraint</code>, <code>contract</code>, <code>else</code>, <code>enum</code>, <code>extern</code>, <code>false</code>, <code>fn</code>, <code>if</code>, <code>implements</code>, <code>interface</code>, <code>int</code>, <code>let</code>, <code>maximize</code>, <code>minimize</code>, <code>real</code>, <code>satisfy</code>, <code>solve</code>, <code>state</code>, <code>string</code>, <code>true</code>, <code>type</code>, <code>use</code>.</p>
<h3 id="paths"><a class="header" href="#paths">Paths</a></h3>
<p>A path is a sequence of one ore more path segments logically separated by a namespace qualifier (<code>::</code>). If a path consists of only one segment, it refers to either an item or a variable in a local control scope. If a path has multiple segments, it always refers to an item.</p>
<p>Paths have the following syntax:</p>
<pre><code class="language-bnf">&lt;path&gt; ::= [ &quot;::&quot; ] &lt;ident&gt; ( &quot;::&quot; &lt;ident&gt; )*
</code></pre>
<p>For example:</p>
<pre><code class="language-yurt">::x;
x::y::z;
x;
</code></pre>
<p>Paths can be used in <a href="#import-items">Import Items</a>. They can also be used in expressions to directly refer to an item in a different module or <a href="#contract-items">contract</a>.</p>
<p>Paths that start with <code>::</code> are absolute paths from the root of the project. Paths that don't start with <code>::</code> are relative paths.</p>
<h2 id="high-level-intent-structure"><a class="header" href="#high-level-intent-structure">High-level Intent Structure</a></h2>
<p>A Yurt intent consists of one or more semicolon separated <code>items</code>:</p>
<pre><code class="language-bnf">&lt;intent&gt; ::= ( &lt;item&gt; &quot;;&quot; )*
</code></pre>
<p>Items can occur in any order; identifiers need not be declared before they are used. Items have the following top-level syntax:</p>
<pre><code class="language-bnf">&lt;item&gt; ::= &lt;import-item&gt;
         | &lt;let-item&gt;
         | &lt;state-item&gt;
         | &lt;constraint-item&gt;
         | &lt;macro-item&gt;
         | &lt;enum-decl-item&gt;
         | &lt;solve-item&gt;
         | &lt;interface-item&gt;
         | &lt;contract-item&gt;
         | &lt;extern-item&gt;
         | &lt;new-type-item&gt;
</code></pre>
<p>Import items (<code>&lt;import-item&gt;</code>) import new items from a module/submodule or external library into the current module (<a href="#import-items">Import Items</a>).</p>
<p>Let declaration items introduce decision variables and optionally constrain them to values (<a href="#let-declaration-items">Let Declaration Items</a>).</p>
<p>State declaration items (<code>&lt;state-item&gt;</code>) introduce <em>state</em> variables and constrain them to values (<a href="#state-declaration-items">State Declaration Items</a>).</p>
<p>Constraint items describe intent constraints (<a href="#constraint-items">Constraint Items</a>).</p>
<p>Macro items introduce new parameterized blocks of declarations or expressions which can be used to facilitate code re-use (<a href="#macro-items">Macro Items</a>).</p>
<p>Enum declaration items describe C-style enumerations (<a href="#enum-declaration-items">Enum Declaration Items</a>).</p>
<p>Solve items specify exact what kind of solution the user is interested in: plain satisfaction, or the minimization/maximization of an expression. Each intent must have at most one solve item (<a href="#solve-items">Solve Items</a>).</p>
<p>Interface items contain lists of smart contract methods that a <a href="#contract-items">contract</a> can have (<a href="#interface-items">Interface Items</a>).</p>
<p>Contract items describe actual deployed contracts with a known contract ID and a list of available methods (<a href="#contract-items">contract Items</a>).</p>
<p>&quot;Extern&quot; items contain lists of external functions that allow accessing data on a blockchain (<a href="#extern-items">&quot;Extern&quot; Items</a>).</p>
<p>New Type items let you assign a new name to an existing type, simplifying complex type definitions or providing more context for certain types (<a href="#new-type-items">&quot;New Type&quot; Items</a>).</p>
<h3 id="multi-file-intents"><a class="header" href="#multi-file-intents">Multi-file Intents</a></h3>
<p>An intent can be spread across multiple files. Each file implicitly declares a local module or submodule dependency.</p>
<h4 id="entry-file"><a class="header" href="#entry-file">Entry File</a></h4>
<p>Each multi-file Yurt project has an entry file. Compiling the entry file (e.g. using <code>yurtc &lt;filename&gt;</code>) should also compile all local modules and submodules that the entry file directly or indirectly depends on.</p>
<h4 id="declaring-modules"><a class="header" href="#declaring-modules">Declaring modules</a></h4>
<p>In the project root directory, new modules can be created as follows:</p>
<ul>
<li>A single-file module must be defined in a file that has the same name as the module itself. For example, module <code>single_mod</code> must be defined in <code>src/single_mod.yrt</code>. The absolute <a href="#paths">path</a> to items in <code>single_mod.yrt</code> is <code>::single_mod::&lt;item&gt;</code>.</li>
<li>A multi-file module must be defined inside a directory that has the same name as the module itself. Moreover, the entry file of the module must also have the same name as the module. For example, multi-file module <code>multi_mod</code> must be defined in <code>src/multi_mod/multi_mod.yrt</code> and its submodule dependencies must live in <code>src/multi_mod/</code>. The absolute <a href="#paths">path</a> to items in <code>multi_mod.yrt</code> is <code>::multi_mod::&lt;item&gt;</code>.</li>
</ul>
<h4 id="declaring-submodules"><a class="header" href="#declaring-submodules">Declaring submodules</a></h4>
<p>In any directory other than the project root directory, new submodules can be created as follows:</p>
<ul>
<li>A single-file submodule must be defined in a file that has the same name as the submodule itself. For example, submodule <code>single_submod</code> of module <code>multi_mod</code> must be defined in <code>src/multi_mod/single_submod.yrt</code>. The absolute <a href="#paths">path</a> to items in <code>single_submod.yrt</code> is <code>::multi_mod::single_submod::&lt;item&gt;</code>.</li>
<li>A multi-file submodule must be defined inside a directory that has the same name as the submodule itself. Moreover, the entry file of the submodule must also have the same name as the submodule. For example, multi-file submodule <code>multi_submod</code> must be defined in <code>src/multi_mod/multi_submod/multi_submod.yrt</code> and its own submodule dependencies must live in <code>src/multi_mod/multi_submod/</code>. The absolute <a href="#paths">path</a> to items in <code>multi_submod.yrt</code> is <code>::multi_mod::multi_submod::&lt;item&gt;</code>.</li>
</ul>
<p>Note that it is not allowed to have a file and a folder with the same name in any of the project's subdirectories. For example, a project that contains both <code>src/my_mod.yrt</code> and <code>src/my_mod/...</code> should not compile. Moreover, having a single file in a subdirectory is allowed even though subdirectories are typically used for multi-file modules. For example, having a single file in <code>src/my_mod/</code> is allowed as long as the name of that file is <code>my_mod.yrt</code>. This is equivalent to having the module live in <code>src/my_mod.yrt</code> and skipping the subdirectory <code>src/my_mod/</code> altogether.</p>
<h3 id="namespaces-and-scopes"><a class="header" href="#namespaces-and-scopes">Namespaces and Scopes</a></h3>
<p>TODO</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>Yurt provides 4 scalar types built-in: Booleans, integers, reals and strings. Yurt also provides tuples and arrays as a compound built-int type.</p>
<p>The syntax for types is as follows:</p>
<pre><code class="language-bnf">&lt;ty&gt; ::= &quot;bool&quot;
       | &quot;int&quot;
       | &quot;real&quot;
       | &quot;string&quot;
       | &lt;tuple-ty&gt;
       | &lt;array-ty&gt;
       | &lt;custom-ty&gt;
</code></pre>
<h3 id="tuple-type"><a class="header" href="#tuple-type">Tuple Type</a></h3>
<p>A tuple type represents a collection of items that may have different types. Tuple types have the following syntax:</p>
<pre><code class="language-bnf">&lt;tuple-ty&gt; ::= &quot;{&quot; ( [ &lt;ident&gt; &quot;:&quot; ] &lt;ty&gt; &quot;,&quot; ... ) &quot;}&quot;
</code></pre>
<p>For example, in <code>let t: { int, real, string };</code>, <code>{ int, real, string }</code> is a tuple type. <code>{x: int, y: real, string }</code> is also a tuple type where some of the fields are named.</p>
<p>Names of tuple fields modify the type of the tuple. That is, <code>{ x: int }</code> and <code>{ y: int }</code> are different types. However they both coerce to <code>{ int }</code>.</p>
<p>Note that the grammar disallows empty tuple types <code>{ }</code>.</p>
<h3 id="array-type"><a class="header" href="#array-type">Array Type</a></h3>
<p>An array type represents a collection of items that share the same type. Arrays can be multi-dimensional and have the following syntax:</p>
<pre><code class="language-bnf">&lt;array-ty&gt; ::= &lt;ty&gt; ( &quot;[&quot; &lt;expr&gt; | &lt;custom-ty&gt; &quot;]&quot; )+
</code></pre>
<p>An array dimension can be indexed using non-negative integers. It can also be indexed using enum variants of some enum type or some <a href="#new-type-items">new type</a> that resolves to an enum type. The allowed type of the index depends on how the dimension is specified in the array type definition.</p>
<ul>
<li>
<p>An array dimension that can be indexed using an integer requires that the corresponding dimension size is specified in between brackets as an expression that is evaluatable, <strong>at compile-time</strong>, to a <strong>strictly positive</strong> integer. Otherwise, the compiler should emit an error.</p>
</li>
<li>
<p>An array dimension that can be indexed using an enum variant requires that the corresponding dimension size is specified in between brackets as the appropriate enum type.</p>
</li>
</ul>
<p>For example, in:</p>
<pre><code class="language-yurt">let N = 5;
enum Colour = Red | Green | Blue;
let a: real[N][Colour];`
</code></pre>
<p><code>a</code> is a two dimensional array that contains <code>N</code> arrays of size 3 each (because <code>Colour</code> is an enum that has 3 variants). An element of <code>a</code> can be <a href="#array-expressions-and-array-element-access-expressions">accessed</a> using <code>a[3][Colour::Green]</code>, which accesses the second element of the fourth array in <code>a</code>.</p>
<h3 id="enum-type"><a class="header" href="#enum-type">Enum Type</a></h3>
<p>An enum type refers to an <a href="#enum-declaration-items">enum declaration</a> using its path and has the following syntax:</p>
<pre><code class="language-bnf">&lt;enum-ty&gt; ::= &lt;path&gt;
</code></pre>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<h3 id="expressions-overview"><a class="header" href="#expressions-overview">Expressions Overview</a></h3>
<p>Expressions represent values and have the following syntax:</p>
<pre><code class="language-bnf">&lt;expr&gt; ::= &lt;un-op&gt; &lt;expr&gt;
         | &lt;expr&gt; &lt;bin-op&gt; &lt;expr&gt;
         | &lt;block-expr&gt;
         | &quot;(&quot; &lt;expr&gt; &quot;)&quot;
         | &lt;path&gt;
         | &lt;bool-literal&gt;
         | &lt;int-literal&gt;
         | &lt;real-literal&gt;
         | &lt;string-literal&gt;
         | &lt;tuple-expr&gt;
         | &lt;tuple-field-access-expr&gt;
         | &lt;array-expr&gt;
         | &lt;array-element-access-expr&gt;
         | &lt;if-expr&gt;
         | &lt;cond-expr&gt;
         | &lt;call-expr&gt;
         | &lt;cast-expr&gt;
         | &lt;in-expr&gt;
         | &lt;range-expr&gt;
         | &lt;prime-expr&gt;
</code></pre>
<p>Expressions can be composed from sub-expressions with operators. All unary and binary operators are described in <a href="#operators">Operators
</a>. All unary operators bind more tightly than all binary operators. Expressions can also be contained within parentheses.</p>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<p>Operators are functions that are distinguished by their syntax:</p>
<ol>
<li>They mostly contain non-alphanumeric characters that normal functions do not (e.g. <code>+</code>).</li>
<li>Their application may be written differently than normal functions.</li>
</ol>
<p>There are two kinds of operators:</p>
<ol>
<li>Unary operators which can be applied in a prefix manner without parentheses, e.g. <code>-x</code>.</li>
<li>Binary operator which can be applied in an infix manner, e.g. <code>3 + 4</code>.</li>
</ol>
<pre><code class="language-bnf">&lt;un-op&gt; ::= &quot;+&quot; | &quot;-&quot; | &quot;!&quot;

&lt;bin-op&gt; ::= &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot; | &quot;==&quot; | &quot;!=&quot;
           | &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
           | &quot;&amp;&amp;&quot; | &quot;||&quot;
</code></pre>
<h3 id="expression-atoms"><a class="header" href="#expression-atoms">Expression Atoms</a></h3>
<h4 id="block-expressions"><a class="header" href="#block-expressions">Block Expressions</a></h4>
<p>Block expressions are expressions that contains a list of <em>statements</em> followed by an expression within curly bracket <code>{ .. }</code>. Formally:</p>
<pre><code class="language-bnf">&lt;block-expr&gt; ::= &quot;{&quot; ( &lt;block-statement&gt; &quot;;&quot; )* &lt;expr&gt; &quot;}&quot;

&lt;block-statement&gt; ::= &lt;let-item&gt;
                    | &lt;state-item&gt;
                    | &lt;constraint-item&gt;
</code></pre>
<p>The type of the block expression is the type of the final expression. For example:</p>
<pre><code class="language-yurt">let x: int = {
    let y: int = 2;
    y + 1
}
</code></pre>
<h4 id="boolean-literals"><a class="header" href="#boolean-literals">Boolean Literals</a></h4>
<p>Boolean literals have this syntax:</p>
<pre><code class="language-bnf">&lt;bool-literal&gt; ::= &quot;false&quot; | &quot;true&quot;
</code></pre>
<h4 id="integer-and-real-literals"><a class="header" href="#integer-and-real-literals">Integer and Real literals</a></h4>
<p>There are three forms of integer literals: decimal, hexadecimal, and binary:</p>
<pre><code class="language-bnf">&lt;int-literal&gt; ::= [0-9]+
                | 0x[0-9A-Fa-f]+
                | 0b[0-1]+
</code></pre>
<p>For example: <code>1</code>, <code>0030</code>, <code>0x333</code>, <code>0b1010</code>.</p>
<p>Real literals have the following form:</p>
<pre><code class="language-bnf">&lt;real-literal&gt; ::= [0-9]+&quot;.&quot;[0-9]+
                  | [0-9]+&quot;.&quot;[0-9]+[Ee][-+]?[0-9]+
                  | [0-9]+[Ee][-+]?[0-9]+
</code></pre>
<p>For example: <code>1.05</code>, <code>2.5e-4</code>, <code>1.3E5</code>.</p>
<p>A <code>-</code> preceding an integer or real literal is parsed as a unary minus, not as part of the literal.</p>
<h4 id="string-literals"><a class="header" href="#string-literals">String Literals</a></h4>
<p>String literals are written as:</p>
<pre><code class="language-bnf">&lt;string-literal&gt; ::= &quot;\&quot;&quot; ([^&quot;\n] | &quot;\\&quot; (&quot;x&quot; [0-9a-fA-F][0-9a-fA-F] | &quot;n&quot; | &quot;t&quot; | &quot;\&quot;&quot; | &quot;\\&quot;)) &quot;\&quot;&quot;
</code></pre>
<p>For example: <code>&quot;Hello, world!\n&quot;</code>.</p>
<p>String literals can be broken across multiple lines by escaping the newline and leading whitespace with a <code>\</code>. For example:</p>
<pre><code class="language-yurt">let string = &quot;first line\
             second line\
             third line&quot;;
</code></pre>
<h4 id="tuple-expressions-and-tuple-field-access-expressions"><a class="header" href="#tuple-expressions-and-tuple-field-access-expressions">Tuple Expressions and Tuple Field Access Expressions</a></h4>
<p>Tuple expressions are written as:</p>
<pre><code class="language-bnf">&lt;tuple-expr&gt; ::= &quot;{&quot; ( [ &lt;ident&gt; &quot;:&quot; ] &lt;expr&gt; &quot;,&quot; ... ) &quot;}&quot;
</code></pre>
<p>For example: <code>let t = { x: 5, 3, &quot;foo&quot; };</code>. The type of this tuple can be inferred by the compiler to be <code>{ x: int, int, string }</code>.</p>
<p>The following is another example:</p>
<pre><code class="language-yurt">let t: { x: int, real } = { 6, 5.0 }
</code></pre>
<p>where the type of the tuple is indicated by the type annotation and has a named field <code>x</code>, but that named field is not actually used in the tuple expression. This is allowed because <code>{ x: int, real }</code> and <code>{ int, real }</code> coerce into each other.</p>
<p>Tuple fields can be initialized out of order only if all the fields have names and their names are used in the tuple expression. For example, the following is allowed:</p>
<pre><code class="language-yurt">let t: { x: int, y: real } = { y: 5.0, x: 6 };
</code></pre>
<p>while the following are not:</p>
<pre><code class="language-yurt">let t: { x: int, real } = { 5.0, x: 6 };
let t: { x: int, y: real } = { 5.0, x: 6 };
let t: { x: int, y: real } = { 5.0, 6 }; // This is a type mismatch!
</code></pre>
<p>Tuple expressions that contain a single <em>unnamed</em> field require the trailing <code>,</code> as in <code>let t = { 4.0, };</code>. Otherwise, the expression becomes a code block that simply evaluates to its contained expression. Tuple expressions that contain a single <em>named</em> field do not require the trailing <code>,</code>.</p>
<p>Note that the grammar disallows empty tuple expressions <code>{ }</code>.</p>
<p>Tuple field access expressions are written as:</p>
<pre><code class="language-bnf">&lt;tuple-field-access-expr&gt; ::= &lt;expr&gt; &quot;.&quot; ( [0-9]+ | &lt;ident&gt; )
</code></pre>
<p>For example, <code>t.1;</code> refers to the second field of tuple <code>t</code>. Named field can be accessed using their names or their index. For example, if <code>x</code> is the third field of tuple <code>t</code>, then <code>t.2</code> and <code>t.x</code> are equivalent.</p>
<h4 id="array-expressions-and-array-element-access-expressions"><a class="header" href="#array-expressions-and-array-element-access-expressions">Array Expressions and Array Element Access Expressions</a></h4>
<p>Array expressions are written as:</p>
<pre><code class="language-bnf">&lt;array-expr&gt; ::= &quot;[&quot; ( &lt;expr&gt; &quot;,&quot; ... ) &quot;]&quot;
</code></pre>
<p>For example: <code>let a = [ 1, 2, 3 ];</code>. The type of this array can be inferred by the compiler to be <code>int[3]</code>.</p>
<p>The following is another example:</p>
<pre><code class="language-yurt">let b: real[2][3] = [ [ 1.0, 2.0, 3.0], [4.0, 5.0, 6.0] ];
</code></pre>
<p>where the type of the array is indicated by the type annotation. Note that the initializers of <code>b</code> is an array expression that contains other array expressions to reflect the fact that <code>b</code> is two dimensional. Also note that <code>real[2][3]</code> is an array that contains 2 elements where each element is of size 3, and not the other way around.</p>
<p>The grammar disallows empty array expressions <code>[ ]</code> because arrays of size 0 are not allowed.</p>
<p>All element expressions used in an array expression must have the exact same type and that type must match the type indicated in the array type annotation, if available.</p>
<p>Array element access expressions are written as:</p>
<pre><code class="language-bnf">&lt;array-element-access-expr&gt; ::= &lt;expr&gt; ( &quot;[&quot; expr &quot;]&quot; )+
</code></pre>
<p>For example, <code>a[1];</code> refers to the second element of array <code>a</code> in the example above. Therefore, <code>a[1]</code> should be equal to <code>2</code>. Similarly, <code>b[0][2]</code> in the example above refers to the third elements from the first inner array of <code>b</code>. That is, <code>b[0][2]</code> should be equal to <code>3.0</code>.</p>
<p>Yurt requires that the expression used to index into is an array. For example, in <code>foo()[5]</code>, <code>foo()</code> must return array of the appropriate size.</p>
<p>Yurt also requires that each array index is known (i.e. evaluatable) at compile-time. In addition, Yurt requires that each index evaluates to:</p>
<ol>
<li>A <strong>non-negative</strong> integer that is <strong>strictly smaller</strong> than the corresponding dimension (i.e. within bounds), if the dimension has a size that is specified using an integer in the array type definition.</li>
<li>A path to an enum variant of some enum type, if the dimension size is specified using that enum type in the array type definition.</li>
</ol>
<p>Below is an example where both an integer and an enum variant are used to index into an two-dimensional array:</p>
<pre><code class="language-yurt">let N = 5;
enum Colour = Red | Green | Blue;
let a: real[N][Colour];`

let a_3_g = a[3][Colour::Green];
</code></pre>
<h4 id="if-expressions"><a class="header" href="#if-expressions">&quot;If&quot; Expressions</a></h4>
<p>Yurt has <code>if</code> expressions which provide selection from two alternatives based on a condition. They have this syntax:</p>
<pre><code class="language-bnf">&lt;if-expr&gt; ::= &quot;if&quot; &lt;expr&gt; &lt;block-expr&gt; &quot;else&quot; &lt;block-expr&gt;
</code></pre>
<p>The condition <code>&lt;expr&gt;</code> above must be of type <code>bool</code>. The &quot;then&quot; and &quot;else&quot; block expressions must have the same type or have types that are coercible to the same type, which determines the type of the whole <code>if</code> expression.</p>
<p>Note that the <code>else</code> block is not optional and the <code>else if { .. }</code> syntax is not supported.</p>
<h4 id="cond-expressions"><a class="header" href="#cond-expressions">&quot;Cond&quot; Expressions</a></h4>
<p>Yurt provides <code>cond</code> expressions which are generalized <code>if</code> expressions with more than two branches. That is, they provide selection from multiple alternatives, each based on some condition. They have the following syntax:</p>
<pre><code class="language-bnf">&lt;cond-branch&gt; ::= &lt;expr&gt; &quot;=&gt;&quot; &lt;expr&gt;

&lt;else-branch&gt; ::= &quot;else&quot; &quot;=&gt;&quot; &lt;expr&gt;

&lt;cond-expr&gt; ::= cond &quot;{&quot; ( &lt;cond-branch&gt; &quot;,&quot; )* &lt;else-branch&gt; [ &quot;,&quot; ] &quot;}&quot;
</code></pre>
<p>The first <code>&lt;expr&gt;</code> in <code>&lt;cond-branch&gt;</code> must be of type <code>bool</code>. If it evaluates to <code>true</code>, then the branch is active which means that the whole <code>cond</code> expression takes the value of the second <code>&lt;expr&gt;</code> in <code>&lt;cond-branch&gt;</code>.</p>
<p>The branches are evaluated in order. The first one to become active determines the value of the <code>cond</code> expression. If all branches fail, then the <code>cond</code> expression takes the value of the <code>&lt;expr&gt;</code> in the <code>&lt;else-branch&gt;</code>.</p>
<p>Similarly to <code>if</code> expressions, all candidate expressions must have the same type or have types that are coercible to the same type, which determines the type of the whole <code>cond</code> expression.</p>
<h4 id="call-expressions"><a class="header" href="#call-expressions">Call Expressions</a></h4>
<p>Call expressions are used to call macros or functions and have the following syntax:</p>
<pre><code class="language-bnf">&lt;func-call-expr&gt; ::= &lt;path&gt; &quot;(&quot; [ &lt;expr&gt; &quot;,&quot; ... ] &quot;)&quot;
&lt;macro-call-expr&gt; ::= &lt;path&gt; &quot;(&quot; [ &lt;tok&gt;+ &quot;;&quot; ... ] &quot;)&quot;
</code></pre>
<p>For example: <code>let x = foo(5, 2);</code> or <code>constraint bar@(5; [a, b])</code>.</p>
<p>For function-style macros or extern function calls the type of the expressions passed as arguments must match the argument types of the called function. For all call expressions the number of passed arguments must match the called item, though this is flexible due to Yurt's variadic macro support. The return type of the function must also be appropriate for the calling context.</p>
<p>See <a href="#macro-items">Macro Items</a> for the distinction between regular and function-style macros. When calling regular macros the call arguments may be a collection of source tokens, excluding semi-colons, delimited by semi-colons.</p>
<h4 id="cast-expressions"><a class="header" href="#cast-expressions">Cast Expressions</a></h4>
<p>Cast expressions are used to cast one value to a different type. They have the following syntax:</p>
<pre><code class="language-bnf">&lt;cast-expr&gt; ::= &lt;expr&gt; &quot;as&quot; &lt;ty&gt;
</code></pre>
<p>Executing an <code>as</code> expression casts the value on the left-hand side to the type on the right-hand side.</p>
<p>For example: <code>let x: real = 5 as real;</code>.</p>
<p>Note that there is no implicit casting in Yurt, hence the need for an explicit casting mechanism using <code>as</code>.</p>
<p>Any cast that does not fit an entry in the table below is a compiler error:</p>
<div class="table-wrapper"><table><thead><tr><th>Type of LHS</th><th>RHS</th><th>Cast performed</th></tr></thead><tbody>
<tr><td><code>int</code></td><td><code>int</code></td><td>No-op</td></tr>
<tr><td><code>int</code></td><td><code>real</code></td><td>Produce the closest possible <code>real</code></td></tr>
<tr><td><code>real</code></td><td><code>real</code></td><td>No-op</td></tr>
<tr><td><code>enum</code></td><td><code>int</code></td><td>Enum cast</td></tr>
<tr><td><code>bool</code></td><td><code>int</code></td><td>Boolean to integer cast</td></tr>
</tbody></table>
</div>
<h5 id="enum-cast"><a class="header" href="#enum-cast">Enum Cast</a></h5>
<p>Casts an enum to its discriminant. For example:</p>
<pre><code class="language-yurt">enum MyEnum = V0 | V1 | V2;

let d = MyEnum::V1 as int; // `d` is equal to `1`.
</code></pre>
<h5 id="boolean-to-integer-cast"><a class="header" href="#boolean-to-integer-cast">Boolean to Integer Cast</a></h5>
<ul>
<li><code>false</code> casts to <code>0</code>.</li>
<li><code>true</code> casts to <code>1</code>.</li>
</ul>
<h4 id="in-expressions"><a class="header" href="#in-expressions">&quot;In&quot; Expressions</a></h4>
<p>&quot;In&quot; expressions are used to detect whether a value belongs to an array. They have the following syntax:</p>
<pre><code class="language-bnf">&lt;in-expr&gt; ::= &lt;expr&gt; &quot;in&quot; &lt;expr&gt;
</code></pre>
<p>An &quot;in&quot; expression returns a <code>bool</code> that indicates whether the left-hand side belongs to the right-hand side. For example, in <code>let x: bool = 5 in [3, 4, 5];</code>, <code>x</code> should be <code>true</code>.</p>
<p>The right-hand side of an &quot;in&quot; expression must be an array and the type of the left-hand side must match the array elements type. Otherwise, a compiler error should be emitted.</p>
<p>A value belongs to an array if and only if it is &quot;equal&quot; to one of its entries. Equality for various types is defined as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Equality Criterion</th></tr></thead><tbody>
<tr><td><code>int</code></td><td>Identical values</td></tr>
<tr><td><code>real</code></td><td>Identical values</td></tr>
<tr><td><code>bool</code></td><td>Identical values</td></tr>
<tr><td><code>string</code></td><td>Identical lengths and characters in the same order</td></tr>
<tr><td><code>enum</code></td><td>Identical variants</td></tr>
<tr><td>array</td><td>Identical lengths and <em>equal</em> elements in the same order</td></tr>
<tr><td>array</td><td>Identical lengths and <em>equal</em> elements in the same order</td></tr>
</tbody></table>
</div>
<p>Note that two values of different types cannot be compared and should result in a compile error.</p>
<h4 id="range-expressions"><a class="header" href="#range-expressions">Range Expressions</a></h4>
<p>Range expressions are used to refer to ranges between a lower bound value and an upper bound value:</p>
<pre><code class="language-bnf">&lt;range-expr&gt; ::= &lt;expr&gt; &quot;..&quot; &lt;expr&gt;
</code></pre>
<p>Range expressions require that both the lower bound and the upper bound expressions have the same type. The type of a range expression is identical to the type of its bounds.</p>
<p>The only allowed types for the bounds of a range expression are <code>int</code> and <code>real</code>.</p>
<p>Range expressions can only be used in two contexts:</p>
<ol>
<li>As the expression on the right-hand side of a <code>&lt;let-item&gt;</code>.</li>
<li>As the expression on the right-hand side of an <code>&lt;in-expr&gt;</code></li>
</ol>
<p>For example,</p>
<pre><code class="language-yurt">let x: int = 3..5;
</code></pre>
<p>is equivalent to;</p>
<pre><code class="language-yurt">let x: int;
constraint x in 3..5;
</code></pre>
<p>which is equivalent to:</p>
<pre><code class="language-yurt">let x: int;
constraint x &gt;= 3;
constraint x &lt;= 5;
</code></pre>
<h4 id="prime-expressions"><a class="header" href="#prime-expressions">Prime Expressions</a></h4>
<p>Prime expressions are used to refer to the <em>future</em> value of a <a href="#state-declaration-items">state variable</a>. They have the following syntax:</p>
<pre><code class="language-bnf">&lt;prime-expr&gt; ::= &lt;expr&gt; &quot;'&quot;
</code></pre>
<p>For example:</p>
<pre><code class="language-yurt">state u = MyContract::foo();
constraint u' - u &gt; 10;
</code></pre>
<p>The above enforces that the blockchain state value returned by <code>MyContract::foo()</code> increases by at least 10 after the execution of a valid solution for the intent.</p>
<h4 id="expression-precedence"><a class="header" href="#expression-precedence">Expression Precedence</a></h4>
<p>The precedence of Yurt operators and expressions is ordered as follows, going from strong to weak. Binary Operators at the same precedence level are grouped in the order given by their associativity.</p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Associativity</th></tr></thead><tbody>
<tr><td>Paths</td><td></td></tr>
<tr><td>Tuple field access expressions</td><td>left to right</td></tr>
<tr><td>Call expressions, array indexing</td><td></td></tr>
<tr><td>Unary <code>-</code>, Unary <code>+</code>, <code>!</code></td><td></td></tr>
<tr><td><code>as</code></td><td>left to right</td></tr>
<tr><td><code>in</code></td><td>left to right</td></tr>
<tr><td><code>*</code>, <code>/</code>, <code>%</code></td><td>left to right</td></tr>
<tr><td>Binary <code>+</code>, Binary <code>-</code></td><td>left to right</td></tr>
<tr><td><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td>Requires parentheses</td></tr>
<tr><td><code>&amp;&amp;</code></td><td>left to right</td></tr>
<tr><td><code>\|\|</code></td><td>left to right</td></tr>
<tr><td><code>..</code></td><td>Requires parentheses</td></tr>
</tbody></table>
</div>
<h2 id="items"><a class="header" href="#items">Items</a></h2>
<p>This section describes the top-level program items.</p>
<h3 id="import-items"><a class="header" href="#import-items">Import Items</a></h3>
<p>Within a scope, import items create shortcuts to items defined in other files. Import items have the following syntax:</p>
<pre><code class="language-bnf">&lt;use-tree&gt; ::= [ [ &lt;path&gt; ] &quot;::&quot; ] &quot;*&quot;
             | [ [ &lt;path&gt; ] &quot;::&quot; ] &quot;{&quot; [ &lt;use-tree&gt; &quot;,&quot; ... ] &quot;}&quot;
             | &lt;path&gt; [ &quot;as&quot; &lt;ident&gt; ]

&lt;import-item&gt; ::= &quot;use&quot; &lt;use-tree&gt;
</code></pre>
<p>An import item creates one or more local name bindings synonymous with some other path. Usually a <code>use</code> item is used to shorten the path required to refer to a module item. These items may appear in modules and blocks, usually at the top.</p>
<p>Use declarations support a number of convenient shortcuts:</p>
<ul>
<li>Simultaneously binding a list of paths with a common prefix, using the brace syntax <code>use a::b::{c, d, e::f, g::h::i};</code></li>
<li>Simultaneously binding a list of paths with a common prefix and their common parent module, using the <code>self</code> keyword, such as <code>use a::b::{self, c, d::e};</code>.</li>
<li>Rebinding the target name as a new local name, using the syntax <code>use p::q::r as x;</code>. This can also be used with the last two features: <code>use a::b::{self as ab, c as abc};</code>.</li>
<li>Nesting groups of the previous features multiple times, such as <code>use a::b::{self as ab, c, d::{e, f::g}};</code>.</li>
</ul>
<h3 id="let-declaration-items"><a class="header" href="#let-declaration-items">Let Declaration Items</a></h3>
<p>These are variables whose values may or may not be unknown for a given <em>instance</em> for an intent. Solvers are required to find appropriate values for those variables with unknown values at compile-time.</p>
<p>Variable declaration items have the following syntax:</p>
<pre><code class="language-bnf">&lt;let-item&gt; ::= &quot;let&quot; &lt;ident&gt; ( ( &quot;:&quot; &lt;ty&gt; ) | (&quot;=&quot; &lt;expr&gt; ) | ( &quot;:&quot; &lt;ty&gt; &quot;=&quot; &lt;expr&gt; ) )
</code></pre>
<p>For example:</p>
<pre><code class="language-yurt">let x: int;
let y = 5;
</code></pre>
<p>Note that at least one of the type annotation and the initializing expression has to be present so that the type of the variable can be determined. This implies that <code>let x;</code> is not a valid variable declaration.</p>
<h3 id="state-declaration-items"><a class="header" href="#state-declaration-items">State Declaration Items</a></h3>
<p>These are variables that represent blockchain <em>state</em> and require an initializer in the form of a <a href="#contract-items">contract</a> method call or a call an <a href="#extern-items"><code>extern</code> function</a>. State variables are <em>not</em> decision variables and the solver is not required to find values for them as their true value is determined by the blockchain. That being said, state variables can still be used in <a href="#constraint-items">constraint items</a> to enforce various restrictions on the current and future state values.</p>
<p>State declaration items have the following syntax:</p>
<pre><code class="language-bnf">&lt;state-item&gt; ::= &quot;state&quot; &lt;ident&gt; [ &quot;:&quot; &lt;ty&gt; ] &quot;=&quot; &lt;expr&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-yurt">state x: int = MyContract::foo();
state y = MyContract::bar();
</code></pre>
<p>Note that, unlike <a href="#let-declaration-items">let declarations</a>, the initializer of a state declaration is not optional.</p>
<h3 id="constraint-items"><a class="header" href="#constraint-items">Constraint Items</a></h3>
<p>Constraint items represent the core of any intent. Any solution to the intent must satisfy all of its constraints.</p>
<p>Constraint items have this syntax:</p>
<pre><code class="language-bnf">&lt;constraint-item&gt; ::= &quot;constraint&quot; &lt;expr&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-yurt">constraint a + b &lt;= c
</code></pre>
<p>The expression in a constraint item must be of type <code>bool</code>.</p>
<h3 id="macro-items"><a class="header" href="#macro-items">Macro Items</a></h3>
<p>Macro items describe user defined operations. They can take the form of a 'regular' macro, or of a specialized 'function-style' macro.</p>
<p>Regular macros have the following syntax:</p>
<pre><code class="language-bnf">&lt;macro-name&gt; ::= @[A-Za-z_][A-Za-z0-9_]*

&lt;macro-param&gt; ::= $[A-Za-z0-9]+

&lt;macro-body-item&gt; ::= &lt;tok&gt; | &lt;macro-param&gt;     % where &lt;tok&gt; is any valid parsable source token.

&lt;macro-item&gt; ::= &quot;macro&quot; &lt;macro-name&gt; &quot;(&quot; [ &lt;macro-param&gt; &quot;,&quot; ... ] &quot;)&quot; &quot;{&quot; &lt;macro-body-item&gt;* &quot;}&quot;
</code></pre>
<p>Macro expansion is the very first operation performed by the compiler. Any macro call expression is expanded in-place, replaced by the contents of the macro as parameterized by the call arguments.</p>
<p>Macros are intended to be a generalized method for code re-use. The macro parameters are special identifiers starting with a <code>$</code>, e.g., <code>$max</code> or <code>$0</code>.</p>
<h4 id="expansion"><a class="header" href="#expansion">Expansion</a></h4>
<p>The macro body is only semi-parsed by the compiler prior to macro expansion and may contain macro identifiers. During expansion macro identifiers are replaced by the corresponding call arguments and the body is then fully parsed. The parsed items are then added to the program as if they were parsed where the macro is called.</p>
<p>For example, a simple macro may introduce some constraints:</p>
<pre><code class="language-yurt">macro @in_range($var, $num) {
    constraint $var &gt;= $num;
    constraint $var &lt; ($num * $num);
}
</code></pre>
<p>It may be used as such:</p>
<pre><code class="language-yurt">let x: int;
@in_range(x; 10);  // Constrain `x` to [10, 100).

</code></pre>
<p>After macro expansion the above becomes:</p>
<pre><code class="language-yurt">let x: int;
constraint x &gt;= 10;
constraint x &lt; (10 * 10);
</code></pre>
<p>The arguments to a macro call may be collections of tokens which do not necessarily parse to a proper expression. For example, an operator like <code>+</code> or a type name such as <code>real</code> are valid. If the token is an identifier then it may be used to name a declaration such as with <code>let</code>.</p>
<pre><code class="language-yurt">macro @do_decls($a, $b, $ty, $op) {
    let $a: $ty;
    let $b: $ty;
    constraint $b $op $a;
}
</code></pre>
<p>If called as <code>@do_decls(foo; bar; real; &gt;)</code> it would expand to:</p>
<pre><code class="language-yurt">let foo: real;
let bar: real;
constraint bar &gt; foo;
</code></pre>
<h4 id="macro-expressions"><a class="header" href="#macro-expressions">Macro Expressions</a></h4>
<p>Macro bodies may have an expression rather than a declaration as its final item after expansion. In this special case the expression is inserted at the macro call, but any prior declaration items are inserted before the call.</p>
<pre><code class="language-yurt">macro @inverse_of($a) {
    constraint $a &gt; 0.0;  // Declaration.
    1.0 / $a              // Final expression.
}
</code></pre>
<p>When called:</p>
<pre><code class="language-yurt">let foo: real;
let bar: real = @inverse_of(foo);
</code></pre>
<p>will expand to:</p>
<pre><code class="language-yurt">let foo: real;
constraint foo &gt; 0.0;
let bar: real = 1.0 / foo;
</code></pre>
<h4 id="hygiene"><a class="header" href="#hygiene">Hygiene</a></h4>
<p>Macro bodies also treat <code>let</code> declarations specially. It may be desirable to use a local variable within a macro. For example:</p>
<pre><code class="language-yurt">macro @is_even($a) {
    let half: int;
    constraint $a == half * 2;
}
</code></pre>
<p>In a naive macro system if <code>@is_even</code> was called more than once within the same module then after expansion there would be multiple <code>half</code> variable declarations, resulting in a name clash error.</p>
<p>To avoid this problem Yurt's macro expansion aims to be 'hygienic' and place newly declared symbols into a unique anonymous namespace. Note that this is only done for symbols which are not macro parameters.</p>
<pre><code class="language-yurt">macro @let_decls($a) {
    let foo: int;       // Hygienic anonymous binding for `foo`.
    let $a: bool;       // Lexical binding for `$a`.
}
</code></pre>
<p>If called using <code>@let_decls(foo)</code> there would not be an error as the expansion would be equivalent to:</p>
<pre><code class="language-yurt">let anon_0::foo: int;
let foo: int;
</code></pre>
<p>And even when called multiple times with different arguments there would be no error:</p>
<pre><code class="language-yurt">@let_decls(foo);
@let_decls(bar);
</code></pre>
<p>Becomes equivalent to:</p>
<pre><code class="language-yurt">let anon_0::foo: int;
let foo: int;
let anon_1::foo: int;
let bar: int;
</code></pre>
<p>Of course if <code>@let_decls</code> was called with the argument <code>foo</code> multiple times there <em>would</em> be an error.</p>
<h4 id="recursion-and-variadic-macros"><a class="header" href="#recursion-and-variadic-macros">Recursion And Variadic Macros</a></h4>
<p>Macros may call other macros and a special type of recursion via variadic parameters is allowed. Sometimes it may be desirable to do repeated expansions using a single macro, essentially entering an expansion loop.</p>
<p>To support this macros may be declared to accept a variable number of parameters. It is valid to declare multiple macros <em>with the same name</em> but different number of parameters and the correct one to expand will be chosen based on the number of arguments passed to the call.</p>
<p>Recursion may be performed via one or more recursing macros and one or more non-recursing, or 'terminating' macros. The recursing macros call other versions of itself but with a different number of -- usually fewer -- arguments. The terminating macros do not call another version of itself.</p>
<p>The recursing macros may have a parameter 'pack' as its final parameter, denoted using an <code>&amp;</code>, e.g., <code>macro @foo($a, $b, &amp;rest) { ... }</code>. The parameter pack is never empty, therefore a macro declaration with a corresponding signature minus the parameter pack is required to avoid a pattern match failure.</p>
<p>The parameter pack is not addressable in any way. It may only be used as arguments to another macro call.</p>
<p>This example performs a naive sum of named variables:</p>
<pre><code class="language-yurt">macro @sum($x, $y, &amp;rest) {
    // Called only when `rest` is not empty.  We recurse by adding $x and $y and using &amp;rest as the second argument.
    @sum($x + $y, &amp;rest)
}

macro @sum($x, $y) {
    // Called only when the number of arguments is exactly 2.
    $x + $y
}
</code></pre>
<p>Calling <code>@sum(a; b)</code> will expand directly using the terminating macro to the expression <code>a + b</code>.</p>
<p>Calling <code>@sum(a; b; c; d)</code> will expand as follows:</p>
<ul>
<li><code>@sum(a; b; c; d)</code> calls the <em>recursive</em> macro as <code>@sum(a; b; [c, d])</code> where <code>[c, d]</code> is <code>&amp;rest</code>.</li>
<li><code>@sum(a; b; [c, d])</code> expands to <code>@sum(a + b; c; d)</code>.</li>
<li><code>@sum(a + b; c; d)</code> calls the recursive macro again, as <code>@sum(a + b; c; [d])</code>.</li>
<li><code>@sum(a + b; c; [d])</code> expands to <code>@sum(a + b + c; d)</code>.</li>
<li><code>@sum(a + b + c; d)</code> calls the <em>terminating</em> macro.</li>
<li><code>@sum(a + b + c; d)</code> expands to <code>a + b + c + d</code>.</li>
</ul>
<p>Note that as the <code>&amp;rest</code> parameter pack is passed in its expanded form, the above <code>@sum</code> macros could instead be the following, to the same effect:</p>
<pre><code class="language-yurt">macro @sum($x, &amp;rest) {
    @sum($x + &amp;rest)
}

macro @sum($x) {
    $x
}
</code></pre>
<p>The <code>&amp;pack</code> parameter may be used by non recursive macros which wish to call recursive macros. A more realistic use of variadic macros might be to chain variables together in relative constraints:</p>
<pre><code class="language-yurt">macro @chain($a, &amp;rest) {
    // Add the first link in the chain, then move to the rest.
    let $a: int;
    @chain_next($a; &amp;rest);
}

macro @chain_next($prev, $next, &amp;rest) {
    // Add the next link, constrain based on the previous link and continue.
    let $next: int;
    constraint $next &gt; $prev + 10;
    @chain_next($next; &amp;rest)
}

macro @chain_next($prev) {
    // Just expand to the final link.
    $prev
}

</code></pre>
<p>When called as <code>@chain(x; y; z)</code> it would expand to:</p>
<pre><code class="language-yurt">let x: int;
let y: int;
constraint y &gt; x + 10;
let z: int;
constraint z &gt; y + 10;
z
</code></pre>
<h4 id="function-style-macros"><a class="header" href="#function-style-macros">Function-style Macros</a></h4>
<p>Yurt also supports 'function-style' macros which are more constrained but also stricter in their use. Function-style macros look like function declarations and are called with standard expression arguments.</p>
<p>Function-style macros must have a final expression in their body and they may only be called as a sub-expression. Each parameter is a typed identifier and a return type (i.e., the type of the final body expression) must be specified.</p>
<pre><code class="language-bnf">&lt;function-sig&gt; ::= &quot;fn&quot; &lt;ident&gt; &quot;(&quot; [ &lt;param&gt; &quot;,&quot; ... ] &quot;)&quot; &quot;-&gt;&quot; &lt;ty&gt;

&lt;function-item&gt; ::= &lt;function-sig&gt; &lt;block-expr&gt;

&lt;param&gt; ::= &lt;ident&gt; &quot;:&quot; &lt;ty&gt;
</code></pre>
<p>For example, the following macro expands to a boolean expression which tests if the parameter is an even number:</p>
<pre><code class="language-yurt">fn is_even(x: int) -&gt; bool {
    x % 2 == 0
}
</code></pre>
<p>The extra type information is used to confirm correct use, which is not directly possible with regular macros. Expansion otherwise follows the regular macro procedures.</p>
<h3 id="enum-declaration-items"><a class="header" href="#enum-declaration-items">Enum Declaration Items</a></h3>
<p>In Yurt, an enum type is a named enumeration of integer constants. Unlike sum types found in some functional languages, each member of an enum in Yurt is associated with an integer discriminant, making it similar to C-style enums. The syntax for declaring an enum is:</p>
<pre><code class="language-bnf">&lt;enum-decl-item&gt; ::= &quot;enum&quot; &lt;ident&gt; &quot;=&quot; &lt;ident&gt; ( &quot;|&quot; &lt;ident&gt; )*
</code></pre>
<p>For example, <code>enum Colour = Red | Green | Blue;</code> declares an enum with three variants. An instantiation of a <code>Colour</code> can be created using a path that includes the name of the enum, as in <code>Colour::Green;</code>.</p>
<p>Each enum variant must be assigned a discriminant that matches the index of its location, starting with <code>0</code>, in the sequence of variants as they appear in the enum declaration. An enum variant can be converted to an integer that is equal to its assigned discriminant using <code>as</code>.</p>
<h3 id="solve-items"><a class="header" href="#solve-items">Solve Items</a></h3>
<p>Every intent must have at most one solve item. Solve items have the following syntax:</p>
<pre><code class="language-bnf">&lt;solve-item&gt; ::= &quot;solve&quot; &quot;satisfy&quot;
               | &quot;solve&quot; &quot;minimize&quot; &lt;expr&gt;
               | &quot;solve&quot; &quot;maximize&quot; &lt;expr&gt;
</code></pre>
<p>Example solve items:</p>
<pre><code class="language-yurt">solve satisfy;
solve maximize a + b - c;
</code></pre>
<p>The solve item determines whether the intent represents a constraint satisfaction problem or an optimization problem. If a solve item is not present, the intent is assumed to be a satisfaction problem. For optimization problems, the given expression is the one to be minimized/maximized.</p>
<h3 id="interface-items"><a class="header" href="#interface-items">Interface Items</a></h3>
<p>Interface items contain lists of smart contract functions that a smart <a href="#contract-items">contract</a> can have (<a href="#interface-items">Interface Items</a>)</p>
<p>Interface items describe lists of smart contract functions, in the form of function signatures, that a contract can have. An interface item has the following syntax:</p>
<pre><code class="language-bnf">&lt;interface-item&gt; ::= &quot;interface&quot; &lt;ident&gt; &quot;{&quot; ( &lt;function-sig&gt; &quot;;&quot; )* &quot;}&quot;
</code></pre>
<p>For example, the following is a simple interface with 3 functions:</p>
<pre><code class="language-yurt">interface IERC20 {
    fn totalSupply() -&gt; int;
    fn balanceOf(account: int) -&gt; int;
    fn allowance(owner: int, spender: int) -&gt; int;
}
</code></pre>
<p>Interface functions are not callable directly. Instead, they have to be called through a <a href="#contract-items">contract</a>.</p>
<h3 id="contract-items"><a class="header" href="#contract-items">Contract Items</a></h3>
<p>Contract items describe actual deployed contracts with a known contract ID and a list of available functions. Contract items require a known integer ID and a list of function signatures. Contract can also &quot;inherit&quot; functions from <a href="#interface-items">interfaces</a>. Contract items have the following syntax:</p>
<pre><code class="language-bnf">&lt;contract-item&gt; ::= &quot;contract&quot; &lt;ident&gt; &quot;(&quot; &lt;expr&gt; &quot;)&quot;
                    [ &quot;implements&quot; &lt;path&gt; ( &quot;,&quot; &lt;path&gt; )* ]
                    &quot;{&quot; ( &lt;function-sig&gt; &quot;;&quot; )* &quot;}&quot;
</code></pre>
<p>For example, consider the contract item below:</p>
<pre><code class="language-yurt">contract MyToken(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48) implements IERC20, Ownable {
    fn foo() -&gt; int;
    fn bar() -&gt; int;
}
</code></pre>
<p>This contract is called <code>MyToken</code> and has an integer ID of <code>0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48</code>. The contract has the following functions:</p>
<ol>
<li>All the functions declared in the <code>IERC20</code> interface.</li>
<li>All the functions declared in the <code>Ownable</code> interface.</li>
<li>All the functions declared in the body of the contract, namely <code>foo()</code> and <code>bar()</code>.</li>
</ol>
<p>A call to any of these functions can be made using a <code>&lt;call-expr&gt;</code> with the name of the contract used in <code>&lt;path&gt;</code>. For example, <code>MyToken::foo()</code>. Contract function calls <em>always</em> return values which must be bound to <a href="#state-declaration-items">state variables</a>, such as <code>state u = MyToken::foo()</code>.</p>
<h3 id="extern-items"><a class="header" href="#extern-items">&quot;Extern&quot; Items</a></h3>
<p>&quot;Extern&quot; items contain lists of function signatures that represent external APIs that can access data on a blockchain. More specifically, for the Ethereum blockchain, the functions should match the <a href="https://ethereum.github.io/execution-apis/api-documentation/">JSON-RPC methods</a> that all Ethereum clients must implement.</p>
<p>The syntax for extern items is as follows:</p>
<pre><code class="language-bnf">&lt;extern-item&gt; ::= &quot;extern&quot; &quot;{&quot; ( &lt;function-sig&gt; &quot;;&quot; )* &quot;}&quot;
</code></pre>
<p>For example:</p>
<pre><code class="language-yurt">extern {
    fn eth_getBalance(address: string) -&gt; string;

    fn eth_gasPrice() -&gt; string;
}
</code></pre>
<p>The types used in the signature of <code>extern</code> functions depend on the types used by the external APIs. In the case of Ethereum JSON-RPC, a string is used to encode all values, hence a <code>string</code> type must be used in the <code>extern</code> block.</p>
<p>Extern functions are available directly without any special scoping. The only requirement is that the functions are called in the same file where the <code>extern</code> block is declared or that the functions are imported using an <a href="#import-items">import item</a>, similarly to regular functions.</p>
<h3 id="new-type-items"><a class="header" href="#new-type-items">&quot;New Type&quot; Items</a></h3>
<p>New Type items introduce a distinct type that is not directly interchangeable with its underlying type or other new types based on the same underlying type.</p>
<p>The syntax for declaring a new type is:</p>
<pre><code class="language-bnf">&lt;new-type-item&gt; ::= &quot;type&quot; &lt;ident&gt; &quot;=&quot; &lt;ty&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-yurt">type AccountTuple = { id: int, balance: real, address: string };

type IdArray = int[5];

type Address = string;
</code></pre>
<p>In the above declarations:</p>
<p><code>AccountTuple</code> is a new type for a <code>tuple</code> type to represent the account's ID, balance, and address. <code>IdArray</code> is a new type for an <code>array</code> type to represent a list of account ids. <code>Address</code> is an new type for the <code>string</code> type to represent blockchain addresses or other specific string-based identifiers.</p>
<p>New type values may be initialized through:</p>
<ul>
<li>
<p>Expressions that conform to the new type's structure (such as tuple and array expressions). For instance, <code>{ x: .. }</code> for tuples or <code>[1, y, .. ]</code> for arrays.</p>
</li>
<li>
<p>Literals of primitive types (<code>int</code>, <code>real</code>, <code>bool</code>, <code>string</code>) as long as they are compatible with the new type's underlying definition.</p>
</li>
</ul>
<pre><code class="language-yurt">let walletDetails: AccountTuple = {id: 1, balance: 2.0, address: &quot;0x1234...ABCD&quot;};

let ids: IdArray = [1, 2, 3, 4, 5];

let myAddress: Address = &quot;0x1234567890abcdef&quot;;
</code></pre>
<h2 id="language-backend"><a class="header" href="#language-backend">Language Backend</a></h2>
<p>The backend of the DSL (or API) that we're building is effectively a Constraint Programming Solver, simply referred to as a &quot;solver&quot; in this documentation. Note, this should not be confused with the &quot;solver&quot; agent in the network. There are numerous commercial solvers that can be targeted, such as <a href="https://developers.google.com/optimization/">OR-Tools</a>, <a href="https://www.gecode.org/">Geocode</a>, and <a href="https://github.com/chuffed/chuffed">Chuffed</a>. We could decide on a standardized JSON output that is generated by the compiler and that can be read and subsequently <em>solved</em> by network participants using their solver of choice (not all solvers are created equal!).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../intro/transactions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../json/json_intents.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../intro/transactions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../json/json_intents.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/yurt.js"></script>
        <script src="../theme/bnf.js"></script>


    </div>
    </body>
</html>
