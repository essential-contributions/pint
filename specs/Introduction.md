# Introduction

This document describes the motivation behind the _intent_-based Domain Specific Language (DSL) that we're proposing and the programming paradigm that this DSL will exhibit. The document will also provide some initial thoughts on the language primitives and basic syntax while looking at some common examples from DeFi.

## Motivation

There is a clear need for users of a blockchain to be able to reason about state transitions without having to specify what execution traces are required to achieve those state transitions. Existing protocols are designed with _transactions_ as their most fundamental unit. In contrast, an _intent_ is a higher level concept than a transaction and can be described in a few different ways. [Anoma's white paper](https://github.com/anoma/whitepaper/blob/main/whitepaper.pdf) defines an intent as follows:

> An _intent_ is an expression of what a user wants to achieve whenever they interact with a protocol, for instance "transfer X from A to B" or "trade X for Y". Practically, an intent is an off-chain signed message that encodes which state transitions a user wants to achieve. Unlike transactions, intents are partial, so one can think of intents as parts of transactions that require other direct or indirect parts as complements in order to form a final balanced transaction which satisfies all users' constraints.

To this day, we do not have a **formal** definition of what an intent is. The above definition is quite vague and seems to indicate that an intent is a _declarative_ concept. Conversely, and at the most fundamental level, we could think of a _basic intent_ as a "state transition requirement" which can be composed into _higher level intents_ as needed. For example, a simple transfer of `x` USDC from address `a` to address `b` on Ethereum is effectively a decrease in the balance of A by `x` and an increase in the balance of `b` by `x`. The balances of `a` and `b` are stored at specific known locations in _storage_ and so, at the most fundamental level, a simple ERC20 token transfer is a _constraint_ on the differential between the **end state** and the **start state** of the Ethereum chain.

This constraint on state does **not** enforce a single transfer. It only enforces a state change and does not concern itself with how to get there (unless additional constraints are provided). In our example, a single transfer of `x` USDC from `a` to `b` is only one way of satisfying the constraint. Another way could be crafting _two_ transfers from `a` to `b`, each transferring `x/2` USDC.

Clearly, crafting two transactions is not desirable in this case because the total gas fees of two transfers is higher than the gas fees of a single transfer. The point, however, is that there will _usually_ be multiple ways of satisfying a constraint (or a set of constraints) on the state change.

In order to limit the space of possible execution traces that a solver might generate, a utility function could be introduced and optimized over the space of feasible execution traces. For example, the user might want to minimize the amount of gas used by the execution trace generated by the solver.

If we are able to express basic intents using constraints on the state change, then we can build a set of libraries that help express higher level intents more concisely.

With the above in mind, there are a few crucial questions that we need to answer:

1. Is describing common intents, such as transfers, and swaps, using constraints on state, a tractable problem?
1. Can solving for execution traces that satisfy the constraints, and optimize an optional utility function, be done in a reasonable amount of time?
1. Do we need a DSL to be able to describe such intents? Or is building an API using an existing language sufficient?

## A (not so) Formal Definition of Intents

Below is an attempt to formalize "intents" that is mostly inspired by the discussion in [this thread from Skip](https://ideas.skip.money/t/a-formal-ish-definition-for-intents/73). We hope that a formal definition will help answer the questions presented in the previous section.

For simplicity, we start by limiting the scope of the problem to a single blockchain. Each sequence of transactions $t_1, \ldots, t_k$ on a given blockchain is effectively a transition from some state $s_0$ to some other state $s_k$ such that transaction $t_j$ transitions the state from state $s_{j-1}$ to state $s_j$. In this context, the state refers to the **full** state of the blockchain. For Ethereum, this would be the `Eth` balance of each account as well as its _storage_, if the account is a "contract account".

Following the definition of the previous section, an intent can be specified as follows:

1. A constraint on the initial state: $s_0 \in S_0$ for some $S_0$.
1. A constraint on the final state: $s_k \in S_k$ for some $S_k$.

We can also imagine a user wanting to constraint the intermediate state:

$$s_i \in S_i, \quad i = 1, \ldots, k-1$$

A user may also want to constraint the transactions themselves:

$$t_j \in T_j, \quad j = 1, \ldots, k$$

An intent may also require optimizing a particular utility function $u(s_0, \ldots, s_k, t_1, \ldots, t_k)$. Without loss of generality, we assume that users want to minimize $u$, so that an intent can then be described using the following optmization problem:

$$
\begin{aligned}
& \text{minimize}   && u(s_0, \ldots, s_k, t_1, \ldots, t_k) \\
& \text{subject to} && s_i \in S_i, & i = 0, \ldots, k \\
&                   && t_j \in T_j, & j = 1, \ldots, k \\
&                   && s_j = \tau(s_{j-1}, t_j), & j = 1, \ldots, k
\end{aligned}
$$

where $\tau$ is the state transition function of our blockchain. The last constraint requires that $s_j$ is result of applying the state transition function on the previous state $s_{j-1}$ and transaction $t_j$.

Note that, while the value of $k$ is fixed in the optimization problem above, this is usually not the case. The user does not typically care about how many transactions are needed to achieve a particular state transition. If $\Omega$ is the space of all possible transactions that can be crafted, then the true space of possible execution traces is:

$$\bigcup_{i=0}^{\infty} \Omega^i = \phi \cup \Omega \cup \Omega^2 \cup \ldots $$

Naturally, it's virtually impossible to search through the space of execution traces above. There has to be some reasonable limits imposed by the user or by the solver to make the problem more solvable.

## Intents in the DSL

Given the above, our DSL (or API) should be able to express a more precise variation of the general optimization problem described in the previous section. The first task would be to figure out a way to represent **state** in our program. Of course, there is no sense in modeling the _full_ state of the blockchain in each program. It should be sufficient to only model the states that are impacted. For example, in the case of a simple `Eth` transfer from account `a` to account `b`, there are only two state variables we're interested in: the `Eth` balance of `a` and the `Eth` balance of `b`. If we were to describe a simple transfer in the style of a constraint programming language like [MiniZinc](https://www.minizinc.org/doc-2.7.3/en/index.html), we would get the following:

```solidity
/* These are constants */
int: amount = 3e18;
address: a = 0x1111111111111111111111111111111111111111
address: b = 0x2222222222222222222222222222222222222222

/* These are decision variables */
var float: eth_a;
var float: eth_a_next;
var float: eth_b;
var float: eth_b_next;
var transaction: t;

/* These are our constraints */
constraint eth_a - eth_a_next = amount;
constraint eth_b_next - eth_b = amount;
constraint eth_a = eth_balance(a);
constraint eth_b = eth_balance(b);
constraint eth_a_next = eth_transition(eth_a, t);
constraint eth_b_next = eth_transition(eth_b, t);

/* No utility function specified so only solve a satisfiablity problem */
solve satisfy;
```

Now there are a few ambiguous elements in the program above:

1. The `transaction` type: it is not yet clear whether transactions need their own type or whether they can be described using a vector of parameters for a given chain.
1. The method `eth_balance` is an external call to a specific chain (in this case Ethereum). In the case of an ERC20 token this becomes a call to `balanceOf` from the ERC20 token contract. This may present a challenge to the solvers.
1. The method `eth_transition` is the most ambiguous and represents the state transition function $\tau$ described in the previous section. The whole purpose of calling `eth_transition` is to enforce the fact that `eth_a_next` is the result of executing transaction `t` on the Ethereum blockchain starting with `eth_a`.

## Satisfying Intents
