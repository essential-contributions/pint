# Introduction

This chapter describes the motivation behind the intent-centric Domain Specific Language (DSL) Yurt and the programming paradigm that Yurt exhibits.

## Motivation

There is a clear need for users of a blockchain to be able to reason about state transitions without having to specify what execution traces are required to achieve those state transitions. Existing protocols are designed around the _transactions_ abstraction. In contrast, _intents_ are a different abstraction for on-chain operations that allow specifying some desired state transitions. [Anoma's white paper](https://github.com/anoma/whitepaper/blob/main/whitepaper.pdf) defines an intent as follows:

> An _intent_ is an expression of what a user wants to achieve whenever they interact with a protocol, for instance "transfer X from A to B" or "trade X for Y". Practically, an intent is an off-chain signed message that encodes which state transitions a user wants to achieve. Unlike transactions, intents are partial, so one can think of intents as parts of transactions that require other direct or indirect parts as complements in order to form a final balanced transaction which satisfies all users' constraints.

At the time of writing this, we do not have a **formal** definition of what an intent is. The above definition is quite vague and seems to indicate that an intent is a _declarative_ concept. Conversely, and at the most fundamental level, we could think of a _basic intent_ as a "state transition requirement" which can be composed into _higher level intents_ as needed. For example, a simple transfer of `x` USDC from address `a` to address `b` on Ethereum is effectively a decrease in the balance of A by `x` and an increase in the balance of `b` by `x`. The balances of `a` and `b` are stored at specific known locations in _storage_ and so, at the most fundamental level, a simple ERC20 token transfer is a _constraint_ on the differential between the **end state** and the **start state** of the Ethereum chain.

This constraint on state does **not** enforce a single transfer. It only enforces a state change and does not concern itself with how to get there (unless additional constraints are provided). In our example, a single transfer of `x` USDC from `a` to `b` is only one way of satisfying the constraint. Another way could be crafting _two_ transfers from `a` to `b`, each transferring `x/2` USDC.

Clearly, crafting two transactions is not desirable in this case because the aggregate gas fee of two transfers is higher than the gas fees of a single transfer. The point, however, is that there will _usually_ be multiple ways of satisfying a constraint (or a set of constraints) on the state change.

In order to limit the space of possible execution traces that a solver might generate, a utility function could be introduced and optimized over the space of feasible execution traces. For example, the user might want to maximize the value in USD of the tokens they will receive. The user might also want to minimize the amount of gas used by the execution trace generated by the solver, but that could be enforced by the protocol because it's a preference that likely all users will want to express.

If we are able to express basic intents using constraints on the state change, then we can build a set of libraries that help express higher level intents more concisely.

With the above in mind, there are a few crucial questions that we need to answer:

1. Is describing common intents, such as transfers, and swaps, using constraints on state, a tractable problem?
1. Can solving for execution traces that satisfy the constraints, and optimize an optional utility function, be done in a reasonable amount of time?
1. Do we need a DSL to be able to describe such intents? Or is building an API using an existing language sufficient?

## A (not so) Formal Definition of Intents

Below is an attempt to formalize "intents" that is mostly inspired by the discussion in [this thread from Skip](https://ideas.skip.money/t/a-formal-ish-definition-for-intents/73). We hope that a formal definition will help answer the questions presented in the previous section.

For simplicity, we start by limiting the scope of the problem to a single blockchain. Each sequence of transactions $t_1, \ldots, t_k$ on a given blockchain is effectively a transition from some state $s_0$ to some other state $s_k$ such that transaction $t_j$ transitions the state from state $s_{j-1}$ to state $s_j$. In this context, the state refers to the **full** state of the blockchain. For Ethereum, this would be the ETH balance of each account as well as its _storage_, if the account is a "contract account".

Following the definition of the previous section, an intent can be specified as follows:

1. A constraint on the initial state: $s_0 \in S_0$ for some $S_0$.
1. A constraint on the final state: $s_k \in S_k$ for some $S_k$.

We can also imagine a user wanting to constrain the intermediate state:

$$s_i \in S_i, \quad i = 1, \ldots, k-1$$

A user may also want to constrain the execution trace:

$$t_j \in T_j, \quad j = 1, \ldots, k$$

An intent may also require optimizing a particular utility function $u(s_0, \ldots, s_k, t_1, \ldots, t_k)$. Without loss of generality, we assume that users want to minimize $u$, so that an intent can then be described using the following optimization problem:

$$
\begin{aligned}
& \text{minimize}   && u(s_0, \ldots, s_k, t_1, \ldots, t_k) \\
& \text{subject to} && s_i \in S_i, & i = 0, \ldots, k \\
&                   && t_j \in T_j, & j = 1, \ldots, k \\
&                   && s_j = \tau(s_{j-1}, t_j), & j = 1, \ldots, k
\end{aligned}
$$

where $\tau$ is the state transition function of our blockchain. The last constraint requires that $s_j$ is result of applying the state transition function on the previous state $s_{j-1}$ and transaction $t_j$.

Note that, while the value of $k$ is fixed in the optimization problem above, this is usually not the case. The user does not typically care about how many transactions are needed to achieve a particular state transition. If $\Omega$ is the space of all possible transactions that can be crafted, then the true space of possible execution traces is:

$$\bigcup_{i=0}^{\infty} \Omega^i = \phi \cup \Omega \cup \Omega^2 \cup \ldots $$

Naturally, it's virtually impossible to search through the space of execution traces above. There have to be some reasonable constraints imposed by the user or by the solver to reduce the solution space.

## Intents in the DSL

Given the above, our DSL (or API) should be able to express a more precise variation of the general optimization problem described in the previous section. The first task would be to figure out a way to represent **state** in our program. Of course, there is no sense in modeling the _full_ state of the blockchain in each program. It should be sufficient to only model the states that are impacted. This implies that each intent needs to describe a **State Access List** (SAL) which will help reduce its complexity and allows for more efficient [batching of intents](#batching-intents) by solvers.

### Example 1

In the case of a simple ETH transfer from account `a` to account `b`, there are only two state variables we're interested in: the ETH balance of `a` and the ETH balance of `b`. If we were to describe a simple transfer in the style of a constraint programming language like [MiniZinc](https://www.minizinc.org/doc-2.7.3/en/index.html), we would get the following:

```solidity
/* These are constants */
int: amount = 3e18;
address: a = 0x1111111111111111111111111111111111111111;
address: b = 0x2222222222222222222222222222222222222222;

/* These are decision variables */
var float: eth_a;
var float: eth_a_next;
var float: eth_b;
var float: eth_b_next;
var transaction: t;

/* These are our constraints */
constraint eth_a - eth_a_next = amount;
constraint eth_b_next - eth_b = amount;
constraint eth_a = eth.balance(a);
constraint eth_b = eth.balance(b);
constraint eth_a_next = eth_transition(eth_a, t);
constraint eth_b_next = eth_transition(eth_b, t);

/* No utility function specified so only solve a satisfiablity problem */
solve satisfy;
```

Now there are a few ambiguous elements in the program above:

1. The `transaction` type: it is not yet clear whether transactions need their own type or whether they can be described using a vector of parameters for a given chain.
1. The method `eth.balance` is an external call to a specific chain (in this case Ethereum). In the case of an ERC20 token this becomes a call to `balanceOf` from the ERC20 token contract. This may present a challenge to the solvers.
1. The method `eth_transition` is the most ambiguous and represents the state transition function $\tau$ described in the previous section. The whole purpose of calling `eth_transition` is to enforce the fact that `eth_a_next` is the result of executing transaction `t` on the Ethereum blockchain starting with `eth_a`.

### Example 2

Another simple and common example is a token swap. Consider a user with address `a` who would like to swap some ETH in exchange for a minimum amount of DAI.

```solidity
/* These are constants */
int: eth_amount = 3e18;
int: min_dai_amount = 5400_000_000; // $1800 per ETH
address: a = 0x1111111111111111111111111111111111111111;

/* These are decision variables */
var float: eth;
var float: eth_next;
var float: dai;
var float: dai_next;
var transaction: t;

/* These are our constraints */
constraint eth - eth_next = eth_amount;
constraint dai_next - dai >= min_dai_amount;
constraint eth = eth.balance(a);
constraint dai = dai.balanceOf(a);
constraint eth_next = eth_transition(eth, t);
constraint dai_next = eth_transition(dai, t);

/* Maximize the amount of DAI received */
solve maximize dai_next - dai;
```

Note that the above is from the point of view of user `a` and does not enforce the exchange mechanism or entity. It is the responsibility of the _solver_ to figure out the best solution to the intent above: this could be interacting with a CFMM, matching the user with other users who are willing to be on the other side of this trade, or even taking the other side of the trade themselves. This also allows solvers to act as market makers if they are willing to take the other side of a swap which cannot be hedged immediately. This is closer to how market makers operate in traditional finance where they typically only reveal their liquidity on-demand.

## Satisfying Intents

Satisfying an intent is the process of solving the constraint programming problem that the user wrote to express the intent. A solver may decide to solve each intent individually or combine some of them into a single problem.

A solution that satisfies an intent is a _valid_ assignment of all the decision variables in the constraint program. The most important decision variables are the transactions that have to be signed and submitted in order to achieve the state transition requested by the user. Other decision variable may serve as a certificate that shows that indeed the solution provided by the solver satisfies the constraints. In the case where the intent is an optimization problem, the [_dual solution_](<https://en.wikipedia.org/wiki/Duality_(optimization)>) may be used to show optimality when strong duality holds.

### Intent Satisfaction Score

An interesting application of the intent-based framework is _scoring_ acceptable execution traces generated by solvers and rewarding them based on that score. This can potentially be done by introducing a decision variable describing the score and framing the problem in a way to assign high scores for better outcomes. Here's how that would look like for [Example 2](example-2):

```solidity
/* These are constants */
int: eth_amount = 3e18;
int: min_dai_amount = 5400_000_000; // $1800 per ETH
int: optimal_dai_amount = 5700_000_000; // $1900 per ETH
address: a = 0x1111111111111111111111111111111111111111;

/* These are decision variables */
var float: eth_a;
var float: eth_a_next;
var float: dai_a;
var float: dai_a_next;
var transaction: t;
var score: float;

/* These are our constraints */
constraint eth_a - eth_a_next = eth_amount;
constraint dai_a_next - dai_a >= min_dai_amount;
constraint eth_a = eth.balance(a);
constraint dai_a = dai.balanceOf(a);
constraint eth_a_next = eth_transition(eth_a, t);
constraint dai_a_next = eth_transition(dai_a, t);
constraint score >= 0.75 /\ score <= 1; // The score is just a percentage
constraint score = min(0.75 + 1 * (dai_a_next - dai_a) / optimal_dai_amount, 100)

/* Maximize the score */
solve maximize score;
```

What we've done is assign a score between 0.75 and 1 such that the score is 0.75 if the amount of DAI received is equal to `min_dai_amount` and the score is 1 if the amount of DAI received is `optimal_dai_amount` or higher. The user may then decide to assign a reward that is linked to `score`, such that solvers that are able achieve higher scores can claim a higher reward.

### Batching Intents

As we mentioned earlier, a solver may decide to combine multiple intents and solve them simultaneously. Consider the simple case of swaps with $m$ users and $n$ tokens. Each users $i$ submits an intent to trade $x_{ij_i}$ amount of token $j$ with at least $y_{ik_i}$ amount of token $k$. The constraint satisfaction problem submitted by user $i$ may look like:

$$
\begin{aligned}
e(i, j_i) - s(i, j_i) = x_{ij_i}\\
e(i, k_i) - s(i, k_i) \geq y_{ik_i}\\
\end{aligned}
$$

where $s$ and $e$ are functions that return the "start" and "end" balances respectively. That is, $s(i, j_i)$ is the start $j$ token balance of user $i$ _before_ the intent is submitted and $e(i, j)$ is the $j$ token balance of user $i$ after the intent is satisfied.

A solver can then combine all $m$ intents from the users into a single optimization problem as follows:

$$
\begin{aligned}
& \text{maximize}   && u(e(1, k_1), \ldots, e(m, k_m))  \\
& \text{subject to} && e(i, j_i) - s(i, j_i) = x_{ij_i}, & i = 1, \ldots, m \\
&                   && e(i, k_i) - s(i, k_i) \geq y_{ik_i} & i = 1, \ldots, m \\
\end{aligned}
$$

where $u$ is some utility function. A reasonable and simple utility function would be the linear function $u(e) = \pi^T e$ where $e$ is the vector of all $e(i, k_i)$. Here, $\pi_i$ could, for example, represent the price of token $k_i$ in USD so that $u$ is the total value, in USD, accrued to all the users. The solver can then attempt to figure out a sequence of transactions that satisfy the intent of each user while trying to maximize the "social welfare".

The optimization problem above is expressible using the DSL by following examples 1 and 2 from the previous section. We may find that additional primitives are needed, such as arrays, in order to make the DSL more ergonomic. Note that this batched constraint is composed by the solver as part of their algorithm.
