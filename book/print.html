<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Book of Pint</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="the-book-of-pint.html">The Book of Pint</a></li><li class="chapter-item expanded "><a href="getting_started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting_started/quickstart.html"><strong aria-hidden="true">1.2.</strong> Quickstart Guide</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/counter.html"><strong aria-hidden="true">2.1.</strong> Counter</a></li><li class="chapter-item expanded "><a href="examples/subcurrency.html"><strong aria-hidden="true">2.2.</strong> Subcurrency</a></li></ol></li><li class="chapter-item expanded "><a href="basics/index.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/variables.html"><strong aria-hidden="true">3.1.</strong> Decision Variables</a></li><li class="chapter-item expanded "><a href="basics/data_types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="basics/comments.html"><strong aria-hidden="true">3.3.</strong> Comments</a></li><li class="chapter-item expanded "><a href="basics/conditionals.html"><strong aria-hidden="true">3.4.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="basics/custom_types.html"><strong aria-hidden="true">3.5.</strong> Custom Types</a></li><li class="chapter-item expanded "><a href="basics/constants.html"><strong aria-hidden="true">3.6.</strong> Constants</a></li></ol></li><li class="chapter-item expanded "><a href="program_types/index.html"><strong aria-hidden="true">4.</strong> Program Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="program_types/stateless.html"><strong aria-hidden="true">4.1.</strong> Stateless Programs</a></li><li class="chapter-item expanded "><a href="program_types/contract.html"><strong aria-hidden="true">4.2.</strong> Smart Contracts</a></li></ol></li><li class="chapter-item expanded "><a href="storage/index.html"><strong aria-hidden="true">5.</strong> Storage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="storage/static.html"><strong aria-hidden="true">5.1.</strong> Statically-Sized Storage Types</a></li><li class="chapter-item expanded "><a href="storage/dynamic.html"><strong aria-hidden="true">5.2.</strong> Dynamically-Sized Storage Types</a></li><li class="chapter-item expanded "><a href="storage/external.html"><strong aria-hidden="true">5.3.</strong> External Storage Access</a></li></ol></li><li class="chapter-item expanded "><a href="projects/index.html"><strong aria-hidden="true">6.</strong> Managing Growing Projects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="projects/packages.html"><strong aria-hidden="true">6.1.</strong> Pint Projects</a></li><li class="chapter-item expanded "><a href="projects/modules.html"><strong aria-hidden="true">6.2.</strong> Defining Modules</a></li><li class="chapter-item expanded "><a href="projects/paths.html"><strong aria-hidden="true">6.3.</strong> Paths for Referring to an item in a Module Tree</a></li><li class="chapter-item expanded "><a href="projects/use.html"><strong aria-hidden="true">6.4.</strong> Bringing Paths into Scope with the use Keyword</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/index.html"><strong aria-hidden="true">7.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/pub_vars.html"><strong aria-hidden="true">7.1.</strong> Public Decision Variables</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">8.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/keywords.html"><strong aria-hidden="true">8.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix/intrinsics.html"><strong aria-hidden="true">8.2.</strong> B - Compiler Intrinsics</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Book of Pint</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/essential-contributions/pint" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="the-book-of-pint"><a class="header" href="#the-book-of-pint">The Book of Pint</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>To get you started, this chapter discusses the following:</p>
<ul>
<li>Installing Pint</li>
<li>Writing your first Pint programs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>A prerequisite for installing and using <code>Pint</code> is the Rust toolchain. Platform-specific instructions for installing <code>rustup</code> can be found <a href="https://www.rust-lang.org/tools/install">here</a>. Then, install the Rust toolchain with:</p>
<pre><code class="language-console">$ rustup install stable
</code></pre>
<p>The Pint toolchain is built and tested against the latest <a href="https://github.com/rust-lang/rust/releases/latest"><code>stable</code> Rust toolchain version</a>. Ensure you are using the latest <code>stable</code> version of Rust with:</p>
<pre><code class="language-console">$ rustup update &amp;&amp; rustup default stable
</code></pre>
<h3 id="installing-from-cargo"><a class="header" href="#installing-from-cargo">Installing from <code>Cargo</code></a></h3>
<p>The Pint toolchain can be installed using <code>Cargo</code> with:</p>
<pre><code class="language-console">$ cargo install pint
</code></pre>
<p>You can update the toolchain with <code>Cargo</code> using:</p>
<pre><code class="language-console">$ cargo update pint
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="quickstart-guide"><a class="header" href="#quickstart-guide">Quickstart Guide</a></h2>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="example"><a class="header" href="#example">Example</a></h1>
<p>This chapter includes some basic examples that show how Pint code looks like:</p>
<ul>
<li><a href="examples/./counter.html">Counter</a></li>
<li><a href="examples/./subcurrency.html">Subcurrency</a></li>
</ul>
<p>We will go over each example line-by-line while briefly introducing new concepts. Later, however, we
will cover each new concept in depth in its own chapter. Therefore, the goal of this chapter is not
to teach you everything about Pint but to get you to (hopefully!) appreciate what Pint is capable
off.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="counter"><a class="header" href="#counter">Counter</a></h2>
<p>The &quot;counter&quot; is one of the simplest smart contracts that can be written in Pint. It showcases how a
contract can have multiple predicates and how it can declare and use <em>storage</em>.</p>
<pre><code class="language-pint">storage {
    counter: int,
}

predicate Initialize {
    var value: int;
    state counter: int = storage::counter;
    constraint counter' == value;
}

predicate Increment {
    var amount: int;
    state counter: int = storage::counter;
    constraint counter' == counter + amount;
}
</code></pre>
<p>The contract starts by declaring a <code>storage</code> block which contains a single storage variable called
<code>counter</code> of type <code>int</code> (i.e. integer). The contract later declares two separate predicates, each
declaring three statements. Let's walk through the first predicate named <code>Initialize</code>:</p>
<ol>
<li>The first statement declares a <strong>decision variable</strong>. Decision variables are quite different from
&quot;regular&quot; variables which you might be familiar with from imperative languages. Decision
variables are variables that the <em>solver</em> is required to <em>find</em> values for. You can think of them
as &quot;arguments&quot; that the solver has to set such that <em>every</em> <code>constraint</code> in the predicate
evaluates to <code>true</code>. In <code>Initialize</code>, we are declaring a single decision variable called <code>value</code>
of type <code>int</code>. This is the value that we want our counter to get initialized to.</li>
<li>The second statement declares a <code>state</code> variable and initializes it to <code>storage::counter</code>. State
variables are special variables that always need to be initialized to a <em>storage</em> access
expression. The statement <code>state counter: int = storage::counter</code> creates a state variable called
<code>counter</code> and initializes it to the current value of <code>counter</code> declared in the <code>storage</code> block.</li>
<li>The third statement contains the core logic of this predicate. It <strong>declares</strong> that the &quot;next
value&quot; of <code>state counter</code> <strong>must</strong> be equal to <code>value</code>. Note the <code>'</code> notation here which can be
only applied to a <code>state</code> variable, and means &quot;the next value of the state variable after a valid
state transition&quot;.</li>
</ol>
<p>The second predicate, called <code>Increment</code>, has a similar structure to <code>Initialize</code>. However, instead
of initializing <code>counter</code>, It increments it by <code>amount</code>. Note that both <code>counter</code> (the current
value) and <code>counter'</code> (the next value) are both used in the constraint to enforce that the next
value is dependent on the current value, which was not the case in <code>Initialize</code>.</p>
<h3 id="solution"><a class="header" href="#solution">Solution</a></h3>
<p>We won't go too deep into the solving process here but it's worth mentioning what a <strong>solution</strong> to
this predicate might look like. Broadly speaking, a solution contains two things:</p>
<ol>
<li>An assignment of all the decision variables in the predicate.</li>
<li>A list of all the state mutations proposed.</li>
</ol>
<p>For example, if a user wants the value of the counter to be <code>42</code> they (or a solver acting on their
behalf) can propose a solution to <code>Initialize</code> that looks like this:</p>
<pre><code class="language-toml"># decision variables:
value: 42

# state mutations:
0x0000000000000000000000000000000000000000000000000000000000000000: 42
</code></pre>
<p>This solution proposes a value of <code>42</code> for the decision variable <code>value</code> and a new value of <code>42</code> for
the storage location <code>0x00...00</code> where <code>counter</code> is stored (we will go over the storage data layout
later!). A solution must also indicate which predicate is being solved using its address but we're
omitting that here for simplicity.</p>
<p>Alternatively, a solution to <code>Increment</code> can be proposed to satisfy the user requirement <code>counter = 42</code>. For example, if the current value of <code>counter</code> happens to be <code>35</code>, then the following solution
to <code>Increment</code> can be proposed:</p>
<pre><code class="language-toml"># decision variables:
amount: 7

# state mutations:
0x0000000000000000000000000000000000000000000000000000000000000000: 42
</code></pre>
<p>It should be easy to verify that this solution satisfies the constraint <code>counter' == counter + amount;</code> from <code>Increment</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="subcurrency"><a class="header" href="#subcurrency">Subcurrency</a></h2>
<p>The following contract implements the simplest form of a cryptocurrency. The contract allows the
creation of new coins (i.e. minting) as well as sending coins from one address to another.</p>
<pre><code class="language-pint">storage {
    total_supply: int,
    balances: (b256 =&gt; int),
}

// Sends an amount of newly created coins to an address
predicate Mint {
    var receiver: b256;
    var amount: int;

    state receiver_balance = storage::balances[receiver];
    state total_supply = storage::total_supply;

    constraint total_supply' == total_supply + amount;
    constraint receiver_balance' == receiver_balance + amount;
}

// Sends an amount of existing coins from address `from` to address `receiver`
predicate Send {
    var from: b256;
    var receiver: b256;
    var amount: int;

    state from_balance = storage::balances[from];
    state receiver_balance = storage::balances[receiver];

    constraint amount &lt; from_balance;
    constraint from_balance' == from_balance - amount;
    constraint receiver_balance' == receiver_balance + amount;
}
</code></pre>
<p>This contract introduces some new concepts. Let's walk through it line by line.</p>
<p>The contract starts with a <code>storage</code> declaration that contains two storage variables:</p>
<ol>
<li><code>total_supply</code> is of type <code>int</code> and represents the total supply of coins available at any given
point in time.</li>
<li><code>balances</code> is a <strong>map</strong> from <code>b256</code> to <code>int</code> and stores balances of addresses as integers. <code>b256</code>
is a primitive type that represents a 256-bit hash value and is used here to represent an
address.</li>
</ol>
<p>The contract also declares two predicates: <code>Mint</code> and <code>Send</code>.</p>
<p>The <code>Mint</code> predicate is fairly simple:</p>
<ol>
<li>It declares two decision variables <code>receiver: b256</code> and <code>amount: int</code>. The goal of this predicate
to mint <code>amount</code> coins and send them to <code>receiver</code>.</li>
<li>It initializes a <code>state</code> variable called <code>receiver_balance</code> using the storage access expression
<code>storage::balances[receiver]</code>. This syntax returns the value in <code>balances</code> that <code>receiver</code> maps
to. The predicate also initializes another state variable called <code>total_supply</code> to
<code>storage::total_supply</code>.</li>
<li>It enforces two constraints:
<ol>
<li>the first constraint requires the total supply to be incremented by <code>amount</code>.</li>
<li>The second constraint requires the balance of <code>receiver</code> to be incremented by <code>amount</code>.</li>
</ol>
</li>
</ol>
<p>The <code>Send</code> predicate has the following structure:</p>
<ol>
<li>It declares three decision variables <code>from: b256</code>, <code>receiver: b256</code>, and <code>amount: int</code>. The goal
of this predicate to send <code>amount</code> coins from address <code>from</code> to address <code>receiver</code>.</li>
<li>It initializes a <code>state</code> variable called <code>from_balance</code> to the balance of <code>from</code> and another
variable called <code>receiver_balance</code> to the balance of <code>receiver</code>.</li>
<li>It enforces three constraints
<ol>
<li>the first constraint requires <code>from_balance</code> to be larger than <code>amount</code>. That is, the address
<code>from</code> must currently actually have enough coins to send to <code>receiver</code>.</li>
<li>The second constraint effectively decrements the balance of <code>from</code> by <code>amount</code>, by requiring
the next state of <code>from_balance</code> to be <code>from_balance - amount</code>.</li>
<li>The third constraint effectively increments the balance of <code>receiver</code> by <code>amount</code>, by
requiring the next state of <code>receiver_balance</code> to be <code>receiver_balance + amount</code>.</li>
</ol>
</li>
</ol>
<blockquote>
<p><strong>Note</strong> to make things simpler and easier to understand, this contract has no <em>authentication</em>
anywhere in its code. That is, anyone can mint new coins and initiate a transfer from one
arbitrary address to another. This, of course, is not the desired behavior for most
cryptocurrencies. That being said, we will cover authentication in a later chapter and discuss how
to use authentication make this contract more secure.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="common-programming-concepts"><a class="header" href="#common-programming-concepts">Common Programming Concepts</a></h1>
<p>This chapter covers concepts that appear in almost every programming language and how they work in
Pint. Many programming languages have much in common at their core. None of the concepts presented
in this chapter are unique to Pint, but we’ll discuss them in the context of Pint and particularly
how they work in a constraint-based environment as opposed to imperative environments that you might
be more familiar with.</p>
<p>Specifically, you’ll learn about decision variables, basic types, custom types, comments, and
conditionals. These foundations will be in every Pint program, and learning them early will give you
a strong core to start from.</p>
<blockquote>
<p><strong>Keywords:</strong> The Pint language has a set of keywords that are reserved for use by the language
only, much as in other languages. Keep in mind that you cannot use these words as names of
variables, predicates, types, or macros. Most of the keywords have special meanings, and you’ll be
using them to do various tasks in your Pint programs; You can find a list of the keywords in
<a href="basics/../appendix/keywords.html">Appendix A</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="decision-variables"><a class="header" href="#decision-variables">Decision Variables</a></h2>
<p>A decision variable is a named variable that every solution is required to assign a value for.
Decision variables are quite different from &quot;regular&quot; variables that you might be used to in
imperative programming languages. Decision variables do not get &quot;computed&quot; or &quot;assigned to&quot; in a
Pint program since a Pint program is <strong>not actually executed but solved</strong> (and later validated
against a solution).</p>
<p>Decision variables can be declared using the <code>var</code> keyword and may be annotated with a type. We will
go over the available data types in Pint, in detail, in a later chapter.</p>
<p>Here's an example that shows how to declared a decision variable named <code>foo</code> of type <code>int</code>:</p>
<pre><code class="language-pint">var foo: int;
</code></pre>
<p>You can actually think of the type annotation as a &quot;constraint&quot; on the decision variable: this
decision variable can only take values in the set of signed integers (64-bit signed integers when
targeting the EssentialVM). Any solution that proposes a value of <code>foo</code> must satisfy that
constraint.</p>
<p>A decision variable can also be &quot;initialized&quot;. Initializing a decision variable may seem like an odd
concept because decision variables are declared to be solved for. However, an initialized decision
variable is simply a decision variable with an extra implicit constraint. Here's how an initialized
decision variable can be declared:</p>
<pre><code class="language-pint">var bar: int = 42;
</code></pre>
<p>The above is equivalent to:</p>
<pre><code class="language-pint">var bar: int;
constraint bar == 42;
</code></pre>
<p>We will go over <code>constraint</code> statements in more details later but it should hopefully be intuitive
that this statement enforces <code>bar</code> to be equal to <code>42</code>. Therefore, every proposed solution must also
set <code>bar</code> to <code>42</code>. Otherwise, this particular constraint will fail and the whole solution will be
deemed invalid.</p>
<p>Skipping the type annotation is only allowed if the decision variable is &quot;initialized&quot;:</p>
<pre><code class="language-pint">var baz = 43;
</code></pre>
<p>In this case, the compiler is able to <em>infer</em> the type of <code>baz</code> by realizing that the initializer
<code>42</code> is of type <code>int</code>.</p>
<p>Again, the above is equivalent to:</p>
<pre><code class="language-pint">var baz: int;
constraint baz == 43;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<p>Every value in Pint is of a certain <em>data type</em>, which tells Pint and solvers what kind of data is
being specified so they know how to work with that data. We'll look at two data type subsets: scalar
and compound.</p>
<p>Keep in mind that Pint is a <em>statically typed</em> language, which means that it must know the types of
all variables at compile time. The compiler can often infer what type we want to use based on the
value and how we use it. In cases where many types are possible, we must add a type annotation as
described in the <a href="basics/./variables.html">chapter on decision variables</a>.</p>
<h3 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h3>
<p>A <em>scalar</em> type represents a single value. Pint has four primary scalar types: integers, reals,
Booleans, and 256-bit hashes.</p>
<h4 id="integer-type"><a class="header" href="#integer-type">Integer Type</a></h4>
<p>An <em>integer</em> is a number without a fractional component. Pint has a single integer type called <code>int</code>
which, when targeting the EssentialVM, represents a <strong>64-bit signed integer</strong> . An <code>int</code>, therefore,
can store numbers from <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> inclusive, where <code>n</code> is the number of bits that
represent the integer (64 in the case of EssentialVM).</p>
<p>You can write integer literals in any of the forms shown in the table below. Note that number
literals can use <code>_</code> as a visual separator to make the number easier to read, such as <code>1_000</code>, which
will have the same value as if you had specified <code>1000</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Number literals</th><th>Examples</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>12_333</code></td></tr>
<tr><td>Hex</td><td><code>0x123f</code></td></tr>
<tr><td>Binary</td><td><code>0b1111_1101</code></td></tr>
</tbody></table>
</div>
<h4 id="real-type"><a class="header" href="#real-type">Real Type</a></h4>
<blockquote>
<p><strong>Note</strong> Pint only has preliminary support for reals</p>
</blockquote>
<p>Pint also has a type called <code>real</code> that represents real values. Real values are usually represented
in computers using floating-point or fixed-point numbers. Because Pint is essentially a constraint
modeling language, we do not specify exactly how a <code>real</code> is represented and we leave that decision
to the backend. What matters here is that a decision variable of type <code>real</code> is <em>not</em> constrained to
be an integer. This has implications on constraint solvers where, typically, solving for a
continuous variable (i.e. a real) is much easier than solving for an integer.</p>
<p>Here's an example that shows some decision variables initialized to real literals:</p>
<pre><code class="language-pint">var x = 1.05;
var y = 42e8;
var z = 2.5e-4;
var w: real = 1.3E5;
var u: real = 0.34;
</code></pre>
<h4 id="numeric-operations"><a class="header" href="#numeric-operations">Numeric Operations</a></h4>
<p>Pint supports the basic mathematical operations you’d expect for integers and reals: addition,
subtraction, multiplication, division, and remainder. Integer division truncates toward zero to the
nearest integer. The following code shows how you’d use each numeric operation in a <code>var</code> statement:</p>
<pre><code class="language-pint">// addition
var sum = 1 + 2 + 3;

// subtraction
var difference = 15.3 - 1e-1;

// multiplication
var product = 42 * 42;

// division
var quotient = 3.3/2.0;
var truncated = -5 / 3; // Results is -1

// remainder
var remainder = 34 % 3;
</code></pre>
<p>Note that binary operators in Pint are strict with regards to what types they allow, that is, only
identical types can be used in a binary operator. For example, adding an integer and a real is not a
valid operation and will result in a compile error.</p>
<h4 id="the-boolean-type"><a class="header" href="#the-boolean-type">The Boolean Type</a></h4>
<p>As in most other programming languages, a Boolean type in Pint has two possible values: <code>true</code> and
<code>false</code>. The Boolean type in Pint is specified using <code>bool</code>. For example:</p>
<pre><code class="language-pint">var t = true;
var f: bool = false;
</code></pre>
<h4 id="the-b256-type"><a class="header" href="#the-b256-type">The <code>b256</code> Type</a></h4>
<p>The <code>b256</code> is a special type that represents a 256-bit hash. It is often used to represent addresses
or storage keys and cannot be used as a numerical integers. That is, two <code>b256</code> values cannot added
for example.</p>
<p>A <code>b256</code> literals can be represented using a Hexadecimal or a Binary literal as follows:</p>
<pre><code class="language-pint">var addr1 = 0x3333333333333333333333333333333333333333333333333333333333333333;
var addr2: b256 = 0b1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111;
</code></pre>
<h3 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h3>
<p>Compound types can group multiple values into one type. Pint has two primitive compound types:
tuples and arrays.</p>
<h4 id="the-tuple-type"><a class="header" href="#the-tuple-type">The Tuple Type</a></h4>
<p>A tuple is a general way of grouping together a number of values with a variety of types into one
compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</p>
<p>We create a tuple by writing a comma-separated list of values inside curly brackets <code>{ .. }</code>. Each
position in the tuple has a type, and the types of the different values in the tuple don’t have to
be the same. We’ve added optional type annotations in this example:</p>
<pre><code class="language-pint">var tup_1: { int, real, bool } = { 42, 4.2, true };
</code></pre>
<p>The variable <code>tup</code> binds to the entire tuple because a tuple is considered to be a single compound
element. To get the individual values out of a tuple, we can use the period (<code>.</code>) operator followed
by the index of the value we want to access. For example:</p>
<pre><code class="language-pint">var tup_2: { int, real, bool } = { 42, 4.2, true };
var tup_2_first = tup_2.0;
var tup_2_second = tup_2.1;
var tup_2_third = tup_2.2;
</code></pre>
<p>This program creates the tuple <code>tup_2</code> and then accesses each element of the tuple using its
respective index. As with most programming languages, the first index in a tuple is 0.</p>
<p>It is also possible to name some or all the fields of a tuple type as follows:</p>
<pre><code class="language-pint">var tup_3: { x: int, real, y: bool } = { 42, 4.2, true };
</code></pre>
<p>Note that, in this example, only two out of the 3 fields are named. In order to access the
individual elements of a tuple with named fields, the period (<code>.</code>) can again be used with either the
index of the tuple field or its name. For example:</p>
<pre><code class="language-pint">var tup_4: { x: int, real, y: bool } = { 42, 4.2, true };
var tup_4_first = tup_4.0;
var tup_4_first_named = tup_4.x; // same as `tup_4.0`
var tup_4_second = tup_4.1;
var tup_4_third = tup_4.2;
var tup_4_third_named = tup_4.y; // same as `tup_4.y`
</code></pre>
<p>Tuples without any values are not allowed in <code>Pint</code>. That is, the following:</p>
<pre><code class="language-pint">var empty: { } = { };
</code></pre>
<p>is disallowed and errors out as follows:</p>
<pre><code class="language-console">Error: empty tuple types are not allowed
    ╭─[ch_3_2.pnt:43:12]
    │
 43 │ var empty: {} = {};
    │            ─┬
    │             ╰── empty tuple type found
────╯
Error: empty tuple expressions are not allowed
    ╭─[ch_3_2.pnt:43:17]
    │
 43 │ var empty: {} = {};
    │                 ─┬
    │                  ╰── empty tuple expression found
────╯
</code></pre>
<h4 id="the-array-type"><a class="header" href="#the-array-type">The Array Type</a></h4>
<p>Another way to have a collection of multiple values is with an array. Unlike a tuple, every element
of an array must have the same type. Unlike arrays in some other languages, arrays in Pint have a
fixed length.</p>
<p>We write the values in an array as a comma-separated list inside square brackets:</p>
<pre><code class="language-pint">var a = [1, 2, 3, 4, 5];
</code></pre>
<p>You write an array's type using the element type followed by its size between square brackets, like
so:</p>
<pre><code class="language-pint">var b: int[5] = [1, 2, 3, 4, 5];
</code></pre>
<p>Here, <code>int</code> is the type of each element. The number <code>5</code> indicates that the array contains five
elements.</p>
<p>You can access elements of an array using by <em>indexing</em> into it, like this:</p>
<pre><code class="language-pint">var c: int[5] = [1, 2, 3, 4, 5];
var c_first = c[0];
var c_second = c[1];
</code></pre>
<p>In this example, the variable named <code>c_first</code> will get the value <code>1</code> because that is the value at
index <code>0</code> in the array. The variable named <code>c_second</code> will get the value <code>2</code> from index <code>1</code> in the
array.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>All programmers strive to make their code easy to understand, but sometimes extra explanation is
warranted. In these cases, programmers leave comments in their source code that the compiler will
ignore but people reading the source code may find useful.</p>
<p>Here’s a simple comment:</p>
<pre><code class="language-pint">// hello, world
</code></pre>
<p>In Pint, the only comment style supported starts a comment with two slashes, and the comment
continues until the end of the line. For comments that extend beyond a single line, you’ll need to
include <code>//</code> on each line, like this:</p>
<pre><code class="language-pint">// This is some complicated code that requires multiple lines to explain:
// 1. The first predicate, called `GetRich` ensures that we're getting rich.
// 2. The second predicate, called `BeResponsible` ensures that 
//    we're not gambling all the money away.
</code></pre>
<p>Comments can also be placed at the end of lines containing code:</p>
<pre><code class="language-pint">var big_answer = 42; // answer to life, the universe, and everything
</code></pre>
<p>But you’ll more often see them used in this format, with the comment on a separate line above the
code it’s annotating:</p>
<pre><code class="language-pint">// answer to life, the universe, and everything
var big_answer_too = 42;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h2>
<p>Pint has three different ways to express conditionals: select expressions, <code>cond</code> expressions, and
<code>if</code> statements. Conditionals allow you to &quot;branch&quot; your code depending on some condition(s). The
word &quot;branch&quot; is between quotations because Pint is <strong>not</strong> an imperative language and does not
&quot;execute&quot; code. Therefore, conditionals are simply a way of saying: &quot;choose between some expressions
or some constraints based on some condition(s)&quot;.</p>
<h3 id="select-expressions"><a class="header" href="#select-expressions">Select Expressions</a></h3>
<p>A select expression allows you to select between two alternatives based on a condition. The two
alternatives must have the same type and that type determines the type of the whole select
expression. For example:</p>
<pre><code class="language-pint">var number: int;

var y = number &lt; 5 ? 1 : 2;
</code></pre>
<p>All select expressions start with a condition followed by the <code>?</code> symbol. In this case, the
condition checks whether or not the decision variable <code>number</code> has a value less than 5. We place the
expression that should be chosen if the condition is <code>true</code> immediately after the <code>?</code> symbol. The
symbol <code>:</code> is then added followed by the expression that should be chosen if the condition is
<code>false</code>. Both options, <code>1</code> and <code>2</code>, have the same type which is <code>int</code> and so, the type of <code>y</code> must
also be <code>int</code>.</p>
<p>If, for example, the types of the two expressions we're selecting from do not match, the compiler
will emit a compile error. For example, if we try to compile the following code:</p>
<pre><code class="language-pint">var number: int;

var y = number &lt; 5 ? 1 : 2.0;
</code></pre>
<p>we will get the following error:</p>
<pre><code class="language-console">Error: branches of a select expression must have the same type
   ╭─[test.pnt:3:9]
   │
 3 │ var y = number &lt; 5 ? 1 : 2.0;
   │                      ┬   ─┬─
   │                      ╰──────── 'then' branch has the type `int`
   │                           │
   │                           ╰─── 'else' branch has the type `real`
───╯
</code></pre>
<p>The condition of a select expression must be a <code>bool</code>. Otherwise, we will get a compile error. For
example, if we try to compile the following code:</p>
<pre><code class="language-pint">var number: int;

var y = number ? 1 : 2;
</code></pre>
<p>we will get the following error:</p>
<pre><code class="language-console">Error: condition for select expression must be a `bool`
   ╭─[test.pnt:3:9]
   │
 3 │ var y = number ? 1 : 2;
   │         ───┬──
   │            ╰──── invalid type `int`, expecting `bool`
───╯
</code></pre>
<p>Note that Pint will <strong>not</strong> automatically try to convert non-Boolean types to a Boolean. You must be
explicit and always provide a select expression with a <code>Boolean</code> as its condition.</p>
<h3 id="cond-expressions"><a class="header" href="#cond-expressions"><code>cond</code> Expressions</a></h3>
<p>Pint provides <code>cond</code> expressions. <code>cond</code> expressions are generalized select expressions that are not
limited to only two branches. They provide selection from multiple alternatives, each based on some
condition. For example:</p>
<pre><code class="language-pint">var x: int;
var z = cond {
    x == 0 =&gt; 0,
    x &gt; 0 &amp;&amp; x &lt;= 10 =&gt; 1,
    x &gt; 10 &amp;&amp; x &lt;= 100 =&gt; 2,
    else =&gt; 3
};
</code></pre>
<p>All <code>cond</code> expressions start with the keyword <code>cond</code>, followed by a comma-separated list of
statements in between curly brackets. Each statement describes a condition and an expression that
should be returned by the <code>cond</code> if that condition is correct. The branches are evaluated in order
and the first one to become active determines the value of the <code>cond</code> expression. If all branches
fail, then the <code>cond</code> expression takes the value of the expression in the <code>else</code> branch, which must
always be the last branch.</p>
<p>in the example above, <code>z</code> is equal to <code>0</code> if <code>x == 0</code>, equal to <code>1</code> if <code>x</code> is between <code>0</code> and <code>10</code>,
equal to <code>2</code> if <code>x</code> is between <code>10</code> and <code>100</code>, and equal to <code>3</code> otherwise.</p>
<p>every <code>cond</code> expression can be rewritten using one or more select expressions. however, <code>cond</code> tends
to be more compact and more readable than nested select expressions. for example, the <code>cond</code>
expression in the example above is equivalent to:</p>
<pre><code class="language-pint">var x: int;
var z = x == 0 ? 0 :
               x &gt; 0 &amp;&amp; x &lt;= 10 ? 1
                 : x &gt; 10 &amp;&amp; x &lt;= 100 ? 2 : 3;
</code></pre>
<p>similarly to select expressions, all candidate expressions must have the same type which determines
the type of the whole <code>cond</code> expression. also, every condition must be a <code>bool</code> or else a compile
error will be emitted.</p>
<h3 id="if-statements"><a class="header" href="#if-statements"><code>if</code> Statements</a></h3>
<p><code>if</code> statements are the last class of conditionals we will look at. Unlike select and <code>cond</code>
expressions, <code>if</code> statements are <strong>not</strong> expressions, that is, they do not hold any values. Instead,
they allow predicating <em>blocks of code</em> based on some condition. A block of code in the context of
an <code>if</code> statement is a collection of constraints and other <code>if</code> statements. For example:</p>
<pre><code class="language-pint">if number &lt; 5 {
    constraint x == y;
} else {
    constraint x != y;
}
</code></pre>
<p>All <code>if</code> statements start with the keyword <code>if</code>, followed by a condition. In this case, the
condition checks whether or not the decision variable <code>number</code> has a value less than 5. The code
block that should be &quot;active&quot; if the condition is <code>true</code> is placed immediate after the condition
inside curly brackets. Optionally, the keyword <code>else</code> is then added followed by the code block that
should be active if the condition is <code>false</code> (also between curly brackets). In the example above,
the <code>if</code> statement can be read as follows: &quot;if <code>number</code> is less than 5, then <code>x</code> must be equal to
<code>y</code>. Otherwise, <code>x</code> must not be equal to <code>y</code>&quot;.</p>
<p>Similarly to select expressions, the condition of an <code>if</code> statement must be a <code>bool</code>. Otherwise we
will get a compile error.</p>
<p><code>if</code> statements can be nested and can contain an arbitrary number of constraints:</p>
<pre><code class="language-pint">if number &lt; 5 {
    constraint x == y;

    if z &gt; 0 {
        constraint x &gt; number;
        constraint y &gt; number;
    }
} else {
    constraint x != y;

    if z &gt; 0 {
        constraint x &gt; number;
        constraint y &gt; number;
    } else {
        constraint x &lt; number;
        constraint y &lt; number;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h2>
<p>Custom data types are named types that you can define in your program to refer, via an alias, to a
primitive type, a compound type, or an <code>enum</code>. Enums are another special class of custom types that
define enumerations with named variants.</p>
<h3 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h3>
<p>Pint provides the ability to declare a type alias to give an existing type another name. For this we
use the <code>type</code> keyword. For example, we can create the alias <code>Balance</code> to <code>int</code> like so:</p>
<pre><code class="language-pint">type Balance = int;
</code></pre>
<p>Now, the alias <code>Balance</code> is a synonym for <code>int</code>. Values that have the type <code>Balance</code> will be treated
the same as values of type <code>int</code>:</p>
<pre><code class="language-pint">var x: int = 5;
var y: Balance = 5;
constraint x == y;
</code></pre>
<p>Because <code>Balance</code> and <code>int</code> are the same type, we can compare values of both types.</p>
<h3 id="defining-structs-using-type"><a class="header" href="#defining-structs-using-type">Defining structs using <code>type</code></a></h3>
<p>Many programming languages offer the concept of a &quot;struct&quot; which lets you <strong>package</strong> together and
<strong>name</strong> multiple related values that make up a meaningful group. While Pint does not offer a
special <code>struct</code> construct, it does offer a way to name a tuple, name its fields, and access its
elements as if it were a <code>struct</code>.</p>
<p>To define a struct-like tuple (which we will just call a struct going forward), we use the <code>type</code>
keyword followed by the name chosen for the tuple. We then use the <code>=</code> operator to bind the new type
name to a tuple type with all of its fields named.</p>
<p>For example:</p>
<pre><code class="language-pint">type User = {
    status: bool,
    address: b256,
    balance: int,
};
</code></pre>
<p>To use a struct after we’ve defined it, we create an instance of that struct by specifying concrete
values for each of the fields. We create an instance using the same tuple expression syntax: curly
brackets containing <em>key: value</em> pairs, where the keys are the names of the fields and the values
are the data we want to store in those fields. We don’t have to specify the fields in the same order
in which we declared them in the struct. In other words, the struct definition is like a general
template for the type, and instances fill in that template with particular data to create values of
the type. For example, we can declare a particular <code>User</code> as shown below:</p>
<pre><code class="language-pint">var user1: User = {
    status: true,
    address: 0x1111111111111111111111111111111111111111111111111111111111111111,
    balance: 42,
};
</code></pre>
<p>To get a specific value from a struct, we use the dot notation similarly to tuples. For example, to
access this user's balance, we use <code>user1.balance</code>.</p>
<h3 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h3>
<p>Enums allow you to define a type by enumerating its possible variants. Where structs and tuples give
you a way of grouping together related fields and data, like a <code>User</code> with its <code>status</code>, <code>address</code>,
and <code>balance</code>, enums give you a way of saying a value is one of possible set of values. For example,
we may want to say that <code>User</code> is one of a set of possible account types that also includes
<code>Contract</code>. To do this, Pint allows us to encode these possibilities as an <code>enum</code>.</p>
<p>Let’s look at a situation we might want to express in code and see why enums are useful. Say we need
to work with three possible tokens: DAI, USDC, and USDT. Because these are the only tokens we want
to work with, we can enumerate all possible variants, which is where enumeration gets its name:</p>
<pre><code class="language-pint">enum Token = DAI | USDC | USDT;
</code></pre>
<p>Note how the possible variants of <code>Token</code> are separated by a <code>|</code>. <code>Token</code> is now a custom data type
that we can use elsewhere in our code. Also, we can now create an instance of each of the three
variants of <code>Token</code> like this:</p>
<pre><code class="language-pint">var dai: Token = Token::DAI;
var usdc: Token = Token::USDC;
var usdt: Token = Token::USDT;
</code></pre>
<p>Note that the variants of the enum are namespaced under its identifier, and we use a double colon to
separate the two. This is useful because now all three values <code>Token::DAI</code>, <code>Token::USDC</code>, and
<code>Token::USDT</code> are of the same type: <code>Token</code>. We can then, for instance, declare a variable called
<code>token_type</code> to be of type <code>Token</code> and assign it to either variants depending on how large some
value <code>amount</code> is.</p>
<pre><code class="language-pint">var amount: int;
var token_type: Token = cond {
    amount in 0..1000 =&gt; Token::DAI,
    amount in 1001..2000  =&gt; Token::USDC,
    else  =&gt; Token::USDT,
};
</code></pre>
<p>We can even use enums inside structs as follows:</p>
<pre><code class="language-pint">type Bal = {
    token: Token,
    bal: int, 
};

var user1_bal = {
    token: Token::DAI,
    bal: 42, 
};

var user2_bal = {
    token: Token::USDC,
    bal: 96, 
};

var user3_bal = {
    token: Token::USDT,
    bal: 100, 
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Sometimes it may be desirable to use a common constant value for re-use throughout a program which
is not a decision variable to be solved. These may be declared in Pint using the <code>const</code> keyword.</p>
<p><code>const</code> declarations resemble <code>var</code> declarations in that they name an optionally typed value with an
initializer.</p>
<pre><code class="language-pint">const minimum: int = 10;
const maximum: int = 20;

var size: int;
constraint size &gt;= minimum &amp;&amp; foo &lt;= maximum;
</code></pre>
<p>Like <code>var</code> declarations the type may be ommitted and will be inferred by the Pint compiler, but the
<code>const</code> initializer is required and must a constant expression which does not refer to decision
variables nor other non-constant values such as state.</p>
<!--- Temporarily disabled.

### Constants of Compound Types

`const` declarations may refer to values with compound types as long as every element within is a
constant value. Constant value initializers may also dereference other array or tuple `const`
declarations or even array or tuple immediates.

```pint
//|const counts = [20, 30, 40];
//|
//|const default_idx = 1;
//|const next_count = counts[default_idx + 1];
//|
//|const min_size = { valid: true, size: 10 };
//|
//|var my_size: int;
//|constraint !min_size.valid || my_size >= min_size.size;
```

In the above example `next_count` is evaluated at compile time to be fixed as 40.

The `min_size` tuple is adding a flag to a value to mark whether it should be used or not in a
constraint. This may be convenient during development for turning the `min_size.size` constraint on
or off.

--->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="program-structure"><a class="header" href="#program-structure">Program Structure</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="statelss-contracts"><a class="header" href="#statelss-contracts">Statelss Contracts</a></h2>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="smart-contracts"><a class="header" href="#smart-contracts">Smart Contracts</a></h2>
<p>The most common use case for Pint is writing &quot;smart contracts&quot;. If you're familiar with smart
contract languages like <a href="https://soliditylang.org/">Solidity</a>, then many elements of a Pint contract
should feel familiar. Of course, at its core, Pint is fundamentally different from imperative smart
contract languages. Writing smart contracts in Pint requires a different way of thinking about how
to express the rules that the smart contract must enforce.</p>
<p>A Pint contract is a <strong>collection of predicates</strong>. Each predicate has a name and contains a list of
constraints. A contract may also contain a <code>storage</code> declaration which contain all the storage
variable that the contract owns. Contract storage is effectively the database of the contract where
persistent state lives. We will discuss storage in details in <a href="program_types/../storage/index.html">Chapter 5</a>.</p>
<h3 id="contract-structure"><a class="header" href="#contract-structure">Contract Structure</a></h3>
<p>The structure of a Pint smart contract is fairly simple. We simply lay out all the code blocks as
follows:</p>
<pre><code class="language-pint">storage {
    // storage variables
}

predicate Foo {
    // variables, constraints, etc.     
}

predicate Bar {
    // variables, constraints, etc.     
}

// other constraint sets
</code></pre>
<p>The order of the different blocks is not important, and the <code>storage</code> block is optional but most
useful smart contracts will need it.</p>
<p>Unlike imperative smart contracts where the logic lives in contract <em>methods</em> that can be <em>called</em>
to make state updates, Pint contracts have predicates (not methods/functions!) and nothing is ever
&quot;called&quot;. Instead, <em>solutions</em> have to submitted that satisfy one of the predicates in the contract.
A solution must specify concrete values for all the decision variables in the predicate, as well as
propose changes to the state. If the proposed state changes and the decision variables satisfy
<strong>all</strong> the constraints in that particular predicate, then the solution is deemed valid and the
proposed state changes are committed.</p>
<h3 id="contract-interfaces"><a class="header" href="#contract-interfaces">Contract Interfaces</a></h3>
<p>Each smart contract has an interface which can be easily generated from the contract. The interface
is not required to write the smart contract but is required to interact with the contract from
<em>external contexts</em>. For example, one smart contract can propose an update to a storage variables
that is owned by another contract. Will will go over how to do that in <a href="program_types/../storage/index.html">Chapter
5</a>.</p>
<p>A contract interface has the following structure:</p>
<pre><code class="language-pint">interface ExternalContract {
    storage {
        // storage variables
    }

    predicate Foo {
        // all **public** decision variables     
    }

    predicate Bar {
        // all **public** decision variables     
    }

    // other constraint sets
}
</code></pre>
<p>You can see the similarities between the structure of the interface and the structure of the smart
contract. An interface starts with <code>interface</code> keyword followed by the name of the interface which
can be used when referring the interface from external contexts. Inside the interface declaration,
an optional <code>storage</code> block can be declared as well as a list of <strong>predicate interfaces</strong>. These
predicate interfaces contain all the <strong>public</strong> decision variables that the predicates expose. We
will discuss public decision variables in detail in <a href="program_types/../advanced/pub_vars.html">Chapter 6.1</a>, but for
now, you can think of these variables as regular decision variable except that they can be read from
an external context.</p>
<p>Let's revisit the <a href="program_types/../examples/counter.html">counter example</a> but with a small modification where we
have made all decision variables <code>pub</code>, which marks them as public:</p>
<pre><code class="language-pint">storage {
    counter: int,
}

predicate Initialize {
    pub var value: int;
    state counter: int = storage::counter;
    constraint counter' == value;
}

predicate Increment {
    pub var amount: int;
    state counter: int = storage::counter;
    constraint counter' == counter + amount;
}
</code></pre>
<p>An interface for the contract above looks like this:</p>
<pre><code class="language-pint">interface Counter {
    storage {
        counter: int,
    }

    predicate Initialize {
        pub var value: int;
    }

    predicate Increment {
        pub var amount: int;
    }
}
</code></pre>
<p>Hopefully nothing here is surprising! The key point is that an <code>interface</code> must expose <em>everything</em>
that is public in a contract, and that includes the storage block and all public decision variables
in each predicate.</p>
<p>Note that, if a predicate <code>Foo</code> has no public decision variables, both <code>predicate Foo { }</code> and <code> predicate Foo;</code> can be used when adding it to the interface.</p>
<blockquote>
<p><strong>Note</strong> in the future, Pint will have a tool that will auto-generate interfaces.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>Most useful Pint contracts require some sort of <em>persistent storage</em> that represent <em>state</em>. After
all, a blockchain is a decentralized distributed database and contracts are a way to enforce rules
on how &quot;entries&quot; in this database are allowed to change. Therefore, having the ability to express
those database entries using variables and dynamic containers is quite useful. For that reason, Pint
offers a way to declare and access a variety of storage types.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>How to declare and access storage variables with statically-sized types.</li>
<li>How to declare and access storage variables with dynamically-sized types.</li>
<li>How to access storage variables that belong to an external contract.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="statically-sized-storage-types"><a class="header" href="#statically-sized-storage-types">Statically-Sized Storage Types</a></h2>
<p>All storage variables in a Pint contract must be declared inside a <code>storage</code> block, and there can
only be a single <code>storage</code> block in a Pint contract. The <code>storage</code> block is optional and can be
skipped if the contract does not need to manage any state, but such contracts are generally not very
useful.</p>
<p>Here's an example of a <code>storage</code> block:</p>
<pre><code class="language-pint">storage {
    x: int,
    a: b256,
    t: { int, bool },
    y: bool,
    w: int,
}
</code></pre>
<p>A <code>storage</code> starts with the keyword <code>storage</code> and followed by a comma-separated list of variable
declarations inside curly brackets. Each variable declaration is an identifier annotated with a
type. In this chapter, we're only looking at storage variables that have statically-sized types,
i.e., types that have known sizes and layouts at compile time. This pretty much covers every type we
discussed so far! In the next chapter, we will introduce new storage-only types that are dynamically
sized.</p>
<p>Back to the example above, the declared <code>storage</code> block is fairly simple. It contains three
variables that have primitive types and one variable that has a compound type (a tuple). Unlike
decision variables, storage variables do not accept an initializer and <strong>must</strong> have a type
annotation.</p>
<h3 id="accessing-storage-variables"><a class="header" href="#accessing-storage-variables">Accessing Storage Variables</a></h3>
<p>Storage variables are not useful unless we can read them and/or <em>propose modifications to them</em>.
Recall that Pint is a declarative constraint-based language, and therefore, does not allow &quot;writing&quot;
directly to a storage variable. Writing directly to storage is a concept you might be familiar with
from other smart contract languages like <a href="https://soliditylang.org/">Solidity</a>, so you might be
asking yourself the following question: &quot;if I can't write directly to storage variables, how will
their values ever change? How will the state of the blockchain ever change?&quot;</p>
<p>The answer to these questions lies at the core of what makes Pint and <em>declarative blockchains</em>
actually <strong>declarative</strong>. Pint has no concept of &quot;updating&quot; state (or even decision variables for
that matter). Pint simply <em>expresses</em> a desired outcome using <code>constraint</code> statements and relies on
<em>solutions</em> to actually propose state changes.</p>
<p>In order to express a desired outcome for a given storage variable, two things are needed:</p>
<ol>
<li>A way to read the <strong>current</strong> value of the variable.</li>
<li>A way to express the <strong>future</strong> value of the variable.</li>
</ol>
<h4 id="reading-a-storage-variable"><a class="header" href="#reading-a-storage-variable">Reading a Storage Variable</a></h4>
<p>Reading a storage variable should not be an unfamiliar concept to you if you've worked with other
smart contract languages before like <a href="https://soliditylang.org/">Solidity</a>. The syntax for reading a
storage variable in Pint requires the <code>storage</code> keyword again:</p>
<pre><code class="language-pint">state x = storage::x;
state a = storage::a;
state t = storage::t;
state t_1 = storage::t.1;
</code></pre>
<p>A few things to note here:</p>
<ol>
<li>Storage read expressions always start with <code>storage::</code> followed by the name of the variable we're
trying to read. The <code>storage::</code> syntax means we're switching namespaces to that of the <code>storage</code>
block.</li>
<li>Each storage read expression is used to initialize a <code>state</code> variable. In fact, storage read
expressions can <strong>only</strong> ever be used to initialize <code>state</code> variables. Using a storage read
expression in other contexts, such as in <code>constraint storage::x == 5</code>, is illegal.</li>
<li>Fields or elements of a compound type in storage can be accessed individually, as in
<code>storage::t.1</code>.</li>
</ol>
<p>We haven't really explained what a <code>state</code> variable is so this is probably a good time to do so.</p>
<h4 id="state-variables"><a class="header" href="#state-variables">State Variables</a></h4>
<p>A state variable is a special type of variables that can only hold values read from storage. A
<code>state</code> variable must <strong>always</strong> have an initializer and that initializer can only be a storage read
expression. Type annotations for <code>state</code> declarations are optional:</p>
<pre><code class="language-pint">state not_annotated = storage::x;
state annotated: b256 = storage::a;
</code></pre>
<p>Once a <code>state</code> variable is declared, it can be used anywhere in its scope as if it were a decision
variable:</p>
<pre><code class="language-pint">state t_0 = storage::t.0;
state y = storage::y;
constraint y &amp;&amp; t_0 &gt;= 42;
</code></pre>
<p>This is an example where two state variables are declared and later constrained as if they were
decision variables. One important distinction to note here is that <code>state</code> variables are not
actually <em>unknown</em>. By definition, decision variables are unknown at compile time <em>and</em> at
solve-time and they only become known <em>after</em> the solving process is finished (if a solution is
found). In contrast, <code>state</code> variables, while unknown at compile time, are actually known at
solve-time: right before the solving process starts, every storage read expression is evaluated by
directly inspecting the blockchain. The result is then assigned to the corresponding <code>state</code>
variable which becomes known in preparation for solving.</p>
<h4 id="next-state"><a class="header" href="#next-state">Next State</a></h4>
<p>Recall that expressing a desired outcome for a given storage variable also requires a way to express
the <strong>future</strong> value of the variable.</p>
<p>In most imperative languages, statements like <code>x = x + 1</code> are commonly used to mean &quot;<em>update</em> the
value of <code>x</code> to be equal to the <em>current</em> value of <code>x</code> plus <code>1</code>&quot;. Because Pint is a constraint-based
declarative language where the order of statements does not matter and there is no sequential
execution, statements like <code>x = x + 1</code> cannot be written and are not logical. Instead, Pint offers a
special syntax, reserved for <code>state</code> variables, that means &quot;the future value of&quot;. Here's an example:</p>
<pre><code class="language-pint">state bal = storage::x;
constraint bal' &gt;= bal + 42;
</code></pre>
<p>Here, <code>bal'</code>, unlike <code>bal</code>, is actually unknown at solve-time. That is, <code>bal'</code> must be solved for as
if it were a decision variable and every solution must include a proposed value for <code>bal'</code>. If, for
example, the value of <code>bal</code> was read to be <code>100</code> at solve-time, a solver might propose that the next
value of <code>bal</code> should be <code>150</code> (i.e. <code>bal' = 150</code>) which would be a valid solution because <code>150 &gt;= 100 + 42</code> (assuming all other constraints in the predicate are also satisfied).</p>
<p>This concludes our overview on storage which only focused on statically-sized storage types. In the
next chapter, we will cover dynamically-sized storage types which offer a lot more flexibility.</p>
<h4 id="empty-state"><a class="header" href="#empty-state">&quot;Empty&quot; State</a></h4>
<p>You may be wondering what happens if a storage variable was never previously updated but was read
anyways. In this case, there is no value stored at that storage variable and nothing can be read.
To help you reason about this, Pint provides the literal <code>nil</code> to represent the <em>absence of a
value</em>. For example,</p>
<pre><code class="language-pint">state w = storage::w;
var value: int = (w == nil ? 0 : w);
</code></pre>
<p>In the example above, we first check if <code>w</code> is <code>nil</code> before attempting to read it. If it is <code>nil</code>
(i.e. currently has no value), then we constrain <code>value</code> to <code>0</code>. Otherwise, we constrain it to the
non-empty value of <code>w</code>. Without checking if <code>w</code> is <code>nil</code> first, and if we're not sure whether <code>w</code>
has a value or not, then it is possible that the state read operation will panic.</p>
<p>It is also possible to update a <code>state</code> variable to <code>nil</code> using the &quot;next state&quot; operator:</p>
<pre><code class="language-pint">if w != nil {
    constraint w' == nil;
}
</code></pre>
<p>Here, if <code>w</code> currently has a value, then we constrain the next value of <code>w</code> to be <code>nil</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="dynamically-sized-storage-types"><a class="header" href="#dynamically-sized-storage-types">Dynamically-sized Storage Types</a></h2>
<p>Pint includes a number of very useful data structures called <em>storage collections</em>. Most other data
types represent one specific value, but storage collections can contain multiple values. Unlike the
built-in array and tuple types, the amount of data that these collections hold does not need to be
known at compile time and can grow or shrink as the blockchain state evolve. Each kind of collection
has different capabilities and costs, and choosing an appropriate one highly depends on the
situation at hand. In this chapter, we'll discuss two collections that are used very often in Pint
contracts:</p>
<ul>
<li><strong>Storage Map</strong>: allows you to associated a value with a particular key.</li>
<li><strong>Storage Vector</strong>: allows you to store a variable number of values.</li>
</ul>
<p>We'll discuss how to create and update storage maps and storage vectors.</p>
<h3 id="storage-map"><a class="header" href="#storage-map">Storage Map</a></h3>
<p>The first collection we will look at is the storage map. A storage map stores a mapping of keys of
some type <code>K</code> to values of some type <code>V</code> using a <em>hashing function</em>, which determines how it places
these keys and values in storage. Hash maps are useful when you want to look up data by using a key
that can be of any type. For example, in the <a href="storage/../examples/subcurrency.html">Subcurrency</a> contract, we
kept track of each user’s token balance in a map in which each key is a user’s address and the
values are each user’s balance. Given a user address, you can retrieve their balance.</p>
<h4 id="creating-a-new-storage-map"><a class="header" href="#creating-a-new-storage-map">Creating a New Storage Map</a></h4>
<p>Because storage maps are a storage type, they must always be declared inside a <code>storage</code> block.
The storage map type is a built-in type with a specific syntax:</p>
<pre><code class="language-pint">storage {
    // ...
    balances: (b256 =&gt; int),
    // ...
}
</code></pre>
<p>Here, a new storage map, called <code>balances</code>, is declared that maps <code>b256</code> keys to <code>int</code> values. The
storage map type is always declared using parentheses that contain two types separated by a <code>=&gt;</code>.
It should be clear that storage maps are <em>homogeneous</em>, that is, all of the keys must have the same
type as each other, and all of the values must have the same type as well.</p>
<h4 id="accessing-values-in-a-hashmap"><a class="header" href="#accessing-values-in-a-hashmap">Accessing Values in a HashMap</a></h4>
<p>We can get a value out of the storage map by providing its key in between square brackets, similar
to how arrays are accessed:</p>
<pre><code class="language-pint">var from_address: b256;
var receiver_address: b256;
state from_balance = storage::balances[from_address];
state receiver_balance = storage::balances[receiver_address];
</code></pre>
<p>Here, <code>from_balance</code> will have the value that's associated with <code>from_address</code> and
<code>receiver_balance</code> will have the value that's associated with <code>receiver_address</code>. Because the values
returned are storage values, we must assign them to <code>state</code> variables. Using a storage map access
expression in any other context results in a compile error.</p>
<h4 id="updating-a-storage-map"><a class="header" href="#updating-a-storage-map">&quot;Updating&quot; a Storage Map</a></h4>
<p>As we've mentioned a few times already, explicitly &quot;updating&quot; <em>anything</em> in Pint is not a valid
operation because Pint has no sequential execution. However, as in the case with statically-sized
storage types, we can <em>require</em> that the next value of a specific entry in a storage map satisfy
some constraint(s):</p>
<pre><code class="language-pint">var my_address: b256;
state my_bal = storage::balances[my_address];
constraint my_bal' == my_bal + 1000000;
</code></pre>
<p>Here, we're requiring that our balance go up by 1 million, by applying the &quot;prime&quot; operator on the
state variable that holds our current balance. Of course, requiring a change in state does not mean
it will actually happen! Otherwise, we can all become instantly rich by submitting predicates like
this. Unless a solution that does not violate any of the deployed rules (i.e. constraints) is
submitted by a solver, the desired state change will never be satisfied.</p>
<h4 id="missing-keys"><a class="header" href="#missing-keys">&quot;Missing&quot; Keys</a></h4>
<p>Now, you may be wondering what happens if a key is missing from a storage map and we try to access
it anyways. In Pint, a <a href="storage/static.html#empty-state"><code>nil</code></a> is returned. In the previous example, if the
balance of <code>my_address</code> was never actually modified in the past, then <code>my_bal</code> would be equal to
<code>nil</code> and therefore, the expression <code>my_bal + 1000000</code> would panic. To avoid this problem, we can
first check if <code>my_bal</code> is <code>nil</code> before trying to use it in an arithmetic operation:</p>
<pre><code class="language-pint">if my_bal != nil {
    constraint my_bal' == my_bal + 1000000;
} else {
    constraint my_bal' == 1000000;
}
</code></pre>
<p>Here, if <code>my_bal</code> is not <code>nil</code>, then the constraint remains the same as before. Otherwise, we simply
update <code>my_bal</code> to <code>1000000</code> (as if <code>my_bal</code> was previously 0!).</p>
<h4 id="complex-maps"><a class="header" href="#complex-maps">Complex Maps</a></h4>
<p>Storage maps can be declared to be arbitrarily complex. They can also be nested!</p>
<pre><code class="language-pint">storage {
    // ...
    complex_map: ( { int, int } =&gt; { bool, b256 } ),
    nested_map: (b256 =&gt; (int =&gt; bool)),
    // ...
}
</code></pre>
<p>In the example above, the fist storage map maps a tuple to another tuple. The second storage map
maps a <code>b256</code> to another map! The way to access entries in these maps should is fairly intuitive and
is exactly what you'd expect:</p>
<pre><code class="language-pint">state complex_read: b256 = storage::complex_map[{42, 69}].1;

var addr: b256;
state nested_read: bool = storage::nested_map[addr1][100];
</code></pre>
<p>The first storage access reads a tuple value using a key that itself is a tuple, and then accesses
its second field. The second storage access is a nested map access using two index operators. Note
that the first index operator accesses the first key (<code>b256</code> in this case) and the second index
operator accesses the second key (<code>int</code> in this case).</p>
<h4 id="illegal-uses-of-the-storage-map-type"><a class="header" href="#illegal-uses-of-the-storage-map-type">Illegal Uses of the Storage Map Type</a></h4>
<p>It may be tempting to write code like this:</p>
<pre><code class="language-pint">storage {
    // ...
    nested_map: (b256 =&gt; (int =&gt; bool)),
    // ...
}
var addr: b256;

state nested_map = storage::nested_map; // Expecting to return the &quot;whole&quot; map
state nested_map_inner = storage::nested_map[addr]; // Expecting to return the &quot;whole&quot; inner map
</code></pre>
<p>However, the compiler will disallow this by emitting the following errors:</p>
<pre><code class="language-console">Error: state variables cannot have storage map type
   ╭─[bad.pnt:8:1]
   │
 8 │ state nested_map = storage::nested_map; // Expecting to return the &quot;whole&quot; map
   │ ───────────────────┬──────────────────
   │                    ╰──────────────────── found state variable of type storage map here
───╯
Error: state variables cannot have storage map type
   ╭─[bad.pnt:9:1]
   │
 9 │ state nested_map_inner = storage::nested_map[addr]; // Expecting to return the &quot;whole&quot; inner map
   │ ─────────────────────────┬────────────────────────
   │                          ╰────────────────────────── found state variable of type storage map here
───╯
</code></pre>
<p>Hopefully the errors are clear enough. What the compiler is telling us here is that we cannot
declare <code>state</code> variables that hold entire storage maps. A storage map is not exactly an object that
we can store a reference to or copy/move around and state variables can only have statically-sized
types!</p>
<h3 id="storage-vector"><a class="header" href="#storage-vector">Storage Vector</a></h3>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="external-storage-access"><a class="header" href="#external-storage-access">External Storage Access</a></h2>
<p>It is common for one smart contract to want to reason about the state of another external smart
contract. For example, a Decentralized Exchange contract typically requires reading and modifying
the state (balances!) owned by the external contracts of the tokens that are being traded through
the exchange.</p>
<p>In imperative smart contract languages like <a href="https://soliditylang.org/">Solidity</a>, reasoning about
external state is typically done by <em>calling</em> some methods in the external contract that access or
modify that contract's state. In Pint however, the storage variables of a contract are <strong>public</strong>
and can be accessed from outside the contract using the contract's
<a href="storage/../program_types/contract.html#contract-interfaces">interface</a>.</p>
<h3 id="interface-instance"><a class="header" href="#interface-instance">Interface Instance</a></h3>
<p>While a contract's interface contains all the public symbols that can be externally accessed, it
does not specify the <em>address</em> of the contract. The <em>address</em> of a contract is 256-bit value that
uniquely identify the contract on the blockchain. Specifying the address is required because
multiple contracts with different addresses may share the same interface.</p>
<p>In order to specify which external contract to actually interact with, we need an <strong>interface
instance</strong>. Consider the <a href="storage/../examples/counter.html">counter example</a> that we presented earlier and its
interface that looks like this:</p>
<pre><code class="language-pint">interface Counter {
    storage {
        counter: int,
    }

    predicate Initialize;

    predicate Increment;
}
</code></pre>
<p>Assume that a contract with that interface has been deployed and has the following address:</p>
<pre><code class="language-pint">const ContractID: b256 = 0x0003000300030003000300030003000300030003000300030003000300030003;
</code></pre>
<p>In order to interact with that particular contract, we would first declare an interface instance as
follows:</p>
<pre><code class="language-pint">interface CounterInstance = Counter(ContractID);
</code></pre>
<h3 id="external-storage-access-using-the-interface-instance"><a class="header" href="#external-storage-access-using-the-interface-instance">External Storage Access Using the Interface Instance</a></h3>
<p>Now that we have an instance of the interface, we can use it to create a path to the external
storage variable. For example,</p>
<pre><code class="language-pint">state counter = CounterInstance::storage::counter;
</code></pre>
<p>Note that the path <code>CounterInstance::storage::counter</code> has three parts:</p>
<ol>
<li>The name of the interface instance <code>CounterInstance</code> that indicates which instance we would like
to access. Recall that there could be multiple interface instances, with different addresses, for
the same <code>interface</code>, hence the need to start the path with the name of the interface instance
and not the name of interface itself.</li>
<li>The keyword <code>storage</code> to indicate that we're accessing the <code>storage</code> block of <code>CounterInstance</code>.</li>
<li><code>counter</code>, the name of the storage variable we want to access.</li>
</ol>
<p>Once we have assigned the external storage expression to a <code>state</code> variable, we can then use that
variable as we usually do.</p>
<p>Similarly to local storage access expressions, the expression <code>CounterInstance::storage::counter</code>
can only be used on the right-hand side of a <code>state</code> declaration.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="managine-growing-projects"><a class="header" href="#managine-growing-projects">Managine Growing Projects</a></h1>
<p>As you write large programs, organizing your code will become increasingly important. By grouping
related functionality and separating code with distinct features, you’ll clarify where to find code
that implements a particular feature and where to go to change how a feature works.</p>
<p>As a project grows, you should organize code by splitting it into multiple <strong>modules</strong> and then
multiple files. You can also extract parts of a project into separate packages that become external
dependencies. This chapter covers all these techniques.</p>
<p>Pint has a number of features that allow you to manage your code’s organization, including which
details are exposed, which details are private, and what names are in each scope in your programs.
These features, sometimes collectively referred to as the module system, include:</p>
<ul>
<li><strong>Packages</strong>: A feature of the pint tool that lets you build, test, and share projects.</li>
<li><strong>Modules</strong> and <strong>use</strong>: Let you control the organization and scope of paths.</li>
<li><strong>Paths</strong>: A way of naming an item, such as a type, a macro, or a <code>const</code>.</li>
</ul>
<p>In this chapter, we’ll cover all these features, discuss how they interact, and explain how to use
them to manage scope. By the end, you should have a solid understanding of the module system.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="pint-packages"><a class="header" href="#pint-packages">Pint Packages</a></h2>
<p>The first part of the module system we’ll cover are packages.</p>
<p>A package is a bundle of one or more modules that provides a set of functionality. A package
contains a <code>pint.toml</code> file that describes how to build it.</p>
<p>Packages can come in one of two forms: a &quot;contract&quot; package and a &quot;library&quot; package. <em>Contract
packages</em> represent smart contracts that can be compiled to bytecode and deployed to a blockchain.
Each contract package must have a <code>contract.pnt</code> file in its <code>src</code> directory, which represents the
entry point of the contract. <em>Library packages</em> don't compile to bytecode. Instead, they define
functionality intended to be shared with multiple projects. The entry point of a library crate is
always a <code>lib.pnt</code> file in the <code>src</code> directory.</p>
<p>Let's walk through what happens when we create a package. First, we enter the command <code>pint new my-project</code>:</p>
<pre><code class="language-console">$ pint new my-project
     Created my-project [contract] (/path/to/my-project)
$ ls my-project
pint.toml src
$ ls my-project/src
contract.pnt
</code></pre>
<p>After we run <code>pint new</code>, we use <code>ls</code> to see what the pint tool creates. In the project directory,
there's a <code>pint.toml</code> file, giving us a package. There's also an <code>src</code> directory that contains
<code>contract.pnt</code>. Open <code>pint.toml</code> in your text editor, and note there's no mention of
<code>src/contract.pnt</code>. The pint tool follows a convention that <code>src/contract.pnt</code> is the root file of a
contract package. Likewise, <code>src/lib.pnt</code> is the root file of a library package.</p>
<p>Note that the <code>pint.toml</code> file does contain a field called <code>kind</code>, which is set to <code>contract</code> in the
example above, to indicate that this particular package is a contract. In contrast, if we were to
create a library package using <code>pint new my-library --lib</code>, then we would find that the <code>kind</code> field
in the generated <code>pint.toml</code> is set to <code>library</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="defining-modules"><a class="header" href="#defining-modules">Defining Modules</a></h2>
<p>In this section, we’ll talk about modules and other parts of the module system, namely paths that
allow you to name items and the <code>use</code> keyword that brings a path into scope.</p>
<h3 id="modules-cheat-sheet"><a class="header" href="#modules-cheat-sheet">Modules Cheat Sheet</a></h3>
<p>Here we provide a quick reference on how modules, paths, and the <code>use</code> keyword work in the compiler,
and how most developers organize their code. We’ll be going through examples of each of these rules
throughout this chapter, but this is a great place to refer to as a reminder of how modules work.</p>
<ul>
<li><strong>Start from the package root</strong>: When compiling a package, the compiler first looks for code to
compile in the package root file, which is <code> src/lib.pnt</code> for a library package or
<code>src/contract.rs</code> for a contract package.</li>
<li><strong>Declaring modules</strong>: You can declare new modules by creating files for them in the appropriate
directories. Say you want to declare a new <code>garden</code> module. You have two options:
<ul>
<li>You can create the file <code>src/garden.pnt</code> if you want the <code>garden</code> module to be a <em>single file</em>
module. That is, if you don't want the module <code>garden</code> to have submodules.</li>
<li>You can create the file <code>src/garden/garden.pnt</code> if you want the module to be a <em>multi-file
module</em>. That is, if you want the module <code>garden</code> to have submodules. The submodules of <code>garden</code>
would then live in the <code>src/garden</code> directory.</li>
</ul>
</li>
<li><strong>Declaring submodules</strong>: In any directory other than the package root directory, you can create
new <em>submodules</em>. For example, say you want to declare a submodule of <code>garden</code> named <code>vegetables</code>.
You have two options:
<ul>
<li>You can create the file <code>src/garden/vegetables.rs</code> if you want the <code>vegetables</code> submodule to be
a <em>single file</em> submodule. That is, if you don't want the submodule <code>vegetables</code> to have its own
submodules.</li>
<li>You can create the file <code>src/garden/vegetables/vegetables.rs</code> if you want the <code>vegetables</code>
submodules to be a <em>multi-file submodule</em>. That is, if you want the submodule <code>vegetables</code> to
have its own submodules.</li>
</ul>
</li>
<li><strong>Paths to code in modules</strong>: Once a module is part of your package, you can refer to code in that
module from anywhere else in the same package. For example, an enum <code>Asparagus</code> in the garden
vegetables module would be found at <code>::garden::vegetables::Asparagus</code>.</li>
<li><strong>The <code>use</code> keyword</strong>: Within a Pint file, the <code>use</code> keyword creates shortcuts to items to reduce
repetition of long paths. For example, you can create a shortcut to
<code>::garden::vegetables::Asparagus</code> using the statement <code>use ::garden::vegetables::Asparagus;</code>
declared at global scope in a Pint file. From then on, you only need to write <code>Asparagus</code> to make
use of that enum in this file.</li>
</ul>
<p>Here, we create a contract package named <code>backyard</code> that illustrates these rules. The package's
directory, also named <code>backyard</code>, contains these files and directories:</p>
<pre><code class="language-console">backyard
├── pint.toml
└── src
    ├── contract.pnt
    └── garden
        ├── garden.rs
        └── vegetables.rs
</code></pre>
<p>The package root file is <code>src/contract.rs</code> since this is a contract package. It contains:</p>
<pre><code class="language-pint">use garden::vegetables::Asparagus;

predicate Foo {
    var green_asparagus = Asparagus::Green;
}
</code></pre>
<p>The submodule <code>vegetables</code> which is defined in <code>src/garden/vegetables.pnt</code>, contains:</p>
<pre><code class="language-pint">enum Asparagus = Green | White | Purple;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="paths-for-referring-to-an-item-in-a-module-tree"><a class="header" href="#paths-for-referring-to-an-item-in-a-module-tree">Paths for Referring to an item in a Module Tree</a></h2>
<p>To show Pint where to find an item in a module tree, we use a path in the same way we use a path
when navigating a filesystem. To use a custom type for example, we need to know its path.</p>
<p>A path can take two forms:</p>
<ul>
<li>An <strong>absolute path</strong> is the full path starting from a package root; for code from an external
package, the absolute path begins with the package name, and for code from the current package, it
starts with double colons (<code>::</code>).</li>
<li>A <strong>relative path</strong> starts from the current module and uses an identifier in the current
module.</li>
</ul>
<p>Both absolute and relative paths are followed by one or more identifiers separated by double colons
(<code>::</code>).</p>
<p>Returning to the &quot;backyard&quot; example from the previous chapter, say we want to access the enum
<code>Asparagus</code>. This is the same as asking: what's the path of the <code>Asparagus</code> enum. We'll show two
ways to access <code>Asparagus</code> from the root file:</p>
<pre><code class="language-pint">predicate Bar {
    var first_asparagus: ::garden::vegetables::Asparagus;

    var second_asparagus: garden::vegetables::Asparagus;
}
</code></pre>
<p>The first time we refer to the enum <code>Asparagus</code> we use an absolute path. The enum <code>Asparagus</code> is defined
in the same package as our root module above, which means we can use <code>::</code> to start an absolute path.
We then include each of the successive modules until we make our way to <code>Asparagus</code>.</p>
<p>The second time we refer to the enum <code>Asparagus</code>, we use a relative path. The path starts with
<code>garden</code>, the name of the module defined at the same level of the module tree as the root module.</p>
<p>Choosing whether to use a relative or absolute path is a decision you’ll make based on your project,
and depends on whether you’re more likely to move item definition code separately from or together
with the code that uses the item. For example, if we move the <code>garden</code> module to a module named
<code>estate</code>, we’d need to update the absolute path to <code>Asparagus</code>, but the relative path would still be
valid. However, if we moved <code>var first_asparagus</code> into a module named <code>salad</code>, the absolute path to
<code>Asparagus</code> would stay the same, but the relative path would need to be updated. Our preference in
general is to specify absolute paths because it’s more likely we’ll want to move code definitions
and item calls independently of each other.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="bringing-paths-into-scope-with-the-use-keyword"><a class="header" href="#bringing-paths-into-scope-with-the-use-keyword">Bringing Paths into Scope with the <code>use</code> Keyword</a></h2>
<p>Having to write out the paths to access items can feel inconvenient and repetitive. In the previous
chapter, whether we chose the absolute or relative path to <code>Asparagus</code>, every time we wanted to use
<code>Asparagus</code> we had to specify the modules <code>garden</code> and <code>vegetables</code>. Fortunately, there’s a way to
simplify this process: we can create a shortcut to a path with the <code>use</code> keyword once, and then use
the shorter name everywhere else in the scope.</p>
<p>In the example below, we bring the <code>::garden::vegetables</code> module into the scope of the root file to
use the <code>Asparagus</code> enum:</p>
<pre><code class="language-pint">
use ::garden::vegetables;

predicate Baz {
    var third_asparagus: vegetables::Asparagus;
}
</code></pre>
<p>Adding <code>use</code> and a path in a scope is similar to creating a symbolic link in the filesystem. By
adding use <code>::garden::vegetables</code> in the root file, <code>vegetables</code> is now a valid name in that scope.</p>
<h3 id="handling-conflicting-imports"><a class="header" href="#handling-conflicting-imports">Handling conflicting imports</a></h3>
<p>Pint does not allow bringing two items with the same name into scope with <code>use</code>. This name clash
makes it impossible for the compiler to distinguish between the two items in the scope. There are
two ways to avoid this problem. The first, is to only import the names of the parent modules.</p>
<p>Consider the following two libraries:</p>
<pre><code class="language-pint">// Module data::contract_lib

type Data = { 
    address: b256,
    storage_vars: int,
    predicates: int,
};
</code></pre>
<pre><code class="language-pint">// Module data::predicate_lib

type Data = { 
    address: b256,
    decision_vars: int,
    pub_vars: int,
};
</code></pre>
<p>Both libraries use the name <code>Data</code> to describe a types. The example below shows how to bring the two
<code>Data</code> types into scope and how to refer to them without having a conflict.</p>
<pre><code class="language-pint">use ::data::contract_lib;
use ::data::predicate_lib;

var contract_data: contract_lib::Data;
var predicate_data: predicate_lib::Data;
</code></pre>
<p>As you can see, using the parent module distinguishes the two <code>Data</code> types. If instead we specified
<code>use data::contract_lib::Data</code> and <code>use data::predicate_lib::Data</code>, we'd have two <code>Data</code> types in
the same scope and Pint wouldn't know which one we meant when we used <code>Data</code>.</p>
<p>There’s another solution to the problem of bringing two types of the same name into the same scope
with <code>use</code>: after the path, we can specify <code>as</code> and a new local name, or <em>alias</em>, for the type. The
example below shows another way to write the code in the previous example by renaming the two <code>Data</code>
types using <code>as</code>.</p>
<pre><code class="language-pint">use ::data::contract_lib::Data as ContractData;
use ::data::predicate_lib::Data as PredicateData;

var contract_data: ContractData;
var predicate_data: PredicateData;
</code></pre>
<p>In each <code>use</code> statement, we choose a new name for <code>Data</code>. That guarantees that no conflicts arise.
This also has the side benefit of giving <code>Data</code> a more meaningful name in the current context.</p>
<h3 id="using-nested-paths-to-clean-up-large-use-lists"><a class="header" href="#using-nested-paths-to-clean-up-large-use-lists">Using Nested Paths to Clean Up Large <code>use</code> Lists</a></h3>
<p>If we’re using multiple items defined in the same module, listing each item on its own line can take
up a lot of vertical space in our files. For example, these two <code>use</code> statements we had in the
previous example bring two items into scope:</p>
<pre><code class="language-pint">use ::data::contract_lib::Data as ContractData;
use ::data::predicate_lib::Data as PredicateData;
</code></pre>
<p>Instead, we can use nested paths to bring the same items into scope in one line. We do this by
specifying the common part of the path, followed by two colons, and then curly brackets around a
list of the parts of the paths that differ, as shown below.</p>
<pre><code class="language-pint">use ::data::{contract_lib::Data as ContractData, predicate_lib::Data as PredicateData};
</code></pre>
<p>In bigger programs, bringing many items into scope from the same module using nested paths can
reduce the number of separate <code>use</code> statements needed by a lot!</p>
<p>We can use a nested path at any level in a path, which is useful when combining two <code>use</code> statements
that share a subpath. For example, the code snippet below shows two <code>use</code> statements: one that
brings <code>data::contract_lib</code> into scope and one that brings <code>data::contract_lib::Data</code> into scope.</p>
<pre><code class="language-pint">use ::data::contract_lib;
use ::data::contract_lib::Data;
</code></pre>
<p>The common part of these two paths is <code>data::contract_lib</code>, and that’s the complete first path. To
merge these two paths into one <code>use</code> statement, we can use <code>self</code> in the nested path, as shown
below.</p>
<pre><code class="language-pint">use ::data::contract_lib::{self, Data};
</code></pre>
<p>This line brings <code>data::contract_lib</code> and <code>data::contract_lib::Data</code> into scope.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h1>
<p>By now, you’ve learned the most commonly used parts of the Pint programming language. We will look
at a few aspects of the language you might run into every once in a while, but may not use every
day. The features covered here are useful in very specific situations. Although you might not reach
for them often, we want to make sure you have a grasp of all the features Pint has to offer.</p>
<p>In this chapter, we'll cover:</p>
<ul>
<li>Public decision variables: how to declare decision variables that are public and how to access
them from external contexts.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="public-decision-variables"><a class="header" href="#public-decision-variables">Public Decision Variables</a></h2>
<p>By default, all decision variables are private. That is, they are only accessible from within the
predicate that declares them. There is no way to reason about the value of a private decision
variable from <em>outside</em> the predicate. This, however, may not be sufficient to build certain
applications. It also imposes limitations on how contracts are written: if a predicate requires data
from another predicate, then the two predicates must be combined.</p>
<p>We've already looked at one class of variables that are always public: <strong>storage variables</strong>. While
storage variables allow us to share data between predicates, they are the wrong tool for our use
case because they are persistent. What we want is a class of variables that can be shared between
predicates but that are <em>temporary</em>. That is, their value should no longer be relevant after a
solution is submitted and validated. Pint solves this problem by allow decision variables to be
<strong>public</strong> via the <code>pub</code> keyword.</p>
<h3 id="declaring-public-decision-variables"><a class="header" href="#declaring-public-decision-variables">Declaring Public Decision Variables</a></h3>
<p>Declaring public decision variables is fairly simple. All you have to do is prefix the <code>var</code>
declaration with the keyword <code>pub</code>:</p>
<pre><code class="language-pint">predicate Foo {
    pub var x: int;
    pub var y: b256;
    pub var t: { int, bool, b256 };

    var a: int;
    var b: bool;
    var c: int[4];

    constraint a + x &gt; 3;
    constraint y == 0x1111111111111111111111111111111111111111111111111111111111111111;
    constraint !t.1 &amp;&amp; b;
}
</code></pre>
<p>In the predicate above, we are declaring 3 public decision variables and 3 private decision
variables.</p>
<p>Accessing public decision variables within the predicate that defines them is no different from
accessing private decision variables. The example above also declares 3 constraints that access both
types of decision variables in various ways.</p>
<h3 id="public-decision-variables-in-interfaces"><a class="header" href="#public-decision-variables-in-interfaces">Public Decision Variables in Interfaces</a></h3>
<p>Recall that for each contract, an interface can be produced that exposes all public elements of a
contract: the storage block as well as all the predicates and their public decision variables. For
example, the following interface can be produced from the contract above:</p>
<pre><code class="language-pint">interface MyInterface {
    // storage block, if present

    predicate Foo {
        pub var x: int;
        pub var y: b256;
        pub var t: { int, bool, b256 };
    }

    // other predicates, if present
}
</code></pre>
<p>Note that everything in predicate <code>Foo</code> was dropped except for <code>pub var</code> declarations.</p>
<p>Next, we will show how to use an interface to access public decision variables of an external
predicate.</p>
<h3 id="external-access-to-public-decision-variables"><a class="header" href="#external-access-to-public-decision-variables">External Access to Public Decision Variables</a></h3>
<p>In <a href="advanced/../storage/external.html">Chapter 5.3</a> we covered how to use interfaces to access storage
variables from an external context. Accessing public decision variables from an external context
requires similar steps.</p>
<p>First, we need to declare an interface instance using the syntax we learned in <a href="advanced/../storage/external.html">Chapter
5.3</a></p>
<pre><code class="language-pint">    interface MyInterfaceInstance = MyInterface(ContractID);
</code></pre>
<p>where <code>ContractID</code> is the address of the contract where the public decision variables are declared.
Then, and because the public decision variables live inside a predicate, we need to declare a
<strong>predicate instance</strong> as follows:</p>
<pre><code class="language-pint">    predicate FooInstance = MyInterfaceInstance::Foo(PredicateID);
</code></pre>
<p>Similarly to interface instance declarations, a predicate instance declaration requires an address.
Each predicate has a 256-bit address that identifies it on the blockchain. The above declares an
interface instance called <code>FooInstance</code> of predicate <code>Foo</code> and with address <code>PredicateID</code>. Note that
we refer to the predicate <code>Foo</code> in the declaration using the interface instance name followed by
<code>::Foo</code>.</p>
<p>Now that we have an instance of <code>Foo</code>, we are able to access its public decision variables using a
path that contains the predicate instance name and the name of the variable:</p>
<pre><code class="language-pint">    var m: int;
    var n: bool;

    constraint m * FooInstance::x &gt; 8;
    constraint FooInstance::y == 0x2222222222222222222222222222222222222222222222222222222222222222;
    constraint FooInstance::t.1 &amp;&amp; n;
</code></pre>
<h3 id="public-decision-variables-in-solutions"><a class="header" href="#public-decision-variables-in-solutions">Public Decision Variables in Solutions</a></h3>
<p>Sharing data between two predicates using public decision variables only makes sense if the solution
that we are trying to validate actually solves both predicates. For example, if predicate <code>Foo</code>
exposes <code>pub var x;</code> and predicate <code>Bar</code> uses <code>x</code>, then a solution that solves <code>Bar</code> must also solve
<code>Foo</code> since <code>Bar</code> requires data from <code>Foo</code>, namely <code>x</code>.</p>
<p>Every solution contains a list of the predicates it solves. Some predicates might even be solved
multiple times in the same solution! This may be surprising to you but you can imagine multiple
instances of the same predicate being solved with different values. After all, predicates can
generally be solved in many different ways depending on how restrictive their constraints are.</p>
<p>As a result, each predicate instance declaration must somehow specify which part of the solution it
is referring to. The Pint compiler accomplishes this by adding an <em>implicit</em> decision variable that
represents the <strong>index</strong> of the solved predicate in the solution. An implicit decision variable is
added for each predicate instance declaration. Therefore, in the example below:</p>
<pre><code class="language-pint">    interface MyInterfaceInstance = MyInterface(ContractID);
    predicate FooInstance1 = MyInterfaceInstance::Foo(PredicateID);
    predicate FooInstance2 = MyInterfaceInstance::Foo(PredicateID);
    
    var x1 = FooInstance1::x;
    var x2 = FooInstance2::x;
</code></pre>
<p>the variables <code>x1</code> and <code>x2</code> may not be the same since they may refer to two different values of <code>x</code>
in the solution (if <code>Foo</code> is solved multiple times).</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<p>The following sections contain reference material you may find useful in your Pint journey.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="appendix-a-keywords"><a class="header" href="#appendix-a-keywords">Appendix A: Keywords</a></h2>
<p>The following list contains keywords that are reserved for current use by the Pint language. As
such, they cannot be used as identifiers. Identifiers are names of macros, variables, tuple fields,
modules, or types.</p>
<ul>
<li><code>as</code> - perform primitive casting or rename items in <code>use</code> statements</li>
<li><code>bool</code> - the Boolean type</li>
<li><code>b256</code> - the 256-bit hash type</li>
<li><code>cond</code> - select between multiple expressions based on some conditions</li>
<li><code>const</code> -</li>
<li><code>constraint</code> - define a Boolean constraint that a proposed solution must satisfy</li>
<li><code>else</code> - fallback for <code>if</code> and <code>cond</code> conditionals</li>
<li><code>enum</code> - define an enumeration</li>
<li><code>exists</code> - existential quantification: checks whether a statements is <code>true</code> for at least one
element in a domain.</li>
<li><code>false</code> -</li>
<li><code>forall</code> - universal quantification: checks whether a statement is <code>true</code> for all elements in a
domain</li>
<li><code>if</code> - branch based on the result of a conditional expression</li>
<li><code>in</code> - checks if an element belongs to a range or to an array</li>
<li><code>int</code> - basic integer type</li>
<li><code>interface</code> - declare an external interface</li>
<li><code>macro</code> - define a macro</li>
<li><code>maximize</code> - part of a <code>solve</code> statement: maximizes an objective function</li>
<li><code>minimize</code> - part of a <code>solve</code> statement: minimizes an objective function</li>
<li><code>nil</code> -</li>
<li><code>predicate</code> - define a predicate</li>
<li><code>pub</code> -</li>
<li><code>real</code> - basic real type</li>
<li><code>satisfy</code> - part of a <code>solve</code> statement: satisfy the constraints in the predicate</li>
<li><code>self</code> - used in <code>use</code> statements</li>
<li><code>solve</code> - define what solve directive to use</li>
<li><code>state</code> - bind a state variable</li>
<li><code>storage</code> - declare a storage block</li>
<li><code>string</code> - basic string type</li>
<li><code>true</code> -</li>
<li><code>type</code> - define a new type</li>
<li><code>use</code> - bring symbols into scope</li>
<li><code>var</code> - bind a decision variable</li>
<li><code>where</code> - denote clauses that constraint generator indices</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="appendix-b-compiler-intrinsics"><a class="header" href="#appendix-b-compiler-intrinsics">Appendix B: Compiler Intrinsics</a></h2>
<p>The Pint compiler supports a list of intrinsics that perform various low level operations that are
mostly useful for building libraries. Intrinsics are generally target-specific. They give library
authors access to VM-specific instructions while preserving type safety. Below is a list of all
available compiler intrinsics for the Essential VM:</p>
<hr />
<pre><code class="language-pint">__mut_keys_len() -&gt; int
</code></pre>
<p><strong>Description:</strong> Returns the number of mutable keys being proposed for mutation.</p>
<hr />
<pre><code class="language-pint">__mut_keys_contains(key: int[&lt;n&gt;]) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Returns a <code>bool</code> indicating whether the mutable keys being proposed contain <code>key</code>.
<code>&lt;n&gt;</code> is any positive integer.</p>
<hr />
<pre><code class="language-pint">__this_address() -&gt; b256
</code></pre>
<p><strong>Description:</strong> Returns the content hash of this predicate.</p>
<hr />
<pre><code class="language-pint">__this_set_address() -&gt; b256
</code></pre>
<p><strong>Description:</strong> Returns the content hash of the contract that this predicate belongs to.</p>
<hr />
<pre><code class="language-pint">__this_pathway() -&gt; int
</code></pre>
<p><strong>Description:</strong> Returns the &quot;pathway&quot; of this predicate. The pathway of a predicate is the index of
the solution data currently being used to check the predicate.</p>
<hr />
<pre><code class="language-pint">__sha256(data: &lt;any&gt;) -&gt; b256
</code></pre>
<p><strong>Description:</strong> Returns a SHA 256 hash from the specified data.</p>
<hr />
<pre><code class="language-pint">__state_len(data: &lt;state&gt;) -&gt; int
</code></pre>
<p><strong>Description:</strong> Returns the length of a state variable. the argument <code>data</code> must be a state
variable or a &quot;next state&quot; expression but can have any type.</p>
<hr />
<pre><code class="language-pint">__verify_ed25519(data: &lt;any&gt;, sig: { b256, b256 }, pub_key: b256) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Validate an Ed25519 signature against a public key.</p>
<hr />
<pre><code class="language-pint">__recover_secp256k1(data_hash: b256, sig: { b256, b256, int }) -&gt; { b256, int }
</code></pre>
<p><strong>Description:</strong> Recover the public key from a secp256k1 signature.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pint.js"></script>
        <script src="theme/bnf.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
