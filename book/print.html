<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Book of Pint</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="the-book-of-pint.html">The Book of Pint</a></li><li class="chapter-item expanded "><a href="getting_started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting_started/quickstart.html"><strong aria-hidden="true">1.2.</strong> Quickstart Guide</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/counter.html"><strong aria-hidden="true">2.1.</strong> Counter</a></li><li class="chapter-item expanded "><a href="examples/subcurrency.html"><strong aria-hidden="true">2.2.</strong> Subcurrency</a></li></ol></li><li class="chapter-item expanded "><a href="smart_contracts/index.html"><strong aria-hidden="true">3.</strong> Pint Smart Contracts</a></li><li class="chapter-item expanded "><a href="basics/index.html"><strong aria-hidden="true">4.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/variables.html"><strong aria-hidden="true">4.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="basics/data_types.html"><strong aria-hidden="true">4.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="basics/comments.html"><strong aria-hidden="true">4.3.</strong> Comments</a></li><li class="chapter-item expanded "><a href="basics/conditionals.html"><strong aria-hidden="true">4.4.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="basics/custom_types.html"><strong aria-hidden="true">4.5.</strong> Custom Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/custom_types/type_aliases.html"><strong aria-hidden="true">4.5.1.</strong> Type Aliases</a></li><li class="chapter-item expanded "><a href="basics/custom_types/unions.html"><strong aria-hidden="true">4.5.2.</strong> Unions</a></li><li class="chapter-item expanded "><a href="basics/custom_types/match.html"><strong aria-hidden="true">4.5.3.</strong> The match Construct</a></li></ol></li><li class="chapter-item expanded "><a href="basics/constraints.html"><strong aria-hidden="true">4.6.</strong> Constraints</a></li><li class="chapter-item expanded "><a href="basics/constants.html"><strong aria-hidden="true">4.7.</strong> Constants</a></li></ol></li><li class="chapter-item expanded "><a href="storage/index.html"><strong aria-hidden="true">5.</strong> Storage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="storage/static.html"><strong aria-hidden="true">5.1.</strong> Statically-Sized Storage Types</a></li><li class="chapter-item expanded "><a href="storage/dynamic.html"><strong aria-hidden="true">5.2.</strong> Dynamically-Sized Storage Types</a></li><li class="chapter-item expanded "><a href="storage/external.html"><strong aria-hidden="true">5.3.</strong> External Storage Access</a></li></ol></li><li class="chapter-item expanded "><a href="projects/index.html"><strong aria-hidden="true">6.</strong> Managing Growing Projects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="projects/packages.html"><strong aria-hidden="true">6.1.</strong> Pint Projects</a></li><li class="chapter-item expanded "><a href="projects/modules.html"><strong aria-hidden="true">6.2.</strong> Defining Modules</a></li><li class="chapter-item expanded "><a href="projects/paths.html"><strong aria-hidden="true">6.3.</strong> Paths for Referring to an item in a Module Tree</a></li><li class="chapter-item expanded "><a href="projects/use.html"><strong aria-hidden="true">6.4.</strong> Bringing Paths into Scope with the use Keyword</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/index.html"><strong aria-hidden="true">7.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/invoking_predicates.html"><strong aria-hidden="true">7.1.</strong> Invoking Predicates</a></li><li class="chapter-item expanded "><a href="advanced/macros.html"><strong aria-hidden="true">7.2.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="pint-reference/index.html"><strong aria-hidden="true">8.</strong> Pint Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pint-reference/cli.html"><strong aria-hidden="true">8.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="pint-reference/manifest.html"><strong aria-hidden="true">8.2.</strong> Manifest</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">9.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/keywords.html"><strong aria-hidden="true">9.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix/intrinsics.html"><strong aria-hidden="true">9.2.</strong> B - Compiler Intrinsics</a></li><li class="chapter-item expanded "><a href="appendix/abi/index.html"><strong aria-hidden="true">9.3.</strong> C - Application Binary Interface (ABI)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/abi/abi_spec.html"><strong aria-hidden="true">9.3.1.</strong> C.1 - Application Binary Interface (ABI) Specification</a></li><li class="chapter-item expanded "><a href="appendix/abi/abi_gen.html"><strong aria-hidden="true">9.3.2.</strong> C.2 - Constructing Solutions using the ABI</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/known_issues.html"><strong aria-hidden="true">9.4.</strong> A - Known Issues and Missing Features</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Book of Pint</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/essential-contributions/pint" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="the-book-of-pint"><a class="header" href="#the-book-of-pint">The Book of Pint</a></h1>
<p>Welcome to <em>The Book of Pint</em>, an introductory book about <strong>Pint</strong>. Pint is a <strong>declarative</strong>
programming language for building blockchain applications. The term declarative means that code
written in Pint is focused on <em>logic</em> and not <em>execution</em>. In Pint, you can describe <em>what</em> your
program must accomplish rather than describing <em>how</em> to accomplish it. This is in contrast with
<em>imperative</em> blockchain languages, like <a href="https://soliditylang.org/">Solidity</a>, which require
implementing algorithms in explicit steps.</p>
<p>In particular, Pint is a constraint-based language. A Pint program is essentially a collection of
predicates and each predicate is a collection of constraints. Because blockchain applications are
all about state transitions, constraints allow you to restrict how the state is allowed to change.
As a result, you do not have to explicitly express <em>how to</em> change the state, but only <em>what state
changes are allowed</em>.</p>
<p>In general, this book assumes that you’re reading it in sequence from front to back. Later chapters
build on concepts in earlier chapters, and earlier chapters might not delve into details on a
particular topic but will revisit the topic in a later chapter. The book can also be used as a
reference, though it is not entirely comprehensive.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>To get you started, this chapter discusses the following:</p>
<ul>
<li>Installing Pint</li>
<li>Writing your first Pint program</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="using-nix-recommended"><a class="header" href="#using-nix-recommended">Using Nix (Recommended)</a></h3>
<p>The easiest way to get started with Pint and the Essential ecosystem is to use
<a href="https://nixos.org/">Nix</a>. You first need to install Nix using:</p>
<pre><code class="language-console">curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install
</code></pre>
<p>or using one of <a href="https://nixos.org/download/">these other alternatives</a>.</p>
<p>Then, enter a Nix shell as follows:</p>
<pre><code class="language-console">nix develop github:essential-contributions/essential-integration#dev
</code></pre>
<p>This will make all the tools you need available in your terminal.</p>
<h3 id="installing-from-cargo"><a class="header" href="#installing-from-cargo">Installing from <code>Cargo</code></a></h3>
<h4 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h4>
<p>A prerequisite for installing <code>Pint</code> from <code>Cargo</code> is the Rust toolchain. Platform-specific
instructions for installing <code>rustup</code> can be found <a href="https://www.rust-lang.org/tools/install">here</a>.
Then, install the Rust toolchain with:</p>
<pre><code class="language-console">$ rustup install stable
</code></pre>
<p>The Pint toolchain is built and tested against the latest <a href="https://github.com/rust-lang/rust/releases/latest"><code>stable</code> Rust toolchain
version</a>. Ensure you are using the latest
<code>stable</code> version of Rust with:</p>
<pre><code class="language-console">$ rustup update &amp;&amp; rustup default stable
</code></pre>
<h4 id="installation-steps"><a class="header" href="#installation-steps">Installation Steps</a></h4>
<p>The Pint toolchain can be installed using <code>Cargo</code> with:</p>
<pre><code class="language-console">$ cargo install pint-cli
</code></pre>
<p>You can update the toolchain with <code>Cargo</code> using:</p>
<pre><code class="language-console">$ cargo update pint-cli
</code></pre>
<h3 id="syntax-highlighting"><a class="header" href="#syntax-highlighting">Syntax Highlighting</a></h3>
<p>Currently, Pint only has syntax highlighting support in Visual Studio Code. We are, however, in the
process of adding support for other editors.</p>
<h4 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h4>
<p>To install the Pint plugin, Search the Visual Studio Code market place for <code>pint syntax</code>.
Alternatively, use <a href="https://marketplace.visualstudio.com/items?itemName=essential-contributions.pint-lang">this
link</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="quickstart-guide"><a class="header" href="#quickstart-guide">Quickstart Guide</a></h2>
<p>Now that you’ve installed Pint, it’s time to write your first Pint contract. The first contract we
will implement is a counter.</p>
<h3 id="creating-a-project-directory"><a class="header" href="#creating-a-project-directory">Creating a Project Directory</a></h3>
<p>You'll start by making a directory to store your Pint code. Open a terminal and enter the following
commands to make a <code>projects</code> directory:</p>
<pre><code class="language-console">mkdir ~/projects
cd ~/projects
</code></pre>
<p>Now, we will use the <code>pint</code> tool to create a new project in the <code>projects</code> directory:</p>
<pre><code class="language-console">pint new counter
cd counter
</code></pre>
<p>The <code>pint new</code> commands creates a new Pint project with the provided name. In the newly created
directory <code>counter</code>, you should find a <code>pint.toml</code> file as well as a <code>src/</code> directory with a single
file in it called <code>contract.pnt</code>:</p>
<pre><code class="language-console">projects
└── counter
    ├── pint.toml
    └── src
        └── contract.pnt
</code></pre>
<p>The auto-generated <code>pint.toml</code> file describes how to build the project. The <code>src/contract.pnt</code> file
is the root file of a contract project, i.e., this is where the compilation starts when we build the
project.</p>
<p>Open the <code>pint.toml</code> and inspect its content:</p>
<pre><code class="language-toml">[package]
name = &quot;counter&quot;
kind = &quot;contract&quot;

[dependencies]
# Library dependencies go here.

[contract-dependencies]
# Contract dependencies go here.
</code></pre>
<p>The one thing to note is that the <code>kind</code> field in this <code>pint.toml</code> is set to <code>contract</code>. This is the
default project kind. Alternatively, <code>kind</code> can be a <em>library</em>.</p>
<h3 id="writing-a-pint-program"><a class="header" href="#writing-a-pint-program">Writing a Pint Program</a></h3>
<p>Next, open the <code>src/contract.pnt</code> file and erase its content. Then, paste the following:</p>
<pre><code class="language-pint">storage {
    counter: int,
}

predicate Increment() {
    let counter: int = mut storage::counter;

    constraint (counter == nil &amp;&amp; counter' == 1) || counter' == counter + 1;
}
</code></pre>
<p>This is a contract with a single predicate and a single storage variable. The storage variable
<code>counter</code>, of type <code>int</code> (i.e. integer), is declared in a <code>storage</code> block. The only predicate in
this contract is called <code>Increment</code> and contains two statements:</p>
<ol>
<li>A <code>let</code> declaration which reads the variable <code>counter</code>.</li>
<li>A <code>constraint</code> statement which enforces some logic on the state of the contract.</li>
</ol>
<p>The above constraint is essentially saying: &quot;if <code>counter</code> hasn't been set yet (i.e. is <code>nil</code>), set
the new value of <code>counter</code> to <code>1</code> (<code>counter' == 1</code>). Otherwise, increment <code>counter</code> by <code>1</code>&quot;.</p>
<p>Don't worry if this looks a bit overwhelming! We will later dive into each feature in this contract
separately.</p>
<h3 id="building-the-project"><a class="header" href="#building-the-project">Building the Project</a></h3>
<p>To build the project above, simply run the following command in the <code>counter</code> directory:</p>
<pre><code class="language-console">pint build
</code></pre>
<p>You should get something like this:</p>
<pre><code class="language-console">   Compiling counter [contract] (/path/to/counter)
    Finished build [debug] in 5.470625ms
    contract counter            1899743AA94972DDD137D039C2E670ADA63969ABF93191FA1A4506304D4033A2
         └── counter::Increment 355A12DCB600C302FFD5D69C4B7B79E60BA3C72DDA553B7D43F4C36CB7CC0948
</code></pre>
<p>Note the two 256-bit numbers in the output. These represent the <em>content hash</em> (i.e. the <code>sha256</code> of
the bytecode) of the <code>counter</code> contract (as a whole) and the <code>Increment</code> predicate, respectively.
These &quot;addresses&quot; will be used when referring to the contract or the predicate (in a proposed
solution for example).</p>
<p>In the <code>counter</code> directory, you will also notice a new directory called <code>out</code>. Navigate to
<code>out/debug</code> and inspect the two <code>json</code> files that you see.</p>
<ul>
<li><code>counter.json</code> represents the compiled bytecode in JSON format, which is the most important
artifact produced by the compiler. This file is used when validating a solution. That is, when a
solution is submitted, this file contains the bytecode that &quot;runs&quot; and decides whether all the
relevant constraints are valid.</li>
<li><code>counter-abi.json</code> is the Application Binary Interface (ABI) of the contract. It basically
describes how to interact with the contract from an external application or another contract. For
example, while crafting a solution, the ABI can be used to figure out where the various storage
variables are stored (i.e. their keys) and their types. This information is crucial to form
correct solutions.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: <a href="getting_started/../appendix/abi.html">Appendix C</a> contains the ABI spec.</p>
</blockquote>
<p>Now that we have built and inspected the artifacts of our project, we can proceed to build an
application that interacts with this contract. We won't cover this topic here, but you can check out
this <a href="https://essential-contributions.github.io/essential-integration/index.html">Getting Started with Essential
Application</a> book, which
covers this exact same &quot;counter&quot; example and how to build a Rust application that interacts with it
using the Essential VM.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="example"><a class="header" href="#example">Example</a></h1>
<p>This chapter includes some basic examples that show how Pint code looks like:</p>
<ul>
<li><a href="examples/./counter.html">Counter</a></li>
<li><a href="examples/./subcurrency.html">Subcurrency</a></li>
</ul>
<p>We will go over each example line-by-line while briefly introducing new concepts. Later, however, we
will cover each new concept in depth in its own chapter. Therefore, the goal of this chapter is not
to teach you everything about Pint but to get you to (hopefully!) appreciate what Pint is capable
off.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="counter"><a class="header" href="#counter">Counter</a></h2>
<p>The &quot;counter&quot; is one of the simplest smart contracts that can be written in Pint. It showcases how a
contract can have multiple predicates and how it can declare and use <em>storage</em>. This particular
implementation of the &quot;counter&quot; contract is different from the one we encountered in the <a href="examples/../getting_started/quickstart.html#writing-a-pint-program">Quickstart
Guide</a>.</p>
<pre><code class="language-pint">storage {
    counter: int,
}

predicate Initialize(value: int) {
    let counter: int = mut storage::counter;
    constraint counter' == value;
}

predicate Increment(amount: int) {
    let counter: int = mut storage::counter;
    constraint counter' == counter + amount;
}
</code></pre>
<p>The contract starts by declaring a <code>storage</code> block which contains a single storage variable called
<code>counter</code> of type <code>int</code> (i.e. integer). The contract later declares two separate predicates, each
having a single <em>parameter</em> and declaring two statements. Let's walk through the first predicate
named <code>Initialize</code>:</p>
<ol>
<li>Predicate <code>Initialize</code> has a single <em>parameter</em> called <code>value</code> of type <code>int</code>. The parameters of a
predicate are essentially <em>decision variables</em> that a solver is required to find values for such
that every <code>constraint</code> in the predicate evaluates to <code>true</code>. The expression &quot;decision variable&quot;
is commonly used in constraint programming languages to refer to unknowns that a solver must find
given some constraints. In <code>Initialize</code>, the parameter <code>value</code> is the value that we want our
counter to get initialized to.</li>
<li>The second statement declares a local variable and initializes it to <code>mut storage::counter</code>. The
statement <code>let counter: int = mut storage::counter</code> creates a local variable called <code>counter</code> and
initializes it to the current value of <code>counter</code> declared in the <code>storage</code> block. The <code>mut</code>
keyword simply indicates that the solver is allowed to propose a new value for <code>counter</code>. If
<code>mut</code> is not present, then the storage variable <code>counter</code> cannot be modified by anyone attempting
to solve predicate <code>Initialize</code>.</li>
<li>The third statement contains the core logic of this predicate. It <strong>declares</strong> that the &quot;next
value&quot; of <code>counter</code> <strong>must</strong> be equal to <code>value</code>. Note the <code>'</code> notation here which can be only
applied to a local variable, and means &quot;the next value of the state variable after a valid state
transition&quot;.</li>
</ol>
<p>The second predicate, called <code>Increment</code>, has a similar structure to <code>Initialize</code>. However, instead
of initializing <code>counter</code>, It increments it by <code>amount</code>. Note that both <code>counter</code> (the current
value) and <code>counter'</code> (the next value) are both used in the constraint to enforce that the next
value is dependent on the current value, which was not the case in <code>Initialize</code>.</p>
<h3 id="solution"><a class="header" href="#solution">Solution</a></h3>
<p>We won't go too deep into the solving process here but it's worth mentioning what a <strong>solution</strong> to
this predicate might look like. Broadly speaking, a solution contains two things:</p>
<ol>
<li>An assignment of all the parameters of the predicate.</li>
<li>A list of all the state mutations proposed.</li>
</ol>
<p>For example, if a user wants the value of the counter to be <code>42</code> they (or a solver acting on their
behalf) can propose a solution to <code>Initialize</code> that looks like this:</p>
<pre><code class="language-toml"># parameters:
value: 42

# state mutations:
0: 42
</code></pre>
<p>This solution proposes a value of <code>42</code> for parameter <code>value</code> and a new value of <code>42</code> for the storage
key <code>0</code> where <code>counter</code> is stored (we will go over the storage data layout later!). Note that the
storage key <code>0</code> where <code>counter</code> is stored <em>can</em> be modified by the solution because of the <code>mut</code>
keyword added before <code>storage::counter</code>.</p>
<p>A solution must also indicate which predicate is being solved using its address but we're omitting
that here for simplicity.</p>
<p>Alternatively, a solution to <code>Increment</code> can be proposed to satisfy the user requirement <code>counter = 42</code>. For example, if the current value of <code>counter</code> happens to be <code>35</code>, then the following solution
to <code>Increment</code> can be proposed:</p>
<pre><code class="language-toml"># parameters:
amount: 7

# state mutations:
0: 42
</code></pre>
<p>It should be easy to verify that this solution satisfies the constraint <code>counter' == counter + amount;</code> from <code>Increment</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="subcurrency"><a class="header" href="#subcurrency">Subcurrency</a></h2>
<p>The following contract implements the simplest form of a cryptocurrency. The contract allows the
creation of new coins (i.e. minting) as well as sending coins from one address to another.</p>
<pre><code class="language-pint">storage {
    total_supply: int,
    balances: (b256 =&gt; int),
}

// Sends an amount of newly created coins to an address
predicate Mint(receiver: b256, amount: int) {
    let receiver_balance = mut storage::balances[receiver];
    let total_supply = mut storage::total_supply;

    constraint total_supply' == total_supply + amount;
    constraint receiver_balance' == receiver_balance + amount;
}

// Sends an amount of existing coins from address `from` to address `receiver`
predicate Send(from: b256, receiver: b256, amount: int) {
    let from_balance = mut storage::balances[from];
    let receiver_balance = mut storage::balances[receiver];

    constraint amount &lt; from_balance;
    constraint from_balance' == from_balance - amount;
    constraint receiver_balance' == receiver_balance + amount;
}
</code></pre>
<p>This contract introduces some new concepts. Let's walk through it line by line.</p>
<p>The contract starts with a <code>storage</code> declaration that contains two storage variables:</p>
<ol>
<li><code>total_supply</code> is of type <code>int</code> and represents the total supply of coins available at any given
point in time.</li>
<li><code>balances</code> is a <strong>map</strong> from <code>b256</code> to <code>int</code> and stores balances of addresses as integers. <code>b256</code>
is a primitive type that represents a 256-bit hash value and is used here to represent an
address.</li>
</ol>
<p>The contract also declares two predicates: <code>Mint</code> and <code>Send</code>.</p>
<p>The <code>Mint</code> predicate is fairly simple:</p>
<ol>
<li>It has two parameters <code>receiver: b256</code> and <code>amount: int</code>. The goal of this predicate to mint
<code>amount</code> coins and send them to <code>receiver</code>.</li>
<li>It initializes a local variable called <code>receiver_balance</code> using the storage access expression
<code>mut storage::balances[receiver]</code>. This syntax returns the value in <code>balances</code> that <code>receiver</code>
maps to and makes it &quot;mutable&quot;. The predicate also initializes another local variable called
<code>total_supply</code> to <code>mut storage::total_supply</code>.</li>
<li>It enforces two constraints:
<ol>
<li>The first constraint requires the total supply to be incremented by <code>amount</code>.</li>
<li>The second constraint requires the balance of <code>receiver</code> to be incremented by <code>amount</code>.</li>
</ol>
</li>
</ol>
<p>The <code>Send</code> predicate has the following structure:</p>
<ol>
<li>It has three parameters <code>from: b256</code>, <code>receiver: b256</code>, and <code>amount: int</code>. The goal of this
predicate to send <code>amount</code> coins from address <code>from</code> to address <code>receiver</code>.</li>
<li>It initializes a local variable called <code>from_balance</code> to the balance of <code>from</code> and another
variable called <code>receiver_balance</code> to the balance of <code>receiver</code>. It also makes both balances
&quot;mutable&quot;.</li>
<li>It enforces three constraints
<ol>
<li>The first constraint requires <code>from_balance</code> to be larger than <code>amount</code>. That is, the address
<code>from</code> must currently actually have enough coins to send to <code>receiver</code>.</li>
<li>The second constraint effectively decrements the balance of <code>from</code> by <code>amount</code>, by requiring
the next state of <code>from_balance</code> to be <code>from_balance - amount</code>.</li>
<li>The third constraint effectively increments the balance of <code>receiver</code> by <code>amount</code>, by
requiring the next state of <code>receiver_balance</code> to be <code>receiver_balance + amount</code>.</li>
</ol>
</li>
</ol>
<blockquote>
<p><strong>Note</strong> to make things simpler and easier to understand, this contract has no <em>authentication</em>
anywhere in its code. That is, anyone can mint new coins and initiate a transfer from one
arbitrary address to another. This, of course, is not the desired behavior for most
cryptocurrencies. That being said, examples of authentication can be found in <a href="https://github.com/essential-contributions/essential-integration">this Github
repository</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="smart-contracts"><a class="header" href="#smart-contracts">Smart Contracts</a></h2>
<p>Pint is a language for writing &quot;smart contracts&quot;. If you're familiar with smart contract languages
like <a href="https://soliditylang.org/">Solidity</a>, then many elements of a Pint contract should feel
familiar. Of course, at its core, Pint is fundamentally different from imperative smart contract
languages. Writing smart contracts in Pint requires a different way of thinking about how to express
the rules that the smart contract must enforce.</p>
<p>A Pint contract is a <strong>collection of predicates</strong>. Each predicate has a name, a list of typed
parameters, and a list of constraints. Predicates of a smart contract describe the various ways
<strong>state can be mutated</strong> in order to accomplish certain tasks (e.g. token transfer). A contract may
also contain a <code>storage</code> declaration which contain all the storage variable that the contract owns.
Contract storage is effectively the database of the contract where persistent state lives. We will
discuss storage in details in <a href="smart_contracts/../storage/index.html">Chapter 5</a>.</p>
<h3 id="contract-structure"><a class="header" href="#contract-structure">Contract Structure</a></h3>
<p>The structure of a Pint smart contract is fairly simple. We simply lay out all the code blocks as
follows:</p>
<pre><code class="language-pint">storage {
    // storage variables
}

predicate Foo(
    // parameters 
) {
    // local variables, constraints, etc.     
}

predicate Bar(
    // parameters 
) {
    // local variables, constraints, etc.     
}

// other predicates
</code></pre>
<p>The order of the code blocks is not important, and the <code>storage</code> block is optional but most useful
smart contracts will need it.</p>
<p>Unlike imperative smart contracts where the logic lives in contract <em>methods</em> that can be <em>called</em>
to make state updates, Pint contracts have predicates (not methods/functions even though they look
like ones!) and nothing is ever &quot;called&quot;. Instead, <em>solutions</em> have to submitted that satisfy one or
more predicates in the contract. A solution must specify concrete values for the parameters of the
solved predicates, as well as propose changes to the state if necessary.</p>
<p>If the proposed values for the parameters and the proposed state changes satisfy <strong>all</strong> the
constraints for each solved predicate (potentially including predicates from other contracts), then
the solution is deemed valid and the proposed state changes should be accepted.</p>
<h3 id="predicate-parameters"><a class="header" href="#predicate-parameters">Predicate Parameters</a></h3>
<p>A predicate parameter is a named parameter that every solution is required to assign a value for.
Predicate parameters are quite different from &quot;regular&quot; function parameters that you might be used
to in imperative programming languages since predicates of a smart contract are <em>not called</em>!.
Instead, they are <em>solved</em> by proposing values for these parameters such that all the constraints
are satisfied.</p>
<p>All predicate parameters have to be annotated with a type. We will go over the available data types
in Pint, in detail, in a later chapter.</p>
<p>Here's an example that shows how to declare a predicate named <code>test</code> with three parameters <code>foo</code>,
<code>bar</code>, and <code>baz</code> with three different types:</p>
<pre><code class="language-pint">predicate test(
    foo: int, 
    bar: bool, 
    baz: b256, 
) {
    constraint foo * foo &lt;= 1024;

    // other constraints
}
</code></pre>
<p>The predicate <code>test</code> also declares a constraint that enforces that the square of <code>foo</code> is at most
<code>1024</code>, meaning that any proposed solution must assign a value for <code>foo</code> that satisfies this
condition. For example, if <code>foo</code> is set to <code>7</code>, this is constraint would be satisfied. If <code>foo</code> is
set to <code>11</code>, this constraint would not be satisfied. We will go over constraints in more detail in
<a href="smart_contracts/../basics/constraints.html">Chapter 4.6</a>.</p>
<p>You can think of the type annotation on each predicate parameter as an implicit &quot;constraint&quot;. For
example, parameter <code>foo</code> can only take values in the set of signed integers (64-bit signed integers
when targeting the EssentialVM) while <code>bar</code> can only take two values: <code>false</code> or <code>true</code> (i.e. <code>0</code> or
<code>1</code> in the EssentialVM).</p>
<h3 id="contract-interfaces"><a class="header" href="#contract-interfaces">Contract Interfaces</a></h3>
<p>Each smart contract has an interface which can be easily generated from the contract. The interface
is not required to write the smart contract but is required to interact with the contract from
<em>external contexts</em>. For example, one smart contract can propose an update to a storage variables
that is owned by another contract. Will will go over how to do that in <a href="smart_contracts/../storage/index.html">Chapter
5</a>. Another example is invoking external predicates which is a more advanced
topic that we will cover in <a href="smart_contracts/../advanced/invoking_predicates.html">Chapter 7.1</a>.</p>
<p>A contract interface has the following structure:</p>
<pre><code class="language-pint">interface ExternalContract {
    storage {
        // storage variables
    }

    predicate Foo(
        //  parameters
    );

    predicate Bar(
        // parameters     
    );

    // other predicate interfaces 
}
</code></pre>
<p>You can see the similarities between the structure of the interface and the structure of the smart
contract. An interface starts with <code>interface</code> keyword followed by the name of the interface which
can be used when referring the interface from external contexts. Inside the interface declaration,
an optional <code>storage</code> block can be declared as well as a list of <strong>predicate interfaces</strong>, each with
its own list of typed parameters. The storage block and the predicate signatures of an interface
should always match the corresponding storage block and predicate signatures of the deployed
contract. Otherwise, correct behavior cannot be guaranteed.</p>
<p>For example, an interface for the <a href="smart_contracts/../examples/counter.html">counter example</a> looks like this:</p>
<pre><code class="language-pint">interface Counter {
    storage {
        counter: int,
    }

    predicate Initialize(value: int);

    predicate Increment(amount: int);
}
</code></pre>
<p>Hopefully nothing here is surprising! The key point is that an <code>interface</code> must expose <em>everything</em>
that is public in a contract, and that includes the storage block and the predicate signatures.</p>
<blockquote>
<p><strong>Note</strong> in the future, Pint will have a tool that will auto-generate interfaces from a smat
contract.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="common-programming-concepts"><a class="header" href="#common-programming-concepts">Common Programming Concepts</a></h1>
<p>This chapter covers concepts that appear in almost every programming language and how they work in
Pint. Many programming languages have much in common at their core. None of the concepts presented
in this chapter are unique to Pint, but we’ll discuss them in the context of Pint and particularly
how they work in a constraint-based environment as opposed to imperative environments that you might
be more familiar with.</p>
<p>Specifically, you’ll learn about local variables, basic types, custom types, <code>match</code> constructs,
comments, and conditionals. These foundations will be in every Pint program, and learning them early
will give you a strong core to start from.</p>
<blockquote>
<p><strong>Keywords:</strong> The Pint language has a set of keywords that are reserved for use by the language
only, much as in other languages. Keep in mind that you cannot use these words as names of
variables, predicates, types, or macros. Most of the keywords have special meanings, and you’ll be
using them to do various tasks in your Pint programs; You can find a list of the keywords in
<a href="basics/../appendix/keywords.html">Appendix A</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="local-variables"><a class="header" href="#local-variables">Local Variables</a></h2>
<p>Local variables in Pint are similar to local variables in other languages with a few restrictions.
In Pint, variables <strong>must</strong> be initialized and are <strong>immutable</strong>. They basically hold values and
help you write readable code, but are not meant to be modified. This is an important property that
allows Pint to be fully declarative with <em>no control flow</em>. In Pint, the order in which you write
your statements (variable declarations, constraints, etc.) is unimportant and has no impact on the
behavior of the code.</p>
<p>In order to declare a new variable, we use the <code>let</code> keyword:</p>
<pre><code class="language-pint">predicate foo() {
    let x = 5;
    let y: int = 6;

    constraint y - x == 1;
}
</code></pre>
<p>The first <code>let</code> declares a variable named <code>x</code> and assigns its value to <code>5</code>. The second <code>let</code>
declares a variable named <code>y</code> and assigns its value to <code>6</code>. The constraint <code>y - x == 1</code> references
<code>x</code> and <code>y</code> using their names and is obviously always <code>true</code> in this case since <code>6 - 5 == 1</code>.</p>
<p>Note that, while <code>y</code> is annotated with type <code>int</code>, we opted to omit a type annotation for <code>x</code>; we're
relying on the compiler to <em>infer</em> its type to be <code>int</code> since the initializing expression is <code>5</code>
which is an <code>int</code>.</p>
<p>If we were to declare <code>y</code> as follows:</p>
<pre><code class="language-pint">let y: int = true;
</code></pre>
<p>then the compiler would emit an error because the type annotation <code>int</code> and the type of the
initializing expressions <code>true</code> do not match:</p>
<pre><code class="language-console">Error: variable initialization type error
   ╭─[variables.pnt:4:18]
   │
 4 │     let y: int = true;
   │            ─┬─   ──┬─
   │             ╰────────── expecting type `int`
   │                    │
   │                    ╰─── initializing expression has unexpected type `bool`
───╯
</code></pre>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>Name shadowing is not allowed in Pint. Declaring two variables with the same name will result in a
compiler error. For example, the following code fails to compile:</p>
<pre><code class="language-pint">let y = 5;
let y: int = 6;
</code></pre>
<p>and the following error is emitted:</p>
<pre><code class="language-console">Error: symbol `y` has already been declared
   ╭─[variables.pnt:4:9]
   │
 3 │     let y = 5;
   │     ────┬────
   │         ╰────── previous declaration of the symbol `y` here
 4 │     let y: int = 6;
   │         ┬
   │         ╰── `y` redeclared here
   │
   │ Note: `y` must be declared or imported only once in this scope
───╯
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<p>Every value in Pint is of a certain <em>data type</em>, which tells Pint and solvers what kind of data is
being specified so they know how to work with that data. We'll look at two data type subsets: scalar
and compound.</p>
<p>Keep in mind that Pint is a <em>statically typed</em> language, which means that it must know the types of
all variables at compile time. The compiler can often infer what type we want to use based on the
value and how we use it. In cases where many types are possible, we must add a type annotation as
described in the <a href="basics/./variables.html">chapter on local variables</a>.</p>
<h3 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h3>
<p>A <em>scalar</em> type represents a single value. Pint has three primary scalar types: integers, Booleans,
and 256-bit hashes.</p>
<h4 id="integer-type"><a class="header" href="#integer-type">Integer Type</a></h4>
<p>An <em>integer</em> is a number without a fractional component. Pint has a single integer type called <code>int</code>
which, when targeting the EssentialVM, represents a <strong>64-bit signed integer</strong> . An <code>int</code>, therefore,
can store numbers from <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> inclusive, where <code>n</code> is the number of bits that
represent the integer (64 in the case of EssentialVM).</p>
<p>You can write integer literals in any of the forms shown in the table below. Note that number
literals can use <code>_</code> as a visual separator to make the number easier to read, such as <code>1_000</code>, which
will have the same value as if you had specified <code>1000</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Number literals</th><th>Examples</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>12_333</code></td></tr>
<tr><td>Hex</td><td><code>0x123f</code></td></tr>
<tr><td>Binary</td><td><code>0b1111_1101</code></td></tr>
</tbody></table>
</div>
<h4 id="numeric-operations"><a class="header" href="#numeric-operations">Numeric Operations</a></h4>
<p>Pint supports the basic mathematical operations you’d expect for integers: addition, subtraction,
multiplication, division, and remainder. Integer division truncates toward zero to the nearest
integer. The following code shows how you’d use each numeric operation in a <code>let</code> statement:</p>
<pre><code class="language-pint">// addition
let sum = 1 + 2 + 3;

// subtraction
let difference = 15 - 1;

// multiplication
let product = 42 * 42;

// division
let quotient = 3 / 2;
let truncated = -5 / 3; // Results is -1

// remainder
let remainder = 34 % 3;
</code></pre>
<p>Note that binary operators in Pint are strict with regards to what types they allow, that is, only
identical types can be used in a binary operator. For example, adding an <code>int</code> and a <code>bool</code> is not a
valid operation and will result in a compile error.</p>
<h4 id="the-boolean-type"><a class="header" href="#the-boolean-type">The Boolean Type</a></h4>
<p>As in most other programming languages, a Boolean type in Pint has two possible values: <code>true</code> and
<code>false</code>. The Boolean type in Pint is specified using <code>bool</code>. For example:</p>
<pre><code class="language-pint">let t = true;
let f: bool = false;
</code></pre>
<h4 id="the-b256-type"><a class="header" href="#the-b256-type">The <code>b256</code> Type</a></h4>
<p>The <code>b256</code> is a special type that represents a 256-bit hash. It is often used to represent addresses
or storage keys and cannot be used as a numerical integers. That is, two <code>b256</code> values cannot added
for example.</p>
<p>A <code>b256</code> literals can be represented using a Hexadecimal or a Binary literal as follows:</p>
<pre><code class="language-pint">let addr1 = 0x3333333333333333333333333333333333333333333333333333333333333333;
let addr2: b256 = 0b1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111;
</code></pre>
<h3 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h3>
<p>Compound types can group multiple values into one type. Pint has two primitive compound types:
tuples and arrays.</p>
<h4 id="the-tuple-type"><a class="header" href="#the-tuple-type">The Tuple Type</a></h4>
<p>A tuple is a general way of grouping together a number of values with a variety of types into one
compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</p>
<p>We create a tuple by writing a comma-separated list of values inside curly brackets <code>{ .. }</code>. Each
position in the tuple has a type, and the types of the different values in the tuple don’t have to
be the same. We’ve added optional type annotations in this example:</p>
<pre><code class="language-pint">let tup_1: { int, int, bool } = { 42, 4, true };
</code></pre>
<p>The variable <code>tup</code> binds to the entire tuple because a tuple is considered to be a single compound
element. To get the individual values out of a tuple, we can use the period (<code>.</code>) operator followed
by the index of the value we want to access. For example:</p>
<pre><code class="language-pint">let tup_2: { int, int, bool } = { 42, 4, true };
let tup_2_first = tup_2.0;
let tup_2_second = tup_2.1;
let tup_2_third = tup_2.2;
</code></pre>
<p>This program creates the tuple <code>tup_2</code> and then accesses each element of the tuple using its
respective index. As with most programming languages, the first index in a tuple is 0.</p>
<p>It is also possible to name some or all the fields of a tuple type as follows:</p>
<pre><code class="language-pint">let tup_3: { x: int, int, y: bool } = { 42, 4, true };
</code></pre>
<p>Note that, in this example, only two out of the 3 fields are named. In order to access the
individual elements of a tuple with named fields, the period (<code>.</code>) can again be used with either the
index of the tuple field or its name. For example:</p>
<pre><code class="language-pint">let tup_4: { x: int, int, y: bool } = { 42, 4, true };
let tup_4_first = tup_4.0;
let tup_4_first_named = tup_4.x; // same as `tup_4.0`
let tup_4_second = tup_4.1;
let tup_4_third = tup_4.2;
let tup_4_third_named = tup_4.y; // same as `tup_4.y`
</code></pre>
<p>Tuples without any values are not allowed in <code>Pint</code>. That is, the following:</p>
<pre><code class="language-pint">let empty: {} = {};
</code></pre>
<p>is disallowed and errors out as follows:</p>
<pre><code class="language-console">Error: empty tuple types are not allowed
    ╭─[data_types.pnt:43:12]
    │
 43 │ let empty: {} = {};
    │            ─┬
    │             ╰── empty tuple type found
────╯
Error: empty tuple expressions are not allowed
    ╭─[data_types.pnt:43:17]
    │
 43 │ let empty: {} = {};
    │                 ─┬
    │                  ╰── empty tuple expression found
────╯
</code></pre>
<h4 id="the-array-type"><a class="header" href="#the-array-type">The Array Type</a></h4>
<p>Another way to have a collection of multiple values is with an array. Unlike a tuple, every element
of an array must have the same type. Unlike arrays in some other languages, arrays in Pint have a
fixed length.</p>
<p>We write the values in an array as a comma-separated list inside square brackets:</p>
<pre><code class="language-pint">let a = [1, 2, 3, 4, 5];
</code></pre>
<p>You write an array's type using the element type followed by its size between square brackets, like
so:</p>
<pre><code class="language-pint">let b: int[5] = [1, 2, 3, 4, 5];
</code></pre>
<p>Here, <code>int</code> is the type of each element. The number <code>5</code> indicates that the array contains five
elements.</p>
<p>You can access elements of an array using by <em>indexing</em> into it, like this:</p>
<pre><code class="language-pint">let c: int[5] = [1, 2, 3, 4, 5];
let c_first = c[0];
let c_second = c[1];
</code></pre>
<p>In this example, the variable named <code>c_first</code> will get the value <code>1</code> because that is the value at
index <code>0</code> in the array. The variable named <code>c_second</code> will get the value <code>2</code> from index <code>1</code> in the
array.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>All programmers strive to make their code easy to understand, but sometimes extra explanation is
warranted. In these cases, programmers leave comments in their source code that the compiler will
ignore but people reading the source code may find useful.</p>
<p>Here’s a simple comment:</p>
<pre><code class="language-pint">// hello, world
</code></pre>
<p>In Pint, the only comment style supported starts a comment with two slashes, and the comment
continues until the end of the line. For comments that extend beyond a single line, you’ll need to
include <code>//</code> on each line, like this:</p>
<pre><code class="language-pint">// This is some complicated code that requires multiple lines to explain:
// 1. The first predicate, called `GetRich` ensures that we're getting rich.
// 2. The second predicate, called `BeResponsible` ensures that 
//    we're not gambling all the money away.
</code></pre>
<p>Comments can also be placed at the end of lines containing code:</p>
<pre><code class="language-pint">let big_answer = 42; // answer to life, the universe, and everything
</code></pre>
<p>But you’ll more often see them used in this format, with the comment on a separate line above the
code it’s annotating:</p>
<pre><code class="language-pint">// answer to life, the universe, and everything
let big_answer_too = 42;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h2>
<p>Pint has three different ways to express conditionals: select expressions, <code>cond</code> expressions, and
<code>if</code> statements. Conditionals allow you to &quot;branch&quot; your code depending on some condition(s). The
word &quot;branch&quot; is between quotations because Pint is <strong>not</strong> an imperative language and does not
&quot;execute&quot; code. Therefore, conditionals are simply a way of saying: &quot;choose between some expressions
or some constraints based on some condition(s)&quot;.</p>
<p>Pint also has <code>match</code> statements that are useful to reason about <em>unions</em>. Both unions and <code>match</code>
will be discussed separately in <a href="basics/custom_types.html">Chapter 3.5</a></p>
<h3 id="select-expressions"><a class="header" href="#select-expressions">Select Expressions</a></h3>
<p>A select expression allows you to select between two alternatives based on a condition. The two
alternatives must have the same type and that type determines the type of the whole select
expression. For example:</p>
<pre><code class="language-pint">let y = (number &lt; 5 ? 1 : 2);
</code></pre>
<p>All select expressions start with a condition followed by the <code>?</code> symbol. In this case, the
condition checks whether or not the local variable <code>number</code> has a value less than 5. We place the
expression that should be chosen if the condition is <code>true</code> immediately after the <code>?</code> symbol. The
symbol <code>:</code> is then added followed by the expression that should be chosen if the condition is
<code>false</code>. Both options, <code>1</code> and <code>2</code>, have the same type which is <code>int</code> and so, the type of <code>y</code> must
also be <code>int</code>.</p>
<p>If, for example, the types of the two expressions we're selecting from do not match, the compiler
will emit a compile error. For example, if we try to compile the following code:</p>
<pre><code class="language-pint">predicate test(number: int) {
    let y = number &lt; 5 ? 1 : true;
}
</code></pre>
<p>we will get the following error:</p>
<pre><code class="language-console">Error: branches of a select expression must have the same type
   ╭─[test.pnt:2:13]
   │
 2 │     let y = number &lt; 5 ? 1 : true;
   │                          ┬   ──┬─
   │                          ╰───────── 'then' branch has the type `int`
   │                                │
   │                                ╰─── 'else' branch has the type `bool`
───╯
</code></pre>
<p>The condition of a select expression must be a <code>bool</code>. Otherwise, we will get a compile error. For
example, if we try to compile the following code:</p>
<pre><code class="language-pint">predicate test(number: int) {
    let y = number ? 1 : 2;
}
</code></pre>
<p>we will get the following error:</p>
<pre><code class="language-console">Error: condition for select expression must be a `bool`
   ╭─[test.pnt:2:13]
   │
 2 │     let y = number ? 1 : 2;
   │             ───┬──
   │                ╰──── invalid type `int`, expecting `bool`
───╯
</code></pre>
<p>Note that Pint will <strong>not</strong> automatically try to convert non-Boolean types to a Boolean. You must be
explicit and always provide a select expression with a <code>Boolean</code> as its condition.</p>
<h3 id="cond-expressions"><a class="header" href="#cond-expressions"><code>cond</code> Expressions</a></h3>
<p>Pint provides <code>cond</code> expressions. <code>cond</code> expressions are generalized select expressions that are not
limited to only two branches. They provide selection from multiple alternatives, each based on some
condition. For example:</p>
<pre><code class="language-pint">let z = cond {
    x == 0 =&gt; 0,
    x &gt; 0 &amp;&amp; x &lt;= 10 =&gt; 1,
    x &gt; 10 &amp;&amp; x &lt;= 100 =&gt; 2,
    else =&gt; 3
};
</code></pre>
<p>All <code>cond</code> expressions start with the keyword <code>cond</code>, followed by a comma-separated list of
statements in between curly brackets. Each statement describes a condition and an expression that
should be returned by the <code>cond</code> if that condition is correct. The branches are evaluated in order
and the first one to become active determines the value of the <code>cond</code> expression. If all branches
fail, then the <code>cond</code> expression takes the value of the expression in the <code>else</code> branch, which must
always be the last branch.</p>
<p>in the example above, <code>z</code> is equal to <code>0</code> if <code>x == 0</code>, equal to <code>1</code> if <code>x</code> is between <code>0</code> and <code>10</code>,
equal to <code>2</code> if <code>x</code> is between <code>10</code> and <code>100</code>, and equal to <code>3</code> otherwise.</p>
<p>every <code>cond</code> expression can be rewritten using one or more select expressions. however, <code>cond</code> tends
to be more compact and more readable than nested select expressions. for example, the <code>cond</code>
expression in the example above is equivalent to:</p>
<pre><code class="language-pint">let z = x == 0 ? 0 :
               x &gt; 0 &amp;&amp; x &lt;= 10 ? 1
                 : x &gt; 10 &amp;&amp; x &lt;= 100 ? 2 : 3;
</code></pre>
<p>similarly to select expressions, all candidate expressions must have the same type which determines
the type of the whole <code>cond</code> expression. also, every condition must be a <code>bool</code> or else a compile
error will be emitted.</p>
<h3 id="if-statements"><a class="header" href="#if-statements"><code>if</code> Statements</a></h3>
<p><code>if</code> statements are the last class of conditionals we will look at. Unlike select and <code>cond</code>
expressions, <code>if</code> statements are <strong>not</strong> expressions, that is, they do not hold any values. Instead,
they allow predicating <em>blocks of code</em> based on some condition. A block of code in the context of
an <code>if</code> statement is a collection of constraints and other <code>if</code> statements. For example:</p>
<pre><code class="language-pint">if number &lt; 5 {
    constraint x == y;
} else {
    constraint x != y;
}
</code></pre>
<p>All <code>if</code> statements start with the keyword <code>if</code>, followed by a condition. In this case, the
condition checks whether or not the local variable <code>number</code> has a value less than 5. The code block
that should be &quot;active&quot; if the condition is <code>true</code> is placed immediate after the condition inside
curly brackets. Optionally, the keyword <code>else</code> is then added followed by the code block that should
be active if the condition is <code>false</code> (also between curly brackets). In the example above, the <code>if</code>
statement can be read as follows: &quot;if <code>number</code> is less than 5, then <code>x</code> must be equal to <code>y</code>.
Otherwise, <code>x</code> must not be equal to <code>y</code>&quot;.</p>
<p>Similarly to select expressions, the condition of an <code>if</code> statement must be a <code>bool</code>. Otherwise we
will get a compile error.</p>
<p><code>if</code> statements can be nested and can contain an arbitrary number of constraints:</p>
<pre><code class="language-pint">if number &lt; 5 {
    constraint x == y;

    if z &gt; 0 {
        constraint x &gt; number;
        constraint y &gt; number;
    }
} else {
    constraint x != y;

    if z &gt; 0 {
        constraint x &gt; number;
        constraint y &gt; number;
    } else {
        constraint x &lt; number;
        constraint y &lt; number;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h2>
<p>Custom data types are named types that you can define in your program to refer, via an alias, to a
primitive type, a compound type, or a <code>union</code>. Unions are another special class of custom types that
allow you to define a type by enumerating its possible <em>variants</em>.</p>
<p>Both type aliases and union declarations must be made at the top level of a module, and are not
allowed inside a <code>predicate</code> declaration.</p>
<p>This chapter covers type aliases and unions. It also covers <code>match</code> expressions and <code>match</code>
statements which help reason about unions and their variants.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<p>Pint provides the ability to declare a type alias to give an existing type another name. For this we
use the <code>type</code> keyword. For example, we can create the alias <code>Balance</code> to <code>int</code> like so:</p>
<pre><code class="language-pint">type Balance = int;
</code></pre>
<p>Now, the alias <code>Balance</code> is a synonym for <code>int</code>. Values that have the type <code>Balance</code> will be treated
the same as values of type <code>int</code>:</p>
<pre><code class="language-pint">let x: int = 5;
let y: Balance = 5;
constraint x == y;
</code></pre>
<p>Because <code>Balance</code> and <code>int</code> are the same type, we can compare values of both types.</p>
<h3 id="defining-structs-using-type"><a class="header" href="#defining-structs-using-type">Defining structs using <code>type</code></a></h3>
<p>Many programming languages offer the concept of a &quot;struct&quot; which lets you <strong>package</strong> together and
<strong>name</strong> multiple related values that make up a meaningful group. While Pint does not offer a
special <code>struct</code> construct, it does offer a way to name a tuple, name its fields, and access its
elements as if it were a <code>struct</code>.</p>
<p>To define a struct-like tuple (which we will just call a struct going forward), we use the <code>type</code>
keyword followed by the name chosen for the tuple. We then use the <code>=</code> operator to bind the new type
name to a tuple type with all of its fields named.</p>
<p>For example:</p>
<pre><code class="language-pint">type User = {
    status: bool,
    address: b256,
    balance: int,
};
</code></pre>
<p>To use a struct after we’ve defined it, we create an instance of that struct by specifying concrete
values for each of the fields. We create an instance using the same tuple expression syntax: curly
brackets containing <em>key: value</em> pairs, where the keys are the names of the fields and the values
are the data we want to store in those fields. We don’t have to specify the fields in the same order
in which we declared them in the struct. In other words, the struct definition is like a general
template for the type, and instances fill in that template with particular data to create values of
the type. For example, we can declare a particular <code>User</code> as shown below:</p>
<pre><code class="language-pint">let user1: User = {
    status: true,
    address: 0x1111111111111111111111111111111111111111111111111111111111111111,
    balance: 42,
};
</code></pre>
<p>To get a specific value from a struct, we use the dot notation similarly to tuples. For example, to
access this user's balance, we use <code>user1.balance</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="unions"><a class="header" href="#unions">Unions</a></h2>
<p>Unions allow you to define a type by enumerating its possible variants. Where structs and tuples
give you a way of grouping together related fields and data, like a <code>User</code> with its <code>status</code>,
<code>address</code>, and <code>balance</code>, unions give you a way of saying a value is one of possible set of values.
For example, we may want to say that <code>User</code> is one of a set of possible account types that also
includes <code>Contract</code>. To do this, Pint allows us to encode these possibilities as a <code>union</code>.</p>
<p>Let’s look at a situation we might want to express in code and see why unions are useful and more
appropriate that structs in this case. Say we need to describe token ownership of one of three
available tokens on an exchange: DAI, USDC, and USDT. Because these are the only tokens we can work
with, we can enumerate them all as different <em>variants</em>:</p>
<pre><code class="language-pint">union Token = DAI | USDC | USDT;
</code></pre>
<p>Note how the possible variants of <code>Token</code> are separated by a <code>|</code>. <code>Token</code> is now a custom data type
that we can use elsewhere in our code. Any <code>Token</code> can now be <code>DAI</code>, <code>USDC</code>, or <code>USDT</code> but never 2
or more of these at the same time. That property of <code>Token</code> makes the union data structure
appropriate because a union variant can only be one of its variants. All three tokens are still
fundamentally <em>tokens</em>, so they should be treated as the same type when the code is handling
situations that apply to any of these tokens.</p>
<h3 id="union-values"><a class="header" href="#union-values">Union Values</a></h3>
<p>We can now create an instance of each of the three variants of <code>Token</code> like this:</p>
<pre><code class="language-pint">let dai: Token = Token::DAI;
let usdc: Token = Token::USDC;
let usdt: Token = Token::USDT;
</code></pre>
<p>Note that the variants of the union are namespaced under its identifier, and we use a double colon
to separate the two. This is useful because now all three values <code>Token::DAI</code>, <code>Token::USDC</code>, and
<code>Token::USDT</code> are of the same type: <code>Token</code>. We can then, for instance, declare a variable called
<code>token_type</code> to be of type <code>Token</code> and assign it to either variants depending some token ID:</p>
<pre><code class="language-pint">let token_type: Token = cond {
    token_id == 0 =&gt; Token::DAI,
    token_id == 1  =&gt; Token::USDC,
    else =&gt; Token::USDT,
};
</code></pre>
<p>Using unions has even more advantages. Thinking more about our <code>Token</code> type, at the moment we don’t
have a way to store the actual token amount; we only know what kind it is. Given what you know about
structs and tuples, you might be tempted to tackle this problem with structs as follows:</p>
<pre><code class="language-pint">type Balance = {
    token: Token,
    balance: int,
};

predicate balances_1() {
    let alice_bal: Balance = {
        token: Token::DAI,
        balance: 42,
    };

    let bob_bal: Balance = {
        token: Token::USDC,
        balance: 96,
    };
}
</code></pre>
<p>Here, we've defined a new type called <code>Balance</code> that has two fields: a <code>token</code> field that is of type
<code>Token</code> (the union we defined previously) and a <code>balance</code> field of type <code>int</code> that represents the
balance. We have two instances of this type. The first is <code>alice_bal</code>, and it has the value
<code>Token::DAI</code> as its <code>token</code> with associated <code>balance</code> of <code>42</code>. The second instance is <code>bob_bal</code>. It
has another variant of <code>Token</code> as its <code>kind</code> value, <code>Token::USDC</code>, and has a <code>balance</code> of <code>96</code>
associated with it. We've used a struct to bundle the <code>token</code> and <code>balance</code> values together, so now
the variant is associated with the value.</p>
<p>However, representing the same concept using just a union is more concise: rather than a union
inside a struct, we can put data directly into each union variant. This new definition of the
<code>Token</code> union says that the variants <code>DAI</code>, <code>USDC</code>, and <code>USDT</code> will have associated <code>int</code> values:</p>
<pre><code class="language-pint">union TokenBalance = DAI(int) | USDC(int) | USDT(int);

predicate balances_2() {
    let alice_bal: TokenBalance = TokenBalance::DAI(42);
    let bob_bal: TokenBalance = TokenBalance::USDC(96);
}
</code></pre>
<p>We attach data to each variant of the union directly, so there is no need for an extra struct. Also
notice the syntax for constructing an instance of the union where the value held by a variant is
added between parentheses after the variant name.</p>
<p>There's another advantage to using a union rather than a struct: each variant can have different
types and amounts of associated data. Let's look at another example of a union that has a wide
variety of types embedded in its variants:</p>
<pre><code class="language-pint">union Action =   Quit                                // Quit the application
               | Buy (TokenBalance)                  // Buy some amount of a token
               | Sell({TokenBalance, price: int})    // sell some amount of a token at some price
               | Swap({TokenBalance, TokenBalance}); // Swap some amount of a token for another amount of some other token
</code></pre>
<p>This union has four variants with different types:</p>
<ul>
<li><code>Quit</code> has no data associated with it at all.</li>
<li><code>Buy</code> includes a <code>TokenBalance</code>.</li>
<li><code>Sell</code> and <code>Swap</code> includes tuples.</li>
</ul>
<p>Defining a union with variants such as the ones above is similar to defining different kinds of
struct definitions, except the union variants are grouped together under the <code>Action</code> type which
makes it easier to reason about them as part of a single type.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="the-match-construct"><a class="header" href="#the-match-construct">The <code>match</code> Construct</a></h2>
<p>Pint has the powerful construct <code>match</code> that allows you to inspect a value that has a union type and
conditionally execute some code based on which union variant that union value matches. The power of
<code>match</code> comes from the introduction of the union variant datum into a specific scope, and the fact
that the compiler confirms that all possible variants are handled.</p>
<p>Pint has both <code>match</code> <strong>expressions</strong> and <code>match</code> <strong>statements</strong>, the distinction between which is
illustrated below.</p>
<h3 id="match-as-an-expression"><a class="header" href="#match-as-an-expression"><code>match</code> as an Expression</a></h3>
<p>Consider the following example which takes an unknown US coin and determines which coin it is and
returns its value in cents:</p>
<pre><code class="language-pint">union Coin = Penny | Nickel | Dime | Quarter;

predicate CoinConversion1(coin: Coin) {
    let coin_in_cents = match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    };
}
</code></pre>
<p>Let’s break down the <code>match</code> expression above. First we list the <code>match</code> keyword followed by an
expression, which in this case is the value <code>coin</code>. This seems very similar to a conditional
expression used with <code>cond</code>, but there’s a big difference: with <code>cond</code>, the condition needs to
evaluate to a Boolean value, but here it has to be a union variant of <code>Coin</code> because this is the
type of the value <code>coin</code>.</p>
<p>Next are the <code>match</code> arms. An arm has two parts: a pattern and some code. The first arm here has a
pattern that is the value <code>Coin::Penny</code> and then the <code>=&gt;</code> operator that separates the pattern and
the code to run. The code in this case is just the value <code>1</code>. Each arm is separated from the next
with a comma.</p>
<p>In this particular example, the code associated with each arm is an expression, and the resultant
value of the expression in the matching arm is the value that gets returned for the entire <code>match</code>
expression.</p>
<p>It is also possible to include <code>constraints</code> in the match arm code, but you must use curly brackets.
For example, the following code requires the Boolean variable <code>is_lucky_penny</code> to be <code>true</code> if the
value <code>coin</code> is a <code>Coin::Penny</code>.</p>
<pre><code class="language-pint">predicate CoinConversion2(coin: Coin, is_lucky_penny: bool) {
    let coin_in_cents = match coin {
        Coin::Penny =&gt; {
            constraint is_lucky_penny;
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    };
}
</code></pre>
<h4 id="patterns-that-bind-to-values"><a class="header" href="#patterns-that-bind-to-values">Patterns that Bind to Values</a></h4>
<p>Another useful feature of match arms is that they can bind to the value that match the pattern. This
is how we can extract values out of union variants.</p>
<p>As an example, let's change our union variants to hold data inside them. Namely, we want each
variant to hold an <code>int</code> that represents the number of coins available:</p>
<pre><code class="language-pint">union Coins = Penny(int) | Nickel(int) | Dime(int) | Quarter(int);
</code></pre>
<p>Now, given a value <code>coins</code> of type <code>Coins</code>, we can compute the total number of cents that <code>coins</code> is
equivalent to as follows:</p>
<pre><code class="language-pint">predicate CoinConversion3(coins: Coins) {
    let coins_in_cents = match coins {
        Coins::Penny(n) =&gt; n,
        Coins::Nickel(n) =&gt; n * 5,
        Coins::Dime(n) =&gt; n * 10,
        Coins::Quarter(n) =&gt; n * 25,
    };
}
</code></pre>
<p>In the <code>match</code> expression above, we add a variable called <code>n</code> for each of the patterns. In each
pattern, <code>n</code> will bind to the value that the union variant holds. For example, if <code>coins</code> is equal
to <code>Coin::Nickel(42)</code>, then we expect <code>coins_in_cents</code> to be equal to <code>42 * 5 == 210</code>.</p>
<p>Note that <code>match</code> expressions can be nested. Here's an example that has nested unions and nested
<code>match</code> expressions to compute a <code>prize</code> given a coin and the face it landed on in a head-or-tails
game.</p>
<pre><code class="language-pint">union Face = Head | Tail;
union CoinFace =  Penny(Face)
                | Nickel(Face)
                | Dime (Face)
                | Quarter(Face);

predicate CoinGame1(coin: CoinFace) {
    let prize = match coin {
        CoinFace::Penny(f) =&gt; match f {
            Face::Head =&gt; 100,
            Face::Tail =&gt; 200,
        },
        CoinFace::Nickel(f) =&gt; 5 * match f {
            Face::Head =&gt; 10,
            Face::Tail =&gt; 20,
        },
        CoinFace::Dime(f) =&gt; 10 * match f {
            Face::Head =&gt; 5,
            Face::Tail =&gt; 10,
        },
        CoinFace::Quarter(f) =&gt; 25 * match f {
            Face::Head =&gt; 1,
            Face::Tail =&gt; 2,
        },
    };
}
</code></pre>
<h3 id="match-as-a-statement"><a class="header" href="#match-as-a-statement"><code>match</code> as a Statement</a></h3>
<p>In some cases, you may not need a <code>match</code> to return a value. Instead, you may simply want to enforce
conditional constraints based on which pattern matches the given value. Below is a rewrite of the
previous example that uses <code>match</code> statements. The code exhibits the exact same behavior as before
but written different to showcase <code>match</code> statements.</p>
<pre><code class="language-pint">predicate CoinGame2(coin: CoinFace, prize: int) {
    match coin {
        CoinFace::Penny(f) =&gt; {
            match f {
                Face::Head =&gt; {
                    constraint prize == 100;
                }
                Face::Tail =&gt; {
                    constraint prize == 200;
                }
            }
        }
        CoinFace::Nickel(f) =&gt; {
            if f == Face::Head {
                constraint prize == 5 * 10;
            } else {
                constraint prize == 5 * 20;
            }
        }
        CoinFace::Dime(f) =&gt; {
            constraint f == Face::Head ? 10 * 5 : 10 * 10;
        }
        CoinFace::Quarter(f) =&gt; {
            constraint prize == 25 * match f {
                Face::Head =&gt; 1,
                Face::Tail =&gt; 2,
            };
        }
    }
}
</code></pre>
<p>Here, the top level <code>match</code> is a statement, not an expression; it does not return any value.
Instead, it declares some constraints, each based on one or more conditions. .</p>
<ul>
<li>If <code>coin</code> matches <code>CoinFace::Penny(f)</code>, then we add another <code>match</code> statement that includes
different constraints based on what pattern <code>f</code> matches.</li>
<li>If <code>coin</code> matches <code>CoinFace::Nickel(f)</code>, then we add an <code>if</code> statement that also includes
different constraints based on whether <code>f</code> is equal to <code>Face::Head</code> or not.</li>
<li>If <code>coin</code> matches <code>CoinFace::Dime(f)</code>, then we add a single constraint that uses a select
expression to compute the prize.</li>
<li>If <code>coin</code> matches <code>CoinFace::Quarter(f)</code>, then we add a single constraint that relies on a <code>match</code>
expression.</li>
</ul>
<p>As shown, nested <code>if</code> statements and <code>match</code> statements are allowed within <code>match</code> statement arms,
as are <code>constraint</code> statements.</p>
<h3 id="matches-are-exhaustive"><a class="header" href="#matches-are-exhaustive">Matches are Exhaustive</a></h3>
<p>There’s one other aspect of <code>match</code> we need to discuss: the arms’ patterns must cover all
possibilities. Consider the following version of variables <code>coins</code> and <code>coins_in_cents</code> previously
declared:</p>
<pre><code class="language-pint">let coins_in_cents = match coins {
    Coins::Penny(n) =&gt; n,
    Coins::Nickel(n) =&gt; n * 5,
    Coins::Quarter(n) =&gt; n * 25,
};
</code></pre>
<p>We didn't handle the <code>Coins::Dime(n)</code> case, so this code will cause a bug. Luckily, it's a bug the
Pint compiler knows how to catch. If we try to compile this code, we'll get this error:</p>
<pre><code class="language-console">Error: not all match variants are covered
    ╭─[match.pnt:42:26]
    │
 42 │ ╭─▶     let coins_in_cents = match coins {
    ┆ ┆
 46 │ ├─▶     };
    │ │
    │ ╰──────────── not all variants for union `::Coins` are covered by match
    │
    │     Help: branches and/or bindings are required for variant `Coins::Dime`
────╯
Error: could not compile `match.pnt` due to previous error
</code></pre>
<p>The Pint compiler knows that we didn't cover every possible case, and even knows which pattern we
forgot. Matches in Pint are <em>exhaustive</em>: we must exhaust every last possibility in order for the
code to be valid. This is true for both <code>match</code> expressions and <code>match</code> statements!</p>
<h3 id="catch-all-patterns"><a class="header" href="#catch-all-patterns">Catch-all Patterns</a></h3>
<p>In the case where not every variant is significant, <code>match</code> expressions and statements may employ an
<code>else</code> arm. It must be declared last and will obviously have no value bound, and is useful to
evaluate to a default value for <code>match</code> expressions, or to contain default declarations (or none)
for <code>match</code> statements.</p>
<p>To get the above example to compile with a default value of zero, implying any other coins actually
have no value, an <code>else</code> may be used as follows:</p>
<pre><code class="language-pint">    let coins_in_cents = match coins {
        Coins::Penny(n) =&gt; n,
        Coins::Nickel(n) =&gt; n * 5,
        Coins::Quarter(n) =&gt; n * 25,
        else =&gt; 0,
    };
</code></pre>
<p>The code compiles, even though we haven't listed all the possible values a <code>Coins</code> can have, because
the last pattern will match all values not specifically listed. This catch-all pattern meets the
requirement that <code>match</code> must be exhaustive.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p>Constraints are the building blocks of a Pint contract. Simply put, a constraint is a statement that
starts with the keyword <code>constraint</code> followed by a <strong>Boolean</strong> expression:</p>
<pre><code class="language-pint">constraint x == 0;
</code></pre>
<p>The above is a simple constraint which ensures that the value of <code>x</code> is exactly 0. Every proposed
solution to this contract must set <code>x</code> to 0. Otherwise, the constraint will fail. If we have
multiple constraint statements, then all of them must be satisfied for a solution to be valid. For
example:</p>
<pre><code class="language-pint">constraint y &gt;= 0;
constraint y &lt;= 10;
</code></pre>
<p>In the above, every valid solution must set <code>y</code> to a value between 0 and 10.</p>
<p>Note that the above is actually equivalent to:</p>
<pre><code class="language-pint">constraint y &gt;= 0 &amp;&amp; y &lt;= 10;
</code></pre>
<p>However, you may find it easier to structure your code into multiple separate constraints.
Otherwise, you'll find yourself with a giant constraint statement that is hard to read and maintain.</p>
<p>As mentioned above, the expression of a constraint statement must be of type boolean. Otherwise, a
compile error will be produced. For example:</p>
<pre><code class="language-pint">constraint x + y
</code></pre>
<p>will result in the following error:</p>
<pre><code class="language-console">Error: constraint expression type error
    ╭─[example.pnt:16:1]
    │
 16 │ constraint x + y;
    │ ────────┬───────
    │         ╰───────── constraint expression has unexpected type `int`
    │         │
    │         ╰───────── expecting type `bool`
────╯
Error: could not compile `example.pnt` due to previous error
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Sometimes it may be desirable to use a common constant value for re-use throughout a program which
is not a parameter to be solved or variable to be computed. These may be declared in Pint using the
<code>const</code> keyword.</p>
<p><code>const</code> declarations resemble <code>var</code> declarations in that they name an optionally typed value with an
initializer.</p>
<pre><code class="language-pint">const minimum: int = 10;
const maximum: int = 20;

predicate Foo(foo: int, size: int) {
    constraint size &gt;= minimum &amp;&amp; foo &lt;= maximum;
}

</code></pre>
<p>Like <code>var</code> declarations the type may be omitted and will be inferred by the Pint compiler, but the
<code>const</code> initializer is required and must a constant expression which does not refer to predicate
parameter variables nor other non-constant values.</p>
<h3 id="constants-of-compound-types"><a class="header" href="#constants-of-compound-types">Constants of Compound Types</a></h3>
<p><code>const</code> declarations may refer to values with compound types as long as every element within is a
constant value. Constant value initializers may also dereference other array or tuple <code>const</code>
declarations or even array or tuple literals.</p>
<pre><code class="language-pint">const counts = [20, 30, 40];

const default_idx = 1;
const next_count = counts[default_idx + 1];

const min_size = { valid: true, size: 10 };

predicate Bar(my_size: int) {
    constraint !min_size.valid || my_size &gt;= min_size.size;
}
</code></pre>
<p>In the above example <code>next_count</code> is evaluated <strong>at compile time</strong> to be fixed as 40.</p>
<p>The <code>min_size</code> tuple is adding a flag to a value to mark whether it should be used or not in a
constraint. This may be convenient during development for turning the <code>min_size.size</code> constraint on
or off.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>Most useful Pint contracts require some sort of <em>persistent storage</em> that represent <em>state</em>. After
all, a blockchain is a decentralized distributed database and contracts are a way to enforce rules
on how &quot;entries&quot; in this database are allowed to change. Therefore, having the ability to express
those database entries using variables and dynamic containers is quite useful. For that reason, Pint
offers a way to declare and access a variety of storage types.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>How to declare and access storage variables with statically-sized types.</li>
<li>How to declare and access storage variables with dynamically-sized types.</li>
<li>How to access storage variables that belong to an external contract.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="statically-sized-storage-types"><a class="header" href="#statically-sized-storage-types">Statically-Sized Storage Types</a></h2>
<p>All storage variables in a Pint contract must be declared inside a <code>storage</code> block, and there can
only be a single <code>storage</code> block in a Pint contract. The <code>storage</code> block is optional and can be
skipped if the contract does not need to manage any state, but such contracts are generally not very
useful.</p>
<p>Here's an example of a <code>storage</code> block:</p>
<pre><code class="language-pint">union TokenBalance = DAI(int) | USDC(int) | USDT(int);
storage {
    x: int,
    bal: int,
    a: b256,
    t: { int, bool },
    y: bool,
    w: int,
    arr: { int, int }[3],
    v: { int, { bool, b256 } },
    u: TokenBalance,
}
</code></pre>
<p>A <code>storage</code> starts with the keyword <code>storage</code> and followed by a comma-separated list of variable
declarations inside curly brackets. Each variable declaration is an identifier annotated with a
type. In this chapter, we're only looking at storage variables that have statically-sized types,
i.e., types that have known sizes and layouts at compile time. This pretty much covers every type we
discussed so far! In the next chapter, we will introduce new storage-only types that are dynamically
sized.</p>
<p>Back to the example above, the declared <code>storage</code> block is fairly simple. It contains several
variables with different primitive and compound types. Similarly to predicate parameters, storage
variables <strong>must</strong> have a type annotation.</p>
<h3 id="accessing-storage-variables"><a class="header" href="#accessing-storage-variables">Accessing Storage Variables</a></h3>
<p>Storage variables are not useful unless we can read them and/or <em>propose modifications to them</em>.
Recall that Pint is a declarative constraint-based language, and therefore, does not allow &quot;writing&quot;
directly to a storage variable. Writing directly to storage is a concept you might be familiar with
from other smart contract languages like <a href="https://soliditylang.org/">Solidity</a>, so you might be
asking yourself the following question: &quot;if I can't write directly to storage variables, how will
their values ever change? How will the state of the blockchain ever change?&quot;</p>
<p>The answer to these questions lies at the core of what makes Pint and <em>declarative blockchains</em>
actually <strong>declarative</strong>. Pint has no concept of &quot;updating&quot; state (or even predicate parameters or
local variables for that matter). Pint simply <em>expresses</em> a desired outcome using <code>constraint</code>
statements and relies on <em>solutions</em> to actually propose state changes.</p>
<p>In order to express a desired outcome for a given storage variable, two things are needed:</p>
<ol>
<li>A way to read the <strong>current</strong> value of the variable.</li>
<li>A way to express the <strong>future</strong> value of the variable.</li>
</ol>
<h4 id="reading-a-storage-variable"><a class="header" href="#reading-a-storage-variable">Reading a Storage Variable</a></h4>
<p>Reading a storage variable should not be an unfamiliar concept to you if you've worked with other
smart contract languages before like <a href="https://soliditylang.org/">Solidity</a>. The syntax for reading a
storage variable in Pint requires the <code>storage</code> keyword again:</p>
<pre><code class="language-pint">let a = storage::a;
let t = storage::t;
let t_1 = storage::t.1;
let arr_2_1: int = storage::arr[2].1;

let x = storage::x;
let incremented = storage::x + 1;

constraint incremented == x + 1; // always true!
</code></pre>
<p>A few things to note here:</p>
<ol>
<li>Storage read expressions always start with <code>storage::</code> followed by the name of the variable we're
trying to read. The <code>storage::</code> syntax means we're switching namespaces to that of the <code>storage</code>
block.</li>
<li>Each storage read expression is used in the initializer of a local variable. In fact, storage
read expressions can <strong>only</strong> ever be used in initializers of local variables. Using a storage
read expression in other contexts, such as in <code>constraint storage::x == 5</code>, is currently illegal.</li>
<li>Fields or elements of a compound type in storage can be accessed individually, as in
<code>storage::t.1</code> and <code>storage::arr[2].1</code>.</li>
<li>Arbitrary expressions that include storage read expressions can also be used to initialize local
variables. Variable <code>incremented</code> is an example of that.</li>
</ol>
<p>Note that, while storage read expressions cannot be evaluated at compile time, they are actually
known at solve-time: right before the solving process starts, every storage read expression is
evaluated by directly inspecting the blockchain. The result is then used in the corresponding local
variable initializer expression which becomes known in preparation for solving.</p>
<h4 id="next-state"><a class="header" href="#next-state">Next State</a></h4>
<p>Recall that expressing a desired outcome for a given storage variable also requires a way to express
the <strong>future</strong> value of the variable.</p>
<p>In most imperative languages, statements like <code>x = x + 1</code> are commonly used to mean &quot;<em>update</em> the
value of <code>x</code> to be equal to the <em>current</em> value of <code>x</code> plus <code>1</code>&quot;. Because Pint is a constraint-based
declarative language where the order of statements does not matter and there is no sequential
execution, statements like <code>x = x + 1</code> cannot be written and are not logical. Instead, Pint offers a
special syntax, reserved for local variables, that means &quot;the future value of&quot;. Here's an example:</p>
<pre><code class="language-pint">let bal = mut storage::bal;
constraint bal' &gt;= bal + 42;
</code></pre>
<p>Here, <code>bal'</code>, unlike <code>bal</code>, is actually <strong>unknown at solve-time</strong>. That is, <code>bal'</code> must be solved
for as if it were a predicate parameter and every solution must include a proposed value for <code>bal'</code>.
If, for example, the value of <code>bal</code> was read to be <code>100</code> at solve-time, a solver might propose that
the next value of <code>bal</code> should be <code>150</code> (i.e. <code>bal' = 150</code>) which would be a valid solution because
<code>150 &gt;= 100 + 42</code> (assuming all other constraints in the predicate are also satisfied).</p>
<p>The <code>'</code> operator can also be used for variables that have arbitrary initializers. For example:</p>
<pre><code class="language-pint">let bal_in_dollars = price * mut storage::bal;
constraint bal_in_dollars' == price * bal'; // always true!
</code></pre>
<p>Basically, when validating a solution, <code>bal_in_dollars'</code> is computed by plugging in the <em>new</em> value
of <code>storage::bal</code> into the expression <code>price * storage::bal</code>. That is, a valid solution must satisfy
<code>bal_in_dollars' == price * bal'</code> where <code>bal_in_dollars</code> is computed in this way (this just happens
to be always true in this case!).</p>
<p>As you can imagine, using the <code>'</code> operator for variables that do not depend on storage accesses is a
no-op. For example</p>
<pre><code class="language-pint">let z = 42;
constraint z' == z; // always true
</code></pre>
<h4 id="mutable-storage-accesses"><a class="header" href="#mutable-storage-accesses">&quot;Mutable&quot; Storage Accesses</a></h4>
<p>In the previous section, you may have noticed that we added the <code>mut</code> keyword before <code>storage::bal</code>
in the declaration of <code>bal</code>. In Pint, storage locations are <strong>non-mutable by default</strong>. That is,
solvers cannot propose new values for a storage location <em>unless</em> they are solving a predicate that
allows the storage location to be mutable. This is accomplished using the <code>mut</code> keyword added before
a storage access. In the example of the previous section, because <code>mut</code> was added before
<code>storage::bal</code>, a solver can now propose a <em>state mutation</em> that updates the value of <code>x</code>.</p>
<p>When the <code>mut</code> keyword as added before a storage access into a compound type, mutability applies
<strong>only</strong> to the portion of the compound type that is being accessed. For example, in the example
below:</p>
<pre><code class="language-pint">let inner: { bool, b256 } = mut storage::v.1;
</code></pre>
<p><code>v.1</code> is a storage access into nested tuple <code>v</code> defined in the <code>storage</code> block declared earlier.
Here, both <code>v.1.0</code> ( a <code>bool</code>) and <code>v.1.1</code> (a <code>b256</code>) are both allowed to be mutated, but <code>v.0</code> is
not allowed to be.</p>
<h4 id="empty-state"><a class="header" href="#empty-state">&quot;Empty&quot; State</a></h4>
<p>You may be wondering what happens if a storage variable was never previously updated but was read
anyways. In this case, there is no value stored at that storage variable and nothing can be read.
To help you reason about this, Pint provides the literal <code>nil</code> to represent the <em>absence of a
value</em>. For example,</p>
<pre><code class="language-pint">let w = mut storage::w;
let value_1 = (w == nil ? 0 : w);
</code></pre>
<p>In the example above, we first check if <code>w</code> is <code>nil</code> before attempting to read it. If it is <code>nil</code>
(i.e. currently has no value), then we initialize <code>value_1</code> to <code>0</code>. Otherwise, we initialize it to
the non-empty value of <code>w</code>. Without checking if <code>w</code> is <code>nil</code> first, and if we're not sure whether
<code>w</code> has a value or not, then it is possible that the state read operation will fail causing a
<em>panic</em> in the VM.</p>
<p>The following is also a valid approach for handling <code>nil</code> checks:</p>
<pre><code class="language-pint">let value_2 = (mut storage::w == nil) ? 0 : storage::w;
constraint value_2 == value_1; // always true!
</code></pre>
<p>It is also possible to update a variable to <code>nil</code> using the &quot;next state&quot; operator:</p>
<pre><code class="language-pint">if w != nil {
    constraint w' == nil;
}
</code></pre>
<p>Here, if <code>w</code> currently has a value, then we constrain the next value of <code>w</code> to be <code>nil</code>.</p>
<p>This concludes our overview on storage which only focused on statically-sized storage types. In the
next chapter, we will cover dynamically-sized storage types which offer a lot more flexibility.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="dynamically-sized-storage-types"><a class="header" href="#dynamically-sized-storage-types">Dynamically-sized Storage Types</a></h2>
<p>Pint includes a number of very useful data structures called <em>storage collections</em>. Most other data
types represent one specific value, but storage collections can contain multiple values. Unlike the
built-in array and tuple types, the amount of data that these collections hold does not need to be
known at compile time and can grow or shrink as the blockchain state evolve. Each kind of collection
has different capabilities and costs, and choosing an appropriate one highly depends on the
situation at hand. In this chapter, we'll discuss two collections that are used very often in Pint
contracts:</p>
<ul>
<li><strong>Storage Map</strong>: allows you to associated a value with a particular key.</li>
<li><strong>Storage Vector</strong>: allows you to store a variable number of values.</li>
</ul>
<p>We'll discuss how to create and update storage maps and storage vectors.</p>
<h3 id="storage-map"><a class="header" href="#storage-map">Storage Map</a></h3>
<p>The first collection we will look at is the storage map. A storage map stores a mapping of keys of
some type <code>K</code> to values of some type <code>V</code>. Storage maps are useful when you want to look up data by
using a key that can be of any type. For example, in the <a href="storage/../examples/subcurrency.html">Subcurrency</a>
contract, we kept track of each user’s token balance in a map in which each key is a user’s address
and the values are each user’s balance. Given a user address, you can retrieve their balance.</p>
<h4 id="creating-a-new-storage-map"><a class="header" href="#creating-a-new-storage-map">Creating a New Storage Map</a></h4>
<p>Because storage maps are a storage type, they must always be declared inside a <code>storage</code> block. The
storage map type is a built-in type with a specific syntax:</p>
<pre><code class="language-pint">storage {
    // ...
    balances: (b256 =&gt; int),
    // ...
}
</code></pre>
<p>Here, a new storage map, called <code>balances</code>, is declared that maps <code>b256</code> keys to <code>int</code> values. The
storage map type is always declared using parentheses that contain two types separated by a <code>=&gt;</code>.
It should be clear that storage maps are <em>homogeneous</em>, that is, all of the keys must have the same
type as each other, and all of the values must have the same type as well.</p>
<h4 id="accessing-values-in-a-storage-map"><a class="header" href="#accessing-values-in-a-storage-map">Accessing Values in a Storage Map</a></h4>
<p>We can get a value out of the storage map by providing its key in between square brackets, similar
to how arrays are accessed:</p>
<pre><code class="language-pint">let from_balance = storage::balances[from_address];
let receiver_balance = storage::balances[receiver_address];
</code></pre>
<p>Here, <code>from_balance</code> will have the value that's associated with <code>from_address</code> and
<code>receiver_balance</code> will have the value that's associated with <code>receiver_address</code>. Because the values
returned are storage values, they must be used in the initializers of some local variables. Using a
storage map access expression in any other context results in a compile error.</p>
<h4 id="updating-a-storage-map"><a class="header" href="#updating-a-storage-map">&quot;Updating&quot; a Storage Map</a></h4>
<p>As we've mentioned a few times already, explicitly &quot;updating&quot; <em>anything</em> in Pint is not a valid
operation because Pint has no sequential execution. However, as in the case with statically-sized
storage types, we can <em>require</em> that the next value of a specific entry in a storage map satisfy
some constraint(s):</p>
<pre><code class="language-pint">let my_bal = mut storage::balances[my_address];
constraint my_bal' == my_bal + 1_000_000;
</code></pre>
<p>Here, we are requiring that our balance go up by 1 million, by applying the &quot;prime&quot; operator on the
state variable that holds our current balance. Of course, requiring a change in state does not mean
it will actually happen! Otherwise, we can all become instantly rich by deploying predicates like
this. Unless a solution that does not violate any of the deployed rules (i.e. constraints) is
submitted by a solver, the desired state change will never be satisfied.</p>
<h4 id="missing-keys"><a class="header" href="#missing-keys">&quot;Missing&quot; Keys</a></h4>
<p>Now, you may be wondering what happens if a key is missing from a storage map and we try to access
it anyways. In Pint, a <a href="storage/static.html#empty-state"><code>nil</code></a> is returned. In the previous example, if the
balance of <code>my_address</code> was never actually modified in the past, then <code>my_bal</code> would be equal to
<code>nil</code> and therefore, the expression <code>my_bal + 1000000</code> would panic. To avoid this problem, we can
first check if <code>my_bal</code> is <code>nil</code> before trying to use it in an arithmetic operation:</p>
<pre><code class="language-pint">if my_bal != nil {
    constraint my_bal' == my_bal + 1_000_000;
} else {
    constraint my_bal' == 1_000_000;
}
</code></pre>
<p>Here, if <code>my_bal</code> is not <code>nil</code>, then the constraint remains the same as before. Otherwise, we simply
update <code>my_bal</code> to <code>1000000</code> (as if <code>my_bal</code> was previously 0!).</p>
<h4 id="complex-maps"><a class="header" href="#complex-maps">Complex Maps</a></h4>
<p>Storage maps can be declared to be arbitrarily complex. They can also be nested!</p>
<pre><code class="language-pint">storage {
    // ...
    complex_map: ( { int, int } =&gt; { bool, b256 } ),
    nested_map: (b256 =&gt; (int =&gt; bool)),
    // ...
}
</code></pre>
<p>In the example above, the fist storage map maps a tuple to another tuple. The second storage map
maps a <code>b256</code> to another map! The way to access entries in these maps is fairly intuitive and is
exactly what you'd expect:</p>
<pre><code class="language-pint">predicate foo(addr1: b256) {
    let complex_read: b256 = storage::complex_map[{42, 69}].1;

    let nested_read: bool = storage::nested_map[addr1][100];
}
</code></pre>
<p>The first storage access reads a tuple value using a key that itself is a tuple, and then accesses
its second field. The second storage access is a nested map access using two index operators. Note
that the first index operator accesses the first key (<code>b256</code> in this case) and the second index
operator accesses the second key (<code>int</code> in this case).</p>
<h4 id="illegal-uses-of-the-storage-map-type"><a class="header" href="#illegal-uses-of-the-storage-map-type">Illegal Uses of the Storage Map Type</a></h4>
<p>It may be tempting to write code like this:</p>
<pre><code class="language-pint">storage {
    // ...
    nested_map: (b256 =&gt; (int =&gt; bool)),
    // ...
}

predicate test(addr: b256, my_map: (int =&gt; bool)) {
    let nested_map: (b256 =&gt; (int =&gt; bool)) = storage::nested_map;
    let nested_map_inner: (int =&gt; bool) = storage::nested_map[addr];
}
</code></pre>
<p>However, the compiler will disallow this by emitting the following errors:</p>
<pre><code class="language-console">Error: predicate parameters cannot have storage types
   ╭─[bad.pnt:7:28]
   │
 7 │ predicate test(addr: b256, my_map: (int =&gt; bool)) {
   │                            ──────────┬──────────
   │                                      ╰──────────── found parameter of storage type ( int =&gt; bool ) here
───╯
Error: local variables cannot have storage types
   ╭─[bad.pnt:8:5]
   │
 8 │     let nested_map: (b256 =&gt; (int =&gt; bool)) = storage::nested_map;
   │     ──────────────────────────────┬──────────────────────────────
   │                                   ╰──────────────────────────────── found local variable of storage type ( b256 =&gt; ( int =&gt; bool ) ) here
───╯
Error: local variables cannot have storage types
   ╭─[bad.pnt:9:5]
   │
 9 │     let nested_map_inner: (int =&gt; bool) = storage::nested_map[addr];
   │     ───────────────────────────────┬───────────────────────────────
   │                                    ╰───────────────────────────────── found local variable of storage type ( int =&gt; bool ) here
───╯
</code></pre>
<p>Hopefully the error messages are clear enough. What the compiler is telling us here is that we
cannot have predicate parameters or local variables that hold entire storage maps. A storage map is
not exactly an object that we can store a reference to or copy/move around.</p>
<h3 id="storage-vector"><a class="header" href="#storage-vector">Storage Vector</a></h3>
<blockquote>
<p><strong>Note</strong>: Storage vectors are work-in-progress</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="external-storage-access"><a class="header" href="#external-storage-access">External Storage Access</a></h2>
<p>It is common for one smart contract to want to reason about the state of another external smart
contract. For example, a decentralized exchange contract typically requires reading and modifying
the state (balances) owned by the external contracts of the tokens that are to be traded through the
exchange.</p>
<p>In imperative smart contract languages like <a href="https://soliditylang.org/">Solidity</a>, reasoning about
external state is typically done by <em>calling</em> some methods in the external contract that access or
modify that contract's state. In Pint however, the storage variables of a contract are <strong>public</strong>
and can be accessed from outside the contract using the contract's
<a href="storage/../smart_contracts/index.html#contract-interfaces">interface</a>.</p>
<p>While a contract's interface contains all the public symbols that can be externally accessed, it
does not specify the <em>address</em> of the contract. The <em>address</em> of a contract is a 256-bit value that
uniquely identify the contract on the blockchain. Specifying the address is required because
multiple contracts with different implementations may share the same interface.</p>
<p>Recall the interface of the <a href="storage/../examples/counter.html">counter example</a> that we presented earlier:</p>
<pre><code class="language-pint">interface Counter {
    storage {
        counter: int,
    }

    predicate Initialize(value: int);

    predicate Increment(amount: int);
}
</code></pre>
<p>Assume that a contract with that interface has been deployed and has the following address:</p>
<pre><code class="language-pint">const ContractID: b256 = 0x6D05CB94739FFB92CA96750EBF262A82C3ED8F05262DD26B503D732F0B74777E;
</code></pre>
<p>In order to access storage variable <code>counter</code> from interface <code>Counter</code>, we can create a path to
<code>conter</code> as follows:</p>
<pre><code class="language-pint">let counter = Counter@[ContractID]::storage::counter;
</code></pre>
<p>The path <code>Counter@[ContractID]::storage::counter</code> has three parts separated by <code>::</code>:</p>
<ol>
<li>The name of the interface <code>Counter</code> followed by the address of the corresponding deployed
contract in between <code>@[..]</code>.</li>
<li>The keyword <code>storage</code> to indicate that we're accessing the <code>storage</code> block of <code>Counter</code>.</li>
<li><code>counter</code>, the name of the storage variable we want to access.</li>
</ol>
<p>We can now use the local variable <code>counter</code> as usual. For example, we can constrain it as follows:</p>
<pre><code class="language-pint">constraint counter' &gt;= 100;
</code></pre>
<p>This implies that we want that new value of the counter (which is owned by the external contract) to
be at least <code>100</code>. This could be accomplished in different ways:</p>
<ol>
<li>If the current value of the counter is at least <code>100</code>, then nothing needs to be done. We don't
even need to propose a solution for any predicates in the external contract.</li>
<li>If the current value of the counter is less than <code>100</code>, then the solution <strong>must</strong>:
<ol>
<li>Either solve predicate <code>Initialize</code> with parameter <code>value</code> set to <code>100</code> or more.</li>
<li>Or solve predicate <code>Increment</code> with parameter <code>amount</code> set to <code>100 - counter</code> or more.</li>
</ol>
</li>
</ol>
<p>Similarly to local storage access expressions, the expression
<code>Counter@[ContractID]::storage::counter</code> can only be used in the right-hand side of a <code>let</code>
declaration.</p>
<blockquote>
<p><strong>Note</strong>: The <code>mut</code> keyword cannot be added to external storage accesses. External storage
locations belong to the external contract that owns and it's up to the predicates in that contract
to control their mutability.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="managine-growing-projects"><a class="header" href="#managine-growing-projects">Managine Growing Projects</a></h1>
<p>As you write large programs, organizing your code will become increasingly important. By grouping
related functionality and separating code with distinct features, you’ll clarify where to find code
that implements a particular feature and where to go to change how a feature works.</p>
<p>As a project grows, you should organize code by splitting it into multiple <strong>modules</strong> and then
multiple files. You can also extract parts of a project into separate packages that become external
dependencies. This chapter covers all these techniques.</p>
<p>Pint has a number of features that allow you to manage your code’s organization, including which
details are exposed, which details are private, and what names are in each scope in your programs.
These features, sometimes collectively referred to as the module system, include:</p>
<ul>
<li><strong>Packages</strong>: A feature of the pint tool that lets you build, test, and share projects.</li>
<li><strong>Modules</strong> and <strong>use</strong>: Let you control the organization and scope of paths.</li>
<li><strong>Paths</strong>: A way of naming an item, such as a type, a macro, or a <code>const</code>.</li>
</ul>
<p>In this chapter, we’ll cover all these features, discuss how they interact, and explain how to use
them to manage scope. By the end, you should have a solid understanding of the module system.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="pint-packages"><a class="header" href="#pint-packages">Pint Packages</a></h2>
<p>The first part of the module system we’ll cover are packages.</p>
<p>A package is a bundle of one or more modules that provides a set of functionality. A package
contains a <code>pint.toml</code> file that describes how to build it.</p>
<p>Packages can come in one of two forms: a &quot;contract&quot; package and a &quot;library&quot; package. <em>Contract
packages</em> represent smart contracts that can be compiled to bytecode and deployed to a blockchain.
Each contract package must have a <code>contract.pnt</code> file in its <code>src</code> directory, which represents the
entry point of the contract. <em>Library packages</em> don't compile to bytecode. Instead, they define
functionality intended to be shared with multiple projects. The entry point of a library crate is
always a <code>lib.pnt</code> file in the <code>src</code> directory.</p>
<p>Let's walk through what happens when we create a package. First, we enter the command <code>pint new my-project</code>:</p>
<pre><code class="language-console">$ pint new my-project
     Created my-project [contract] (/path/to/my-project)
$ ls my-project
pint.toml src
$ ls my-project/src
contract.pnt
</code></pre>
<p>After we run <code>pint new</code>, we use <code>ls</code> to see what the pint tool creates. In the project directory,
there's a <code>pint.toml</code> file, giving us a package. There's also an <code>src</code> directory that contains
<code>contract.pnt</code>. Open <code>pint.toml</code> in your text editor, and note there's no mention of
<code>src/contract.pnt</code>. The pint tool follows a convention that <code>src/contract.pnt</code> is the root file of a
contract package. Likewise, <code>src/lib.pnt</code> is the root file of a library package.</p>
<p>Note that the <code>pint.toml</code> file does contain a field called <code>kind</code>, which is set to <code>contract</code> in the
example above, to indicate that this particular package is a contract. In contrast, if we were to
create a library package using <code>pint new my-library --lib</code>, then we would find that the <code>kind</code> field
in the generated <code>pint.toml</code> is set to <code>library</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="defining-modules"><a class="header" href="#defining-modules">Defining Modules</a></h2>
<p>In this section, we’ll talk about modules and other parts of the module system, namely paths that
allow you to name items and the <code>use</code> keyword that brings a path into scope.</p>
<h3 id="modules-cheat-sheet"><a class="header" href="#modules-cheat-sheet">Modules Cheat Sheet</a></h3>
<p>Here we provide a quick reference on how modules, paths, and the <code>use</code> keyword work in the compiler,
and how most developers organize their code. We’ll be going through examples of each of these rules
throughout this chapter, but this is a great place to refer to as a reminder of how modules work.</p>
<ul>
<li><strong>Start from the package root</strong>: When compiling a package, the compiler first looks for code to
compile in the package root file, which is <code> src/lib.pnt</code> for a library package or
<code>src/contract.pnt</code> for a contract package.</li>
<li><strong>Declaring modules</strong>: You can declare new modules by creating files for them in the appropriate
directories. Say you want to declare a new <code>garden</code> module. You have two options:
<ul>
<li>You can create the file <code>src/garden.pnt</code> if you want the <code>garden</code> module to be a <em>single file</em>
module. That is, if you don't want the module <code>garden</code> to have submodules.</li>
<li>You can create the file <code>src/garden/garden.pnt</code> if you want the module to be a <em>multi-file
module</em>. That is, if you want the module <code>garden</code> to have submodules. The submodules of <code>garden</code>
would then live in the <code>src/garden</code> directory.</li>
</ul>
</li>
<li><strong>Declaring submodules</strong>: In any directory other than the package root directory, you can create
new <em>submodules</em>. For example, say you want to declare a submodule of <code>garden</code> named <code>vegetables</code>.
You have two options:
<ul>
<li>You can create the file <code>src/garden/vegetables.pnt</code> if you want the <code>vegetables</code> submodule to be
a <em>single file</em> submodule. That is, if you don't want the submodule <code>vegetables</code> to have its own
submodules.</li>
<li>You can create the file <code>src/garden/vegetables/vegetables.pnt</code> if you want the <code>vegetables</code>
submodules to be a <em>multi-file submodule</em>. That is, if you want the submodule <code>vegetables</code> to
have its own submodules.</li>
</ul>
</li>
<li><strong>Paths to code in modules</strong>: Once a module is part of your package, you can refer to code in that
module from anywhere else in the same package. For example, an enum <code>Asparagus</code> in the garden
vegetables module would be found at <code>::garden::vegetables::Asparagus</code>.</li>
<li><strong>The <code>use</code> keyword</strong>: Within a Pint file, the <code>use</code> keyword creates shortcuts to items to reduce
repetition of long paths. For example, you can create a shortcut to
<code>::garden::vegetables::Asparagus</code> using the statement <code>use ::garden::vegetables::Asparagus;</code>
declared at global scope in a Pint file. From then on, you only need to write <code>Asparagus</code> to make
use of that enum in this file.</li>
</ul>
<p>Here, we create a contract package named <code>backyard</code> that illustrates these rules. The package's
directory, also named <code>backyard</code>, contains these files and directories:</p>
<pre><code class="language-console">backyard
├── pint.toml
└── src
    ├── contract.pnt
    └── garden
        ├── garden.pnt
        └── vegetables.pnt
</code></pre>
<p>The package root file is <code>src/contract.pnt</code> since this is a contract package. It contains:</p>
<pre><code class="language-pint">use garden::vegetables::Asparagus;

predicate Foo(green_asparagus: Asparagus) {
    constraint green_asparagus == Asparagus::Green;
}
</code></pre>
<p>The submodule <code>vegetables</code> which is defined in <code>src/garden/vegetables.pnt</code>, contains:</p>
<pre><code class="language-pint">union Asparagus = Green | White | Purple;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="paths-for-referring-to-an-item-in-a-module-tree"><a class="header" href="#paths-for-referring-to-an-item-in-a-module-tree">Paths for Referring to an item in a Module Tree</a></h2>
<p>To show Pint where to find an item in a module tree, we use a path in the same way we use a path
when navigating a filesystem. To use a custom type for example, we need to know its path.</p>
<p>A path can take two forms:</p>
<ul>
<li>An <strong>absolute path</strong> is the full path starting from a package root; for code from an external
package, the absolute path begins with the package name, and for code from the current package, it
starts with double colons (<code>::</code>).</li>
<li>A <strong>relative path</strong> starts from the current module and uses an identifier in the current
module.</li>
</ul>
<p>Both absolute and relative paths are followed by one or more identifiers separated by double colons
(<code>::</code>).</p>
<p>Returning to the &quot;backyard&quot; example from the previous chapter, say we want to access the enum
<code>Asparagus</code>. This is the same as asking: what's the path of the <code>Asparagus</code> enum. We'll show two
ways to access <code>Asparagus</code> from the root file:</p>
<pre><code class="language-pint">predicate Bar(
    first_asparagus: ::garden::vegetables::Asparagus,
    second_asparagus: garden::vegetables::Asparagus,
) { }
</code></pre>
<p>The first time we refer to the enum <code>Asparagus</code> we use an absolute path. The enum <code>Asparagus</code> is defined
in the same package as our root module above, which means we can use <code>::</code> to start an absolute path.
We then include each of the successive modules until we make our way to <code>Asparagus</code>.</p>
<p>The second time we refer to the enum <code>Asparagus</code>, we use a relative path. The path starts with
<code>garden</code>, the name of the module defined at the same level of the module tree as the root module.</p>
<p>Choosing whether to use a relative or absolute path is a decision you’ll make based on your project,
and depends on whether you’re more likely to move item definition code separately from or together
with the code that uses the item. For example, if we move the <code>garden</code> module to a module named
<code>estate</code>, we’d need to update the absolute path to <code>Asparagus</code>, but the relative path would still be
valid. However, if we moved the parameter <code>first_asparagus</code> into a module named <code>salad</code>, the
absolute path to <code>Asparagus</code> would stay the same, but the relative path would need to be updated.
Our preference in general is to specify absolute paths because it’s more likely we’ll want to move
code definitions and item calls independently of each other.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="bringing-paths-into-scope-with-the-use-keyword"><a class="header" href="#bringing-paths-into-scope-with-the-use-keyword">Bringing Paths into Scope with the <code>use</code> Keyword</a></h2>
<p>Having to write out the paths to access items can feel inconvenient and repetitive. In the previous
chapter, whether we chose the absolute or relative path to <code>Asparagus</code>, every time we wanted to use
<code>Asparagus</code> we had to specify the modules <code>garden</code> and <code>vegetables</code>. Fortunately, there’s a way to
simplify this process: we can create a shortcut to a path with the <code>use</code> keyword once, and then use
the shorter name everywhere else in the scope.</p>
<p>In the example below, we bring the <code>::garden::vegetables</code> module into the scope of the root file to
use the <code>Asparagus</code> enum:</p>
<pre><code class="language-pint">use ::garden::vegetables;

predicate Baz(
    third_asparagus: vegetables::Asparagus,
) { }
</code></pre>
<p>Adding <code>use</code> and a path in a scope is similar to creating a symbolic link in the filesystem. By
adding use <code>::garden::vegetables</code> in the root file, <code>vegetables</code> is now a valid name in that scope.</p>
<h3 id="handling-conflicting-imports"><a class="header" href="#handling-conflicting-imports">Handling conflicting imports</a></h3>
<p>Pint does not allow bringing two items with the same name into scope with <code>use</code>. This name clash
makes it impossible for the compiler to distinguish between the two items in the scope. There are
two ways to avoid this problem. The first, is to only import the names of the parent modules.</p>
<p>Consider the following two libraries:</p>
<pre><code class="language-pint">// Module data::contract_lib

type Data = { 
    address: b256,
    storage_vars: int,
    predicates: int,
};
</code></pre>
<pre><code class="language-pint">// Module data::predicate_lib

type Data = {
    address: b256,
    parameters: int,
};
</code></pre>
<p>Both libraries use the name <code>Data</code> to describe a types. The example below shows how to bring the two
<code>Data</code> types into scope and how to refer to them without having a conflict.</p>
<pre><code class="language-pint">use ::data::contract_lib;
use ::data::predicate_lib;

predicate test(
    contract_data: contract_lib::Data,
    predicate_data: predicate_lib::Data,
) {}
</code></pre>
<p>As you can see, using the parent module distinguishes the two <code>Data</code> types. If instead we specified
<code>use data::contract_lib::Data</code> and <code>use data::predicate_lib::Data</code>, we'd have two <code>Data</code> types in
the same scope and Pint wouldn't know which one we meant when we used <code>Data</code>.</p>
<p>There’s another solution to the problem of bringing two types of the same name into the same scope
with <code>use</code>: after the path, we can specify <code>as</code> and a new local name, or <em>alias</em>, for the type. The
example below shows another way to write the code in the previous example by renaming the two <code>Data</code>
types using <code>as</code>.</p>
<pre><code class="language-pint">use ::data::contract_lib::Data as ContractData;
use ::data::predicate_lib::Data as PredicateData;

predicate test(
    contract_data: ContractData,
    predicate_data: PredicateData,
) { }
</code></pre>
<p>In each <code>use</code> statement, we choose a new name for <code>Data</code>. That guarantees that no conflicts arise.
This also has the side benefit of giving <code>Data</code> a more meaningful name in the current context.</p>
<h3 id="using-nested-paths-to-clean-up-large-use-lists"><a class="header" href="#using-nested-paths-to-clean-up-large-use-lists">Using Nested Paths to Clean Up Large <code>use</code> Lists</a></h3>
<p>If we’re using multiple items defined in the same module, listing each item on its own line can take
up a lot of vertical space in our files. For example, these two <code>use</code> statements we had in the
previous example bring two items into scope:</p>
<pre><code class="language-pint">use ::data::contract_lib::Data as ContractData;
use ::data::predicate_lib::Data as PredicateData;
</code></pre>
<p>Instead, we can use nested paths to bring the same items into scope in one line. We do this by
specifying the common part of the path, followed by two colons, and then curly brackets around a
list of the parts of the paths that differ, as shown below.</p>
<pre><code class="language-pint">use ::data::{
    contract_lib::Data as ContractData, 
    predicate_lib::Data as PredicateData
};
</code></pre>
<p>In bigger programs, bringing many items into scope from the same module using nested paths can
reduce the number of separate <code>use</code> statements needed by a lot!</p>
<p>We can use a nested path at any level in a path, which is useful when combining two <code>use</code> statements
that share a subpath. For example, the code snippet below shows two <code>use</code> statements: one that
brings <code>data::contract_lib</code> into scope and one that brings <code>data::contract_lib::Data</code> into scope.</p>
<pre><code class="language-pint">use ::data::contract_lib;
use ::data::contract_lib::Data;
</code></pre>
<p>The common part of these two paths is <code>data::contract_lib</code>, and that’s the complete first path. To
merge these two paths into one <code>use</code> statement, we can use <code>self</code> in the nested path, as shown
below.</p>
<pre><code class="language-pint">use ::data::contract_lib::{self, Data};
</code></pre>
<p>This line brings <code>data::contract_lib</code> and <code>data::contract_lib::Data</code> into scope.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h1>
<p>By now, you’ve learned the most commonly used parts of the Pint programming language. We will look
at a few aspects of the language you might run into every once in a while, but may not use every
day. The features covered here are useful in very specific situations. Although you might not reach
for them often, we want to make sure you have a grasp of all the features Pint has to offer.</p>
<p>In this chapter, we'll cover:</p>
<ul>
<li><strong>Invoking Predicates</strong>: how to invoke external local and external predicates.</li>
<li><strong>Macros</strong>: how to write reusable code using macros.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="invoking-predicates"><a class="header" href="#invoking-predicates">Invoking Predicates</a></h2>
<p>If you've worked with imperative smart contract languages like <a href="https://soliditylang.org/">Solidity</a>
in the past, you know that interactions between smart contracts are essential for many applications.
One way to do this is by <em>calling</em> one contract from another contract. Pint has a similar concept
where one predicate can <em>invoke</em> another predicate with some arguments. We use the word &quot;invoke&quot;
here instead of &quot;call&quot; because, unlike imperative languages, predicates in Pint are not called in
the traditional sense since that would imply the existence of a control flow (a &quot;call&quot; followed by a
&quot;return&quot;). Instead, in Pint, predicate <code>A</code> can invoke predicate <code>B</code> with some arguments to indicate
that <strong><code>B</code> has to be present in the solution with this particular set of arguments, if <code>A</code> is also
present in the solution</strong>. If this sounds confusing, don't worry. It will all be clear by the end of
this chapter.</p>
<p>We cover two types of predicate invocations:</p>
<ol>
<li>External predicate invocation.</li>
<li>Sibling predicate invocation.</li>
</ol>
<h3 id="invoking-external-predicates"><a class="header" href="#invoking-external-predicates">Invoking External Predicates</a></h3>
<p>Similar to accessing external storage, a predicate in an external contract can be invoked through an
<code>interface</code> declaration corresponding to the external contract. When invoking the external
predicate, the following are needed:</p>
<ol>
<li>The address of the external contract.</li>
<li>The address of the predicate we want to access in that contract.</li>
<li>A list of arguments.</li>
</ol>
<p>Consider the following external smart contract that we would like interact with:</p>
<pre><code class="language-pint">predicate foo(
    x: int,
    y: bool,
    t: { int, bool },
) {
    // predicate logic
}

// other predicates
</code></pre>
<p>To interact with this contract, we first need to generate its interface:</p>
<pre><code class="language-pint">interface MyInterface {
    predicate foo(
        x: int,
        y: bool,
        t: { int, bool },
    );

    // other predicates
}
</code></pre>
<p>Now, we can invoke predicate <code>foo</code> as follows:</p>
<pre><code class="language-pint">const CONTRACT_ADDR = 0xEB87FCE275A9AB10996D212F39221A56B90E01C37FA9D16EE04A3FE8E17DEED9;
const FOO_ADDR = 0xBA6595C5C75346E6C82BED0CE770D0758ADD1712163FCE45E38E5E8EAC6AA153;

predicate bar(
    a: int,
    b: bool,
) {
    let tuple = { 42, b };
    constraint MyInterface@[CONTRACT_ADDR]::foo@[FOO_ADDR](a, true, tuple);
}
</code></pre>
<p>The predicate invocation expression has three parts separated by <code>::</code>:</p>
<ol>
<li>The name of the interface <code>MyInterface</code> followed by the address of the corresponding deployed
contract in between <code>@[..]</code>. This is quite similar to what we had to do to access external
storage variables.</li>
<li>The name of the predicate <code>foo</code> followed by the address of the corresponding predicate in the
deployed contract.</li>
<li>A list of arguments that must match the list parameters of <code>foo</code> in the <code>interface</code>.</li>
</ol>
<p>In the above, the constraint:</p>
<pre><code class="language-pint">    constraint MyInterface@[CONTRACT_ADDR]::foo@[FOO_ADDR](a, true, tuple);
</code></pre>
<p>can be interpreted as follows: any solution that solves predicate <code>bar</code> must also contain a solution
for predicate <code>foo</code> such that:</p>
<ol>
<li>The address of <code>foo</code> is <code>FOO_ADDR</code>.</li>
<li>The address of the contract that contains <code>foo</code> is <code>CONTRACT_ADDR</code>.</li>
<li>The arguments provided for <code>foo</code> in the solution are equal to <code>a</code>, <code>true</code>, and <code>tuple</code>
respectively.</li>
</ol>
<p>Of course, for <code>foo</code> to be actually satisfied, the containing contract must exist and be deployed,
the addresses must be correct, and the arguments must match (in number and types) what the deployed
bytecode of <code>foo</code> actually expects.</p>
<h3 id="invoking-sibling-predicates"><a class="header" href="#invoking-sibling-predicates">Invoking Sibling Predicates</a></h3>
<p>A special case for invoking predicates is when the invoked predicate is in the same contract as the
predicate that is invoking it. There is no conceptual difference between this special case and the
generalized case above expect that, because we are working in the same contract, there is no need to
declare an interface for the contract. There is also no need to specify the address of the invoked
predicate because the compiler can figure that out on its own! Here's an example:</p>
<pre><code class="language-pint">predicate A(
    a: { bool, int },
    b: bool,
    c: int[3], 
) {
    // predicate logic
}

predicate B() {
    constraint A@[]( { true, 42 }, false, [1, 2, 3]);
}
</code></pre>
<p>Here, predicate <code>B</code> invokes <em>sibling</em> predicate <code>A</code> by using its path (just <code>A</code>) and empty square
brackets <code>@[]</code> to indicate that the address is to be computed by the compiler. The constraint
<code>constraint A@[](..)</code> should be interpreted exactly as in the case of external predicate
invocation: any solution that solves <code>B</code> should also contain a solution for <code>A</code> with the provided
listed arguments.</p>
<p>One important caveat of the above is that you are not allowed to have <em>cyclical dependencies</em>
between predicates. For example:</p>
<pre><code class="language-pint">predicate A(x: int) {
    constraint B@[](0);
}

predicate B(y: int) {
    constraint A@[](0);
}
</code></pre>
<p>Here, predicate <code>A</code> invokes predicate <code>B</code> and predicate <code>B</code> invokes predicate <code>A</code>. This causes a
cycle where the address of a predicate cannot be determined and used by the other. The compiler will
emit the following error to prevent you from proceeding:</p>
<pre><code class="language-console">Error: dependency cycle detected between predicates
   ╭─[invoking_predicates_3.pnt:1:1]
   │
 1 │ predicate A(x: int) {
   │ ─────┬─────
   │      ╰─────── this predicate is on the dependency cycle
   │
 7 │ predicate B(y: int) {
   │ ─────┬─────
   │      ╰─────── this predicate is on the dependency cycle
   │
   │ Note: dependency between predicates is typically created via predicate instances
───╯
</code></pre>
<p>Another caveat is that a predicate cannot reference itself:</p>
<pre><code class="language-pint">predicate C(x: int) {
    constraint C@[](x);
}
</code></pre>
<p>The compiler will complain as follows:</p>
<pre><code class="language-console">Error: self referential predicate `::C`
   ╭─[invoking_predicates_4.pnt:2:16]
   │
 2 │     constraint C@[](x);
   │                ───┬───
   │                   ╰───── this predicate call references the predicate it's declared in
───╯
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>Macros are a way of writing code that writes other code, which is known as <em>metaprogramming</em>.
Metaprogramming is useful for reducing the amount of code you have to write and maintain. Most
programming languages have &quot;functions&quot; which somewhat serve a similar purpose. Macros, however, are
a lot more powerful. While Pint does not have &quot;functions&quot;, its macro system is powerful enough to
cover their use case.</p>
<p>Macro <em>expansion</em> is the very first operation performed by the compiler. This property implies that
macros can contain <em>anything</em> as long as the code they produce is parsable, i.e. does not violate
the <em>grammar</em> of Pint. Later stages of the compiler will then validate the semantics of the expanded
code.</p>
<p>Macros in Pint have two main forms:</p>
<ul>
<li><strong>Simple Macros</strong>: these are macros that accept a fixed number of parameters and do not support
recursion.</li>
<li><strong>Variadic Macros</strong>: these are macros that accept a variable number of parameters and can support
recursion.</li>
</ul>
<h3 id="simple-macros"><a class="header" href="#simple-macros">Simple Macros</a></h3>
<p>Simple macros take a fixed number of parameters, each starting with <code>$</code>. Consider the following
simple macro:</p>
<pre><code class="language-pint">macro @in_range($v, $num) {
    constraint $v &gt;= $num;
    constraint $v &lt; ($num * $num);
}
</code></pre>
<p>Macro definitions always start with the keyword <code>macro</code> followed by the name of the macro, which
must start with <code>@</code>. Then, a list of named parameters is provided in between parentheses. The body
of the macro is provided in between curly braces and can contain any code that uses the macro
parameters.</p>
<p>The macro above is named <code>@in_range</code> and takes 2 parameters named <code>$v</code> and <code>$num</code>. In the body of
this macro, these parameters are used as expressions but this is not always necessarily the case!
When this macro is used, two constraints are always produced. Let's use this macro as follows:</p>
<pre><code class="language-pint">let x = 42;
@in_range(x; 10);
</code></pre>
<p>To call the macro, we write its name followed by a list of arguments, separated by a semicolon
(<code>;</code>), in between parentheses. The number of arguments must match the number of parameters that the
macro expects.</p>
<blockquote>
<p><strong>Note</strong>: yes, the arguments are separated by a semicolon (<code>;</code>) and not a comma (<code>,</code>).</p>
</blockquote>
<p>After the macro gets expanded, the compiler will produce code that is equivalent to the following:</p>
<pre><code class="language-pint">let x = 42;
constraint x &gt;= 10;
constraint x &lt; (10 * 10);
</code></pre>
<p>It should hopefully be quite clear to you how this substitution happened. The compiler simply
rewrote the body of the macro by replacing <code>$v</code> with <code>x</code> and <code>$num</code> with <code>10</code>. The resulting code is
then <em>pasted</em> exactly where the macro was called.</p>
<h4 id="arbitrary-tokens-as-macro-arguments"><a class="header" href="#arbitrary-tokens-as-macro-arguments">Arbitrary Tokens as Macro Arguments</a></h4>
<p>The arguments to a macro call may be collections of tokens which do not necessarily parse to a
proper expression, as in the previous example. For example, an operator like <code>+</code> or a type name such
as <code>int</code> are valid!. If the token is an identifier, then it may be used as a name, such as the name
of a decision variable or a new type. Here's an example:</p>
<pre><code class="language-pint">macro @do_decls($a, $a_expr, $b, $b_expr, $ty, $op) {
    let $a: $ty = $a_expr;
    let $b: $ty = $b_expr;
    constraint $b $op $a;
}
</code></pre>
<p>The author of this macro likely expects:</p>
<ul>
<li><code>$a</code> and <code>$b</code> to be identifiers.</li>
<li><code>$a_expr</code> and <code>$b_expr</code> to be expressions.</li>
<li><code>$ty</code> to be a type.</li>
<li><code>$op</code> to be a binary operator such as <code>+</code>, <code>-</code>, etc.</li>
</ul>
<p>In fact, if the rules above are not respected when calling the macro, the program will likely fail
to parse correctly resulting in a failed compilation.</p>
<p>If we call the macro above with:</p>
<pre><code class="language-pint">@do_decls(x1; 42; x2; 69; int; &gt;);
</code></pre>
<p>the compiler will expand the macro call to:</p>
<pre><code class="language-pint">let x1: int = 42;
let x2: int = 69;
constraint x2 &gt; x1;
</code></pre>
<p>Hopefully this gives you an idea of how powerful macros can be.</p>
<h4 id="macro-expressions"><a class="header" href="#macro-expressions">Macro Expressions</a></h4>
<p>So far, we've only looked at example macros where the body is a list of declarations (such as <code>let</code>
declarations or constraints). Macros are even more versatile than that! Macros can, in fact, produce
an expression. This would be akin to functions that return values in other programming languages.</p>
<p>The expression that you want produced by the macro must always be the last statement in the macro
body. For example:</p>
<pre><code class="language-pint">macro @quotion($a, $b) {
    constraint $b &gt; 0;  // Declaration.
    $a / $b             // Final expression.
}
</code></pre>
<p>Because this macro produces an expression, a call to it can be used as an expression as well. For
example:</p>
<pre><code class="language-pint">let e: int = 4;
let f: int = 2;
let q: int = @quotion(e; f);
</code></pre>
<p>As a result, the compiler will expand the macro call to:</p>
<pre><code class="language-pint">let e: int = 4;
let f: int = 2;
constraint f &gt; 0;
let q: int = e / f;
</code></pre>
<p>Note that the expression is always inserted at the exact location where the macro was called, but
any declaration items in the macro body are inserted <em>right before</em> the call.</p>
<h4 id="declaring-variables-in-macro-bodies"><a class="header" href="#declaring-variables-in-macro-bodies">Declaring Variables in Macro Bodies</a></h4>
<p>Earlier, we looked at an example macro that uses some of its parameters as identifiers to declare
some local variables. When that macro is called multiple times with different arguments, the
resulting variable declarations will not cause any name conflicts. Now, what happens if, instead, we
were to directly use an identifier in a macro body when declaring new variables? Here's an example:</p>
<pre><code class="language-pint">macro @is_even($a) {
    let half: int = $a / 2;
    constraint $a == half * 2 || $a == half * 2 + 1;
}
</code></pre>
<p>In a naive macro system, if <code>@is_even</code> was called more than once within the same module, then after
expansion there would be multiple <code>half</code> variable declarations, resulting a name clash error.</p>
<p>To avoid this problem Pint's macro expansion aims to be <strong>hygienic</strong> and places newly declared
symbols into a unique anonymous namespace. Note that this is only done for symbols which are <strong>not</strong>
macro parameters. To illustrate this, consider the following:</p>
<pre><code class="language-pint">macro @let_decls($a) {
    let foo: int = 42;     // Hygienic anonymous binding for `foo`.
    let $a: bool = true;   // Lexical binding for `$a`.
}
</code></pre>
<p>If we call the macro above using <code>@let_decls(foo)</code> there would not be an error as the expansion
would be equivalent to:</p>
<pre><code class="language-pint">let anon@0::foo: int = 42;
let foo: bool = true;
</code></pre>
<p>And even when called multiple times with different arguments there would be no error:</p>
<pre><code class="language-pint">@let_decls(foo);
@let_decls(bar);
</code></pre>
<p>Becomes equivalent to:</p>
<pre><code class="language-pint">let anon@0::foo: int = 42;
let foo: bool = true;
let anon@1::foo: int = 42;
let bar: bool = true;
</code></pre>
<p>Of course, if <code>@let_decls</code> was called with the argument <code>foo</code> multiple times there would be an
error!</p>
<h3 id="recursion-and-variadic-macros"><a class="header" href="#recursion-and-variadic-macros">Recursion and Variadic Macros</a></h3>
<p>The second type of macros we will look at is &quot;Variadic Macros&quot;. Variadic macros allow a special type
of recursion via <em>variadic parameters</em>. Such special parameters allow macros to call themselves,
essentially entering an <em>expansion loop</em>. Think of this as <strong>recursive code generation</strong>.</p>
<p>The term &quot;variadic&quot; means that the macro accepts a variable number of parameters. In the parameter
list of the macro definition this is indicated using a special parameter whose name starts with an
<code>&amp;</code>. Recursion may be performed via one or more recursing macros and at least one non-recursing, or
<em>terminating</em> macros. The recursing macros call other versions of itself but with a different number
of - usually fewer - arguments. The terminating macros do not call another version of itself. This
is best explained with an example, so let's consider the following macro which implements a sum
operation over an arbitrary number of named variables:</p>
<pre><code class="language-pint">// Recursive Macro
macro @sum($x, $y, &amp;rest) {
    // Called only when `&amp;rest` is not empty.  
    // We recurse by adding `$x` and `$y` and using `&amp;rest` as the second argument.
    @sum($x + $y; &amp;rest)
}

// Terminating Macro
macro @sum($x, $y) {
    // Called only when the number of arguments is exactly 2.
    $x + $y
}
</code></pre>
<p>We have two versions of the <code>@sum</code> macro. Despite the apparent name clash, this is actually okay
because the two macros accept a different number of parameters. The first version of <code>@sum</code> accepts
<code>$x</code>, <code>$y</code>, and <code>&amp;rest</code> while the second version accepts only <code>$x</code> and <code>$y</code>. The parameter <code>&amp;rest</code>
is special and is referred to as a &quot;parameter pack&quot;. The parameter pack is never empty, therefore in
order to call the first version of <code>@sum</code>, we must pass 3 or more arguments.</p>
<blockquote>
<p><strong>Note</strong>: The parameter pack is not addressable in any way. It may only be used as an argument to
another macro call.</p>
</blockquote>
<p>Now let's walk through how the compiler would expand a call to <code>@sum</code>. You will notice that the
compiler will always try to match the number of arguments provided to the number of parameters in
each macro, and the best match will be selected.</p>
<p>Calling <code>@sum(a; b)</code> will expand directly using the terminating macro to the expression <code>a + b</code>.</p>
<p>Calling <code>@sum(a; b; c; d)</code> will expand as follows:</p>
<ul>
<li><code>@sum(a; b; c; d)</code> calls the recursive macro as <code>@sum(a; b; [c, d])</code> where <code>[c, d]</code> is <code>&amp;rest</code>.</li>
<li><code>@sum(a; b; [c, d])</code> expands to <code>@sum(a + b; c; d)</code>.</li>
<li><code>@sum(a + b; c; d)</code> calls the recursive macro again, as <code>@sum(a + b; c; [d])</code>.</li>
<li><code>@sum(a + b; c; [d])</code> expands to <code>@sum(a + b + c; d)</code>.</li>
<li><code>@sum(a + b + c; d)</code> calls the terminating macro.</li>
<li><code>@sum(a + b + c; d)</code> expands to <code>a + b + c + d</code>, which is the final expanded form of the macro
call.</li>
</ul>
<p>Note that, since the <code>&amp;rest</code> parameter pack is passed in its expanded form, the above <code>@sum</code> macros
could instead be rewritten as follows, to the same effect:</p>
<pre><code class="language-pint">// Recursive Macro
macro @sum_v2($x, &amp;rest) {
    @sum_v2($x + &amp;rest)
}

// Terminating Macro
macro @sum_v2($x) {
    $x
}
</code></pre>
<p>Parameter packs can also be used by non-recursive macros which wish to call other recursive macros.
A more interesting use of variadic macros might be to chain array accesses together in relative
constraints:</p>
<pre><code class="language-pint">macro @chain($a, $index, &amp;rest) {
    // Add the first link in the chain, then move to the rest.
    @chain_next($a; $index; &amp;rest)
}

macro @chain_next($a, $prev, $next, &amp;rest) {
    // Add the next link:
    // constrain based on the previous link and continue.
    constraint $a[$next] &gt; $a[$prev] + 10;
    @chain_next($a; $next; &amp;rest)
}

macro @chain_next($a, $prev, $last) {
    // Just expand to the final link.
    constraint $a[$last] &gt; $a[$prev] + 10;
    $a[$last]
}
</code></pre>
<p>When called as:</p>
<pre><code class="language-pint">predicate chain(array: int[4]) {
    let r = @chain(array; 0; 1; 2; 3);
}
</code></pre>
<p>The following code would be produced:</p>
<pre><code class="language-pint">predicate chain(
    array: int[4],
) {
    let r = array[3];
    constraint (array[1] &gt; (array[0] + 10));
    constraint (array[2] &gt; (array[1] + 10));
    constraint (array[3] &gt; (array[2] + 10));
}
</code></pre>
<h4 id="array-argument-splicing"><a class="header" href="#array-argument-splicing">Array Argument Splicing</a></h4>
<p>An extension to macro argument packing is the concept of <em>array splicing</em>. Array splicing allows
passing the elements of an array variable, in place, as the arguments to a macro call. This is done
by prefixing the array name with a tilde <code>~</code>.</p>
<p>Say we want to find the sum of the elements of some array of integers. If we were to use the
variadic macro <code>@sum</code> from earlier, we would have to write something like:</p>
<pre><code class="language-pint">let sum_of_array = @sum(array[0]; array[1]; array[2]; array[3]);
</code></pre>
<p>The issue with the above is that it's quite verbose, especially when the array size is large.
Instead, array splicing allows us to write this instead:</p>
<pre><code class="language-pint">let sum_of_array_v2 = @sum(~array);
</code></pre>
<p>The compiler will then split <code>array</code> into its individual elements and pass them as separate
arguments to <code>@sum</code>, so that the resulting expansion is</p>
<pre><code class="language-pint">let sum_of_array_v2 = @sum(array[0]; array[1]; array[2]; array[3]);
</code></pre>
<p>Array splicing is usually only useful with variadic macros which can handle arrays of different
sizes, though a non-variadic macro may be called with array splicing if the array size exactly
matches the number of required arguments.</p>
<p>An important property of array splicing is that the array element accesses are expanded in place and
the argument separators are only placed between them and not at their ends! The following:</p>
<pre><code class="language-pint">@foo(~two + ~two + ~two);
</code></pre>
<p>expands to:</p>
<pre><code class="language-pint">@foo(two[0]; two[1] + two[0]; two[1] + two[0]; two[1]);
</code></pre>
<p>This may be a bit surprising at first, but what is really happening here is that each <code>~two</code> gets
replaced <em>verbatim</em> with <code>two[0]; two[1]</code> and the <code>+</code> signs stay exact where they were. So, the
three spliced arrays make up a total of 4 separate arguments in this specific case.</p>
<p>Similarly,</p>
<pre><code class="language-pint">constraint @sum(100 + ~nums * 200) &lt; 1000;
</code></pre>
<p>expands to:</p>
<pre><code class="language-pint">constraint @sum(100 + nums[0]; nums[1]; nums[2] * 200) &lt; 1000;
</code></pre>
<p>The arithmetic add and multiply are applied to the first and last elements of the array in this
example.</p>
<h4 id="debugging-macros"><a class="header" href="#debugging-macros">Debugging Macros</a></h4>
<p>The easiest way to debug macros is to inspect the code they expand to and compare the result to your
expectations. The way to do this is using flag <code>--print-parsed</code> as follows:</p>
<pre><code class="language-console">pint build --print-parsed
</code></pre>
<p>For example, consider the following contract:</p>
<pre><code class="language-pint">macro @in_range($v, $num) {
    constraint $v &gt;= $num;
    constraint $v &lt; ($num * $num);
}

macro @sum($x, $y, &amp;rest) {
    // Called only when `&amp;rest` is not empty.  
    // We recurse by adding `$x` and `$y` and using `&amp;rest` as the second argument.
    @sum($x + $y; &amp;rest)
}

macro @sum($x, $y) {
    // Called only when the number of arguments is exactly 2.
    $x + $y
}

macro @chain($a, $index, &amp;rest) {
    // Add the first link in the chain, then move to the rest.
    @chain_next($a; $index; &amp;rest)
}

macro @chain_next($a, $prev, $next, &amp;rest) {
    // Add the next link:
    // constrain based on the previous link and continue.
    constraint $a[$next] &gt; $a[$prev] + 10;
    @chain_next($a; $next; &amp;rest)
}

macro @chain_next($a, $prev, $last) {
    // Just expand to the final link.
    constraint $a[$last] &gt; $a[$prev] + 10;
    $a[$last]
}

predicate test4(x: int, array: int[4]) {
    @in_range(x; 10);
    let sum_of_array = @sum(array[0]; array[1]; array[2]; array[3]);
    let r = @chain(array; 0; 1; 2; 3);
}
</code></pre>
<p>Building this contract with the flag <code>--print-parsed</code> results in the following:</p>
<pre><code class="language-console">$ pint build --print-parsed
   Compiling to_debug [contract] (/path/to/to_debug)
   Printing parsed to_debug [contract] (/path/to/to_debug)


predicate ::test4(
    ::x: int,
    ::array: int[4],
) {
    let ::sum_of_array = (((::array[0] + ::array[1]) + ::array[2]) + ::array[3]);
    let ::r = ::array[3];
    constraint (::x &gt;= 10);
    constraint (::x &lt; (10 * 10));
    constraint (::array[1] &gt; (::array[0] + 10));
    constraint (::array[2] &gt; (::array[1] + 10));
    constraint (::array[3] &gt; (::array[2] + 10));
}

    Finished build [debug] in 8.914417ms
    contract to_debug        2C7EF76D670086B5A3FA185490A8C596043319A1AA8AC496B9DCF0043B8101F5
         └── to_debug::test4 2E4456C7268C180898A0CE5C4C3F0445D613AD79A0E6E73CF8319F8B2C3EFB3B
</code></pre>
<p>which has no macro calls left! The compiler has already expanded all the macro calls and inlined the
resulting code in the appropriate locations.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="pint-reference"><a class="header" href="#pint-reference">Pint Reference</a></h1>
<p>Reference docs for the <code>pint</code> command line tool.</p>
<ul>
<li>The <a href="pint-reference/./cli.html">Command Reference</a> shows the available commands.</li>
<li>The <a href="pint-reference/./manifest.html">Manifest Reference</a> provides a description of all manifest fields.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>The following inlines the <code>--help</code> output for each command so that you can get
an idea of what <code>pint</code> is capable of prior to downloading the tool and running
it yourself.</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Short Description</th></tr></thead><tbody>
<tr><td><a href="pint-reference/cli.html#pint-build"><code>pint build</code></a></td><td>Build a package.</td></tr>
<tr><td><a href="pint-reference/cli.html#pint-new"><code>pint new</code></a></td><td>Create a new package.</td></tr>
<tr><td><a href="pint-reference/cli.html#pint-plugins"><code>pint plugins</code></a></td><td>List all pint plugins on path.</td></tr>
</tbody></table>
</div>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<pre><code class="language-console">$ pint --help
Pint's package manager and CLI plugin host

Usage: pint &lt;COMMAND&gt;

Commands:
  build    Build a package, writing the generated artifacts to `out/`
  new      Create a new package
  plugins  Print all pint plugins found in `PATH`
  help     Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version
</code></pre>
<h2 id="pint-build"><a class="header" href="#pint-build"><code>pint build</code></a></h2>
<pre><code class="language-console">$ pint build --help
Build a package, writing the generated artifacts to `out/`

Usage: pint build [OPTIONS]

Options:
      --manifest-path &lt;MANIFEST_PATH&gt;
          The path to the package manifest.

          If not provided, the current directory is checked and then each parent recursively until a manifest is found.

      --salt &lt;SALT&gt;
          A 256-bit unsigned integer in hexadeciaml format that represents the contract &quot;salt&quot;. The value is left padded with zeros if it has less than 64 hexadecimal digits.

          The &quot;salt&quot; is hashed along with the contract's bytecode in order to make the address of the contract unique.

          If &quot;salt&quot; is provided for a library package, an error is emitted.

      --print-parsed
          Print the parsed package

      --print-flat
          Print the flattened package

      --print-optimized
          Print the optimized package

      --print-asm
          Print the assembly generated for the package

      --silent
          Don't print anything that wasn't explicitly requested

  -h, --help
          Print help (see a summary with '-h')
</code></pre>
<h2 id="pint-new"><a class="header" href="#pint-new"><code>pint new</code></a></h2>
<pre><code class="language-console">$ pint new --help
Create a new package

Usage: pint new [OPTIONS] &lt;PATH&gt;

Arguments:
  &lt;PATH&gt;
          The directory path in which the package should be created

Options:
      --contract
          Specify the &quot;contract&quot; package kind.

          This is the default behaviour.

      --lib
          Specify the &quot;library&quot; package kind.

          By default, new packages are created with the &quot;contract&quot; kind.

      --name &lt;NAME&gt;
          Optionally provide a name.

          By default, the package name is the last directory in the canonicalized representation of the given path.

  -h, --help
          Print help (see a summary with '-h')
</code></pre>
<h2 id="pint-plugins"><a class="header" href="#pint-plugins"><code>pint plugins</code></a></h2>
<pre><code class="language-console">$ pint plugins --help
Print all pint plugins found in `PATH`

Usage: pint plugins

Options:
  -h, --help  Print help
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="manifest"><a class="header" href="#manifest">Manifest</a></h1>
<p>The <code>pint.toml</code> manifest provides a high-level description of a package and its
dependencies. All projects built with the <code>pint</code> tool must have a <code>pint.toml</code>
manifest file.</p>
<p>The following provides a description of each of the tables and fields within
the manifest.</p>
<h2 id="package"><a class="header" href="#package"><code>[package]</code></a></h2>
<p>The package table declares high-level information about the pint package. It includes the following entries:</p>
<h3 id="name"><a class="header" href="#name"><code>name</code></a></h3>
<p>The name of the package.</p>
<pre><code class="language-toml">name = &quot;foo&quot;
</code></pre>
<h3 id="license"><a class="header" href="#license"><code>license</code></a></h3>
<p>Optionally specify the license for the package.</p>
<pre><code class="language-toml">license = &quot;MIT&quot;
</code></pre>
<h3 id="kind"><a class="header" href="#kind"><code>kind</code></a></h3>
<p>Describes whether the package is a <code>&quot;contract&quot;</code> (the default) or a <code>&quot;library&quot;</code>.</p>
<ul>
<li><strong>library</strong> packages allow for sharing types, macros and constants between
multiple different packages.</li>
<li><strong>contract</strong> packages describe a top-level contract that may be deployed.</li>
</ul>
<pre><code class="language-toml">kind = &quot;contract&quot;
</code></pre>
<h3 id="entry-point"><a class="header" href="#entry-point"><code>entry-point</code></a></h3>
<p>Optionally specify the path to the entry-point module for the package relative
to the <code>src/</code> directory.</p>
<p>By default this is:</p>
<ul>
<li><code>&quot;contract.pnt&quot;</code> for contracts and</li>
<li><code>&quot;library.pnt&quot;</code> for libraries.</li>
</ul>
<pre><code class="language-toml">entry-point = &quot;path/to/my/contract.pnt&quot;
</code></pre>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1"><code>[dependencies]</code></a></h2>
<p>Describes the list of external library packages that the package depends on.</p>
<p>Library packages allow for sharing types, macros and constants between
multiple different packages.</p>
<p>Dependencies are declared as follows:</p>
<pre><code class="language-toml">[dependencies]
&lt;dependency-name-1&gt; = { &lt;source-type&gt; = &quot;&lt;source-value&gt;&quot; }
&lt;dependency-name-2&gt; = { &lt;source-type&gt; = &quot;&lt;source-value&gt;&quot; }
# etc
</code></pre>
<p>For example:</p>
<pre><code class="language-toml">[dependencies]
bar = { path = &quot;path/to/bar&quot; }
</code></pre>
<h3 id="source-types"><a class="header" href="#source-types">Source types</a></h3>
<p>Currently only <code>path</code> dependencies are supported, though we plan to support more
source types in the future (e.g. <code>git</code>).</p>
<h3 id="package-field"><a class="header" href="#package-field"><code>package</code> field</a></h3>
<p>By default, the dependency name is assumed to match the name of the package that
we're depending on.</p>
<p>In some cases we may want to give a dependency a name that differs from its
package name (i.e. if multiple packages have the same name).</p>
<p>We can do this using the <code>package</code> field. In the following, we depend on a
package named <code>barney</code>, but give it the dependency name <code>bar</code>:</p>
<pre><code class="language-toml">[dependencies]
bar = { path = &quot;../path/to/bar&quot;, package = &quot;barney&quot; }
</code></pre>
<h2 id="contract-dependencies"><a class="header" href="#contract-dependencies"><code>[contract-dependencies]</code></a></h2>
<p>Describes the list of external contract packages that the package depends on.</p>
<p>These are similar to <code>[dependencies]</code>, however rather than providing a
module of items like library dependencies do, contract dependencies only provide
the contract's address, along with the address of each of its predicates. E.g.</p>
<pre><code class="language-toml">[contract-dependencies]
baz = { path = &quot;path/to/baz&quot; }
</code></pre>
<p>Now in our package, we can refer to baz's content address with the
<code>baz::ADDRESS</code> constant. Similarly, if <code>baz</code> has a predicate called <code>Foo</code>, we
can access <code>Foo</code>'s predicate address with <code>baz::Foo::ADDRESS</code>.</p>
<h2 id="full-example"><a class="header" href="#full-example">Full Example</a></h2>
<p>The following is an example of a Pint package manifest:</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
license = &quot;MIT&quot;
kind = &quot;contract&quot;
entry-point = &quot;path/to/my/contract.pnt&quot;

[dependencies]
bar = { path = &quot;../relative/path/to/bar&quot;, package = &quot;barney&quot; }

[contract-dependencies]
baz = { path = &quot;/absolute/path/to/baz&quot; }
</code></pre>
<h2 id="developer-notes"><a class="header" href="#developer-notes">Developer Notes</a></h2>
<p>The <code>pint.toml</code> manifest is implemented in the <code>pint-manifest</code> crate within the
<code>pint</code> repostiory. Rust developers looking to build <code>pint</code>-package aware tools
or plugins downstream might find this library useful.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<p>The following sections contain reference material you may find useful in your Pint journey.
Specifically, we will cover the following:</p>
<ul>
<li><strong>Keywords</strong>: A list of all the <em>keywords</em> in Pint, which are reserved and cannot be used as names
of macros, variables, etc.</li>
<li><strong>Compiler Intrinsics</strong>: A list of all available builtin intrinsics in Pint, which can be used to
perform low level operations.</li>
<li><strong>Application Binary Interface (ABI) Spec</strong>: A specification of the <em>JSON ABI</em>, which is a
condensed representation of a smart contract that only exposes its data.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="appendix-a-keywords"><a class="header" href="#appendix-a-keywords">Appendix A: Keywords</a></h2>
<p>The following list contains keywords that are reserved for current use by the Pint language. As
such, they cannot be used as identifiers. Identifiers are names of macros, variables, tuple fields,
modules, or types.</p>
<ul>
<li><code>as</code> - perform primitive casting or rename items in <code>use</code> statements</li>
<li><code>bool</code> - the Boolean type</li>
<li><code>b256</code> - the 256-bit hash type</li>
<li><code>cond</code> - select between multiple expressions based on some conditions</li>
<li><code>const</code> -</li>
<li><code>constraint</code> - define a Boolean constraint that a proposed solution must satisfy</li>
<li><code>else</code> - fallback for <code>if</code> and <code>cond</code> conditionals</li>
<li><code>enum</code> - define an enumeration</li>
<li><code>exists</code> - existential quantification: checks whether a statements is <code>true</code> for at least one
element in a domain.</li>
<li><code>false</code> -</li>
<li><code>forall</code> - universal quantification: checks whether a statement is <code>true</code> for all elements in a
domain</li>
<li><code>if</code> - branch based on the result of a conditional expression</li>
<li><code>in</code> - checks if an element belongs to a range or to an array</li>
<li><code>int</code> - basic integer type</li>
<li><code>interface</code> - declare an external interface</li>
<li><code>let</code> - declare a local variable</li>
<li><code>macro</code> - define a macro</li>
<li><code>match</code> - match a value to patterns</li>
<li><code>mut</code> - allows a storage location to be mutable</li>
<li><code>nil</code> - an <em>empty</em> storage value</li>
<li><code>predicate</code> - define a predicate</li>
<li><code>self</code> - used in <code>use</code> statements</li>
<li><code>storage</code> - declare a storage block</li>
<li><code>true</code> -</li>
<li><code>type</code> - define a new type</li>
<li><code>union</code> - declare a new union</li>
<li><code>use</code> - bring symbols into scope</li>
<li><code>where</code> - denote clauses that constraint generator indices</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="appendix-b-compiler-intrinsics"><a class="header" href="#appendix-b-compiler-intrinsics">Appendix B: Compiler Intrinsics</a></h2>
<p>The Pint compiler supports a list of intrinsics that perform various low level operations that are
mostly useful for building libraries. Intrinsics are generally target-specific. They give library
authors access to VM-specific instructions while preserving type safety. Below is a list of all
available compiler intrinsics for the Essential VM:</p>
<hr />
<pre><code class="language-pint">__address_of(name: string) -&gt; b256
</code></pre>
<p><strong>Description:</strong> Returns the content hash of predicate named <code>name</code> in the same contract. The name
must be the full absolute path to the predicate, such as <code>::Foo</code>, and cannot be the name of the
predicate it's used in.</p>
<hr />
<pre><code class="language-pint">__recover_secp256k1(data_hash: b256, sig: { b256, b256, int }) -&gt; { b256, int }
</code></pre>
<p><strong>Description:</strong> Recover the public key from a secp256k1 signature.</p>
<hr />
<pre><code class="language-pint">__sha256(data: _) -&gt; b256
</code></pre>
<p><strong>Description:</strong> Returns a SHA 256 hash from the specified data.</p>
<hr />
<pre><code class="language-pint">__size_of(data: _) -&gt; int
</code></pre>
<p><strong>Description:</strong> Returns the size, in words, of an expression. This is often the same as the size of
the type of the expression (e.g. 1 word for <code>int</code>, 4 words for <code>b256</code>, 3 words for <code>{int, int, bool}</code>, and so on). However, it can also be different, namely for expressions that can be <code>nil</code> such
as storage accesses and paths to local variables.</p>
<hr />
<pre><code class="language-pint">__this_address() -&gt; b256
</code></pre>
<p><strong>Description:</strong> Returns the content hash of this predicate.</p>
<hr />
<pre><code class="language-pint">__this_contract_address() -&gt; b256
</code></pre>
<p><strong>Description:</strong> Returns the content hash of the contract that this predicate belongs to.</p>
<!---
Uncomment when we officially support storage vectors

```pint
__vec_len(vec: _[]) -> int
```

**Description:** Returns the length of a storage vector.
-->
<hr />
<pre><code class="language-pint">__verify_ed25519(data: _, sig: { b256, b256 }, pub_key: b256) -&gt; bool
</code></pre>
<p><strong>Description:</strong> Validate an Ed25519 signature against a public key.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="appendix-c-application-binary-interface-abi"><a class="header" href="#appendix-c-application-binary-interface-abi">Appendix C: Application Binary Interface (ABI)</a></h2>
<p>The Application Binary Interface (ABI) is a condensed representation of a smart contract that
exposes enough information about the contract to allow external contexts to interact with it. The
ABI does not contain any contract <em>logic</em> but only its public data such as its storage variables and
its predicates. The ABI is serialized in JSON format, making it both human readable and easily
parsable by relevant tools.</p>
<blockquote>
<p><strong>Note</strong> This particular ABI specification is mostly relevant for the EssentialVM. Other virtual
machines may have different architectures, requiring a completely different ABI format.</p>
</blockquote>
<p>In this chapter, we will cover the following:</p>
<ol>
<li>The ABI specification.</li>
<li>How to construct solutions using the ABI.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="appendix-c1-application-binary-interface-abi-specification"><a class="header" href="#appendix-c1-application-binary-interface-abi-specification">Appendix C.1: Application Binary Interface (ABI) Specification</a></h2>
<p>In this chapter, we will cover the specification of the Application Binary Interface (ABI) and
provide an example that showcase how the final ABI looks like in JSON format.</p>
<h3 id="json-abi-specification"><a class="header" href="#json-abi-specification">JSON ABI Specification</a></h3>
<p>The ABI of a contract is represented as a JSON object containing the following properties:</p>
<h4 id="storage-1"><a class="header" href="#storage-1"><code>&quot;storage&quot;</code></a></h4>
<p>This is an array that describes every storage variable in the contract, i.e., every variable
declared in the <code>storage { .. }</code> block. Each entry in this array is a JSON object that contains the
following properties:</p>
<ul>
<li><code>&quot;name&quot;</code>: a string representing the name of the storage variable.</li>
<li><code>&quot;ty&quot;</code>: a JSON object representing the type of the storage variable. This is further explained in
<a href="appendix/abi/abi_spec.html#json-representation-of-types">JSON Representation of Types</a>.</li>
</ul>
<h4 id="predicates"><a class="header" href="#predicates"><code>&quot;predicates&quot;</code></a></h4>
<p>This is an array that describes every predicate in the contract. Each entry in this array is a JSON
object that contains the following properties:</p>
<ul>
<li><code>&quot;name&quot;</code>: a string representing the name of the predicate.</li>
<li><code>&quot;params&quot;</code>: an array that contains the parameters of the predicate. Each entry in this array is a
JSON object that contains the following properties:
<ul>
<li><code>&quot;name&quot;</code>: a string representing the name of the parameter.</li>
<li><code>&quot;ty&quot;</code>: a JSON object representing the type of the parameter. This is further explained
in <a href="appendix/abi/abi_spec.html#json-representation-of-types">JSON Representation of Types</a>.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The order in which the predicate parameters show up in the JSON is important and must
match the order in which they are declared in the Pint code. When constructing a solution, that
same order should also be respected.</p>
</blockquote>
<h3 id="json-representation-of-types"><a class="header" href="#json-representation-of-types">JSON Representation of Types</a></h3>
<p>Each possible Pint type is represented in the ABI as a JSON object with properties that depend on
the type. Below is a list of the JSON objects for each possible type:</p>
<h4 id="int"><a class="header" href="#int"><code>int</code></a></h4>
<pre><code class="language-json">&quot;Int&quot;
</code></pre>
<h4 id="bool"><a class="header" href="#bool"><code>bool</code></a></h4>
<pre><code class="language-json">&quot;Bool&quot;
</code></pre>
<h4 id="b256"><a class="header" href="#b256"><code>b256</code></a></h4>
<pre><code class="language-json">&quot;B256&quot;
</code></pre>
<h4 id="union"><a class="header" href="#union">Union</a></h4>
<pre><code class="language-json">{
  &quot;Union&quot;: {
    &quot;name&quot;: &lt;union_name&gt;,
    &quot;variants&quot;: [
      {
        &quot;name&quot;: &lt;variant1_name&gt;,
        &quot;ty&quot;: &lt;variant1_ty&gt;
      },
      {
        &quot;name&quot;: &lt;variant2_name&gt;,
        &quot;ty&quot;: &lt;variant2_ty&gt;
      },
      ...
    ]
  }
}
</code></pre>
<p>In the above, <code>&lt;variant1_name&gt;</code>, <code>&lt;variant2_name&gt;</code>, ... are strings representing the names of the
union variants. <code>&lt;variant1_ty&gt;</code>, <code>&lt;variant2_ty&gt;</code>, ... are JSON objects representing the types of the
tuple fields, formatted according to the rules of this section. These are optional, that is, they
can be set to <code>null</code> if the corresponding variants don't hold any values.</p>
<h4 id="tuple"><a class="header" href="#tuple">Tuple</a></h4>
<pre><code class="language-json">{
  &quot;Tuple&quot;: [
    {
      &quot;name&quot;: &lt;field1_name&gt;,
      &quot;ty&quot;: &lt;field1_ty&gt;
    }
    {
      &quot;name&quot;: &lt;field2_name&gt;,
      &quot;ty&quot;: &lt;field2_ty&gt;
    }
    ...
  ]
}
</code></pre>
<p>In the above, <code>&lt;field1_name&gt;</code>, <code>&lt;field2_name&gt;</code>, ... are strings representing the names of the tuple
fields. These are optional, that is, they can be set to <code>null</code> if the corresponding tuple fields
have no names. <code>&lt;field1_ty.</code>, <code>&lt;field2_ty&gt;</code>, ... are JSON objects representing the types of the
tuple fields, formatted according to the rules of this section.</p>
<h4 id="array"><a class="header" href="#array">Array</a></h4>
<pre><code class="language-json">{
  &quot;Array&quot;: {
    &quot;ty&quot;: &lt;element_ty&gt;,
    &quot;size&quot;: &lt;array_size&gt;
  }
}
</code></pre>
<p>In the above, <code>&lt;element_ty&gt;</code> is a JSON object representing the type of each element in the array,
formatted according to the rules of this section. <code>&lt;array_size&gt;</code> is an integer representing the size
of the array.</p>
<h4 id="storage-map-1"><a class="header" href="#storage-map-1">Storage Map</a></h4>
<pre><code class="language-json">{
  &quot;Map&quot;: {
    &quot;ty_from&quot;: &lt;ty_from&gt;,
    &quot;ty_to&quot;: &lt;ty_to&gt;,
  }
}
</code></pre>
<p>In the above, <code>&lt;ty_from&gt;</code> and <code>&lt;ty_to&gt;</code> are JSON objects representing the &quot;from&quot; type and the &quot;to&quot;
type in the map, formatted according to the rules of this section.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>Here's an example contract and its corresponding JSON ABI:</p>
<pre><code class="language-pint">union U = A(int) | B | C(int[3]);

storage {
    s0: b256,
    s1: { int, int },
    my_map: ( int =&gt; { int, int } ),
    my_union: U
}

predicate foo(
    v0: int,
    v1: bool[5],
    v2: U,
    v3: { int, int }[5], 
) {
}
</code></pre>
<pre><code class="language-json">{
  &quot;predicates&quot;: [
    {
      &quot;name&quot;: &quot;::foo&quot;,
      &quot;params&quot;: [
        {
          &quot;name&quot;: &quot;::v0&quot;,
          &quot;ty&quot;: &quot;Int&quot;
        },
        {
          &quot;name&quot;: &quot;::v1&quot;,
          &quot;ty&quot;: {
            &quot;Array&quot;: {
              &quot;ty&quot;: &quot;Bool&quot;,
              &quot;size&quot;: 5
            }
          }
        },
        {
          &quot;name&quot;: &quot;::v2&quot;,
          &quot;ty&quot;: {
            &quot;Union&quot;: {
              &quot;name&quot;: &quot;::U&quot;,
              &quot;variants&quot;: [
                {
                  &quot;name&quot;: &quot;U::A&quot;,
                  &quot;ty&quot;: &quot;Int&quot;
                },
                {
                  &quot;name&quot;: &quot;U::B&quot;,
                  &quot;ty&quot;: null
                },
                {
                  &quot;name&quot;: &quot;U::C&quot;,
                  &quot;ty&quot;: {
                    &quot;Array&quot;: {
                      &quot;ty&quot;: &quot;Int&quot;,
                      &quot;size&quot;: 3
                    }
                  }
                }
              ]
            }
          }
        },
        {
          &quot;name&quot;: &quot;::v3&quot;,
          &quot;ty&quot;: {
            &quot;Array&quot;: {
              &quot;ty&quot;: {
                &quot;Tuple&quot;: [
                  {
                    &quot;name&quot;: null,
                    &quot;ty&quot;: &quot;Int&quot;
                  },
                  {
                    &quot;name&quot;: null,
                    &quot;ty&quot;: &quot;Int&quot;
                  }
                ]
              },
              &quot;size&quot;: 5
            }
          }
        }
      ]
    }
  ],
  &quot;storage&quot;: [
    {
      &quot;name&quot;: &quot;s0&quot;,
      &quot;ty&quot;: &quot;B256&quot;
    },
    {
      &quot;name&quot;: &quot;s1&quot;,
      &quot;ty&quot;: {
        &quot;Tuple&quot;: [
          {
            &quot;name&quot;: null,
            &quot;ty&quot;: &quot;Int&quot;
          },
          {
            &quot;name&quot;: null,
            &quot;ty&quot;: &quot;Int&quot;
          }
        ]
      }
    },
    {
      &quot;name&quot;: &quot;my_map&quot;,
      &quot;ty&quot;: {
        &quot;Map&quot;: {
          &quot;ty_from&quot;: &quot;Int&quot;,
          &quot;ty_to&quot;: {
            &quot;Tuple&quot;: [
              {
                &quot;name&quot;: null,
                &quot;ty&quot;: &quot;Int&quot;
              },
              {
                &quot;name&quot;: null,
                &quot;ty&quot;: &quot;Int&quot;
              }
            ]
          }
        }
      }
    },
    {
      &quot;name&quot;: &quot;my_union&quot;,
      &quot;ty&quot;: {
        &quot;Union&quot;: {
          &quot;name&quot;: &quot;::U&quot;,
          &quot;variants&quot;: [
            {
              &quot;name&quot;: &quot;U::A&quot;,
              &quot;ty&quot;: &quot;Int&quot;
            },
            {
              &quot;name&quot;: &quot;U::B&quot;,
              &quot;ty&quot;: null
            },
            {
              &quot;name&quot;: &quot;U::C&quot;,
              &quot;ty&quot;: {
                &quot;Array&quot;: {
                  &quot;ty&quot;: &quot;Int&quot;,
                  &quot;size&quot;: 3
                }
              }
            }
          ]
        }
      }
    }
  ]
}
</code></pre>
<p>Here's how we would interpret this JSON ABI:</p>
<ul>
<li>This contract has a single predicate called <code>::foo</code>, which is the <em>full path</em> of the <code>foo</code>
predicate in the contract above.</li>
<li>Predicate <code>::foo</code> has three parameters:
<ul>
<li>At index 0, we have <code>::v0</code> of type <code>int</code>.</li>
<li>At index 1, we have <code>::v1</code> of type <code>bool[5]</code>.</li>
<li>At index 2, we have <code>::v2</code> of type <code>U</code> which is a union with three variants <code>U::A</code>, <code>U::B</code>, and
<code>U::C</code>.</li>
<li>At index 3, we have <code>::v3</code>. It's an array of 5 tuples, where each tuple contains two <code>int</code>s
with no field names.</li>
</ul>
</li>
<li>The contract also has four storage variables:
<ul>
<li>The first is called <code>s0</code> and is of type <code>b256</code>.</li>
<li>The second is called <code>s1</code> and is a tuple of two <code>int</code>s.</li>
<li>The third is called <code>my_map</code> and is a storage map from <code>int</code> to a tuple of two <code>int</code>s.</li>
<li>The fourth is called <code>my_union</code> and is a union with three variants <code>U::A</code>, <code>U::B</code>, and <code>U::C</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="constructing-solutions-using-the-abi"><a class="header" href="#constructing-solutions-using-the-abi">Constructing Solutions using the ABI</a></h2>
<p>The Application Binary Interface (ABI) of a contract provides all the essential information needed
to construct a solution for one or more predicates within the contract. Although you could perform
this manually, the <a href="https://docs.rs/pint-abi/latest/pint_abi/"><code>pint-abi</code></a> crate makes it much more
ergonomic in Rust. The <code>pint-abi</code> crate includes the <code>gen_from_file</code> macro, which automatically
generates the modules, types, and builder methods required to accomplish this.</p>
<h3 id="the-gen_from_file-macro"><a class="header" href="#the-gen_from_file-macro">The <code>gen_from_file</code> Macro</a></h3>
<p>Consider the following simple contract in Pint:</p>
<pre><code class="language-pint">storage {
    s_x: int,
    s_y: bool,
    s_z: {int, b256},
    s_a: {bool, int}[2],
    s_u: MyUnion,
    m1: (int =&gt; b256),
    m2: (int =&gt; (int =&gt; {bool, int})),
}

union MyUnion = A(int) | B;

predicate MyPredicate(
    x: int,
    y: bool,
    z: {int, b256},
    a: {bool, int}[2],
    u: MyUnion,
) {
    // Check arguments
    constraint x == 42;
    constraint y == true;
    constraint z == {2, 0x1111111100000000111111110000000011111111000000001111111100000000};
    constraint a == [{true, 1}, {false, 2}];
    constraint u == MyUnion::A(3);

    let s_x = mut storage::s_x;
    let s_y = mut storage::s_y;
    let s_z = mut storage::s_z;
    let s_a = mut storage::s_a;
    let s_u = mut storage::s_u;
    let m1_42 = mut storage::m1[42];
    let m2_5_6 = mut storage::m2[5][6];

    // Update state
    constraint s_x' == 7;
    constraint s_y' == true;
    constraint s_z' == {8, 0x2222222200000000222222220000000022222222000000002222222200000000};
    constraint s_a' == [{false, 3}, {true, 4}];
    constraint s_u' == MyUnion::B;
    constraint m1_42' == 0x3333333300000000333333330000000033333333000000003333333300000000;
    constraint m2_5_6' == {true, 69};
}
</code></pre>
<p>If you have <code>pint-abi</code> added as dependency in your Rust project, you'll have access to the
<code>gen_from_file</code> macro which can be called as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pint_abi::gen_from_file! {
    abi: &quot;abi_gen_example/out/debug/abi_gen_example-abi.json&quot;,
    contract: &quot;abi_gen_example/out/debug/abi_gen_example.json&quot;,
}
<span class="boring">}</span></code></pre></pre>
<p>The macro takes two arguments:</p>
<ol>
<li><code>abi</code>: a path to the ABI of the contract in JSON format</li>
<li><code>contract</code>: a path to the bytecode of the contract in JSON format</li>
</ol>
<p>The macro above expands to a set of modules, types, and builder methods that allow creating data for
solutions <strong>directly using Rust types</strong> without having to do the encoding manually.</p>
<p>In order to construct a solution to a predicate, you need construct two vectors:</p>
<ol>
<li>A vector of all the predicate arguments.</li>
<li>A vector of all the state mutations.</li>
</ol>
<h3 id="predicate-arguments"><a class="header" href="#predicate-arguments">Predicate Arguments</a></h3>
<p>In order to construct a vector of arguments for the predicate above, you can use the following
syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let arguments = MyPredicate::Vars {
        x: 42,
        y: true,
        z: (2, [0x1111111100000000; 4]),
        a: [(true, 1), (false, 2)],
        u: MyUnion::A(3),
    };
<span class="boring">}</span></code></pre></pre>
<p>The module <code>MyPredicate</code> (which clearly corresponds to the predicate <code>MyPredicate</code> in our contract
above) and the struct <code>Vars</code> are readily available to us from the expansion of the <code>gen_from_file</code>
macro. The fields of the struct <code>Vars</code> exactly match the list of parameters of <code>MyPredicate</code>, both
in name and type.</p>
<p>Each predicate parameter Pint type has a corresponding Rust type as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Pint Type</th><th>Rust Type</th></tr></thead><tbody>
<tr><td><code>int</code></td><td><code>i64</code></td></tr>
<tr><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td><code>b256</code></td><td><code>[i64, 4]</code></td></tr>
<tr><td>Union</td><td>Enum</td></tr>
<tr><td>Tuple</td><td>Tuple</td></tr>
<tr><td>Array</td><td>Array</td></tr>
</tbody></table>
</div>
<h3 id="state-mutations"><a class="header" href="#state-mutations">State Mutations</a></h3>
<p>In order to construct a vector of proposed state mutations for the contract above, you can use the
following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let state_mutations: Vec&lt;essential_types::solution::Mutation&gt; = storage::mutations()
        .s_x(7)
        .s_y(true)
        .s_z(|tup| tup._0(8)._1([0x2222222200000000; 4]))
        .s_a(|arr| {
            arr.entry(0, |tup| tup._0(false)._1(3))
                .entry(1, |tup| tup._0(true)._1(4))
        })
        .s_u(MyUnion::B)
        .m1(|map| map.entry(42, [0x3333333300000000; 4]))
        .m2(|map| map.entry(5, |map| map.entry(6, |tup| tup._0(true)._1(69))))
        .into();
<span class="boring">}</span></code></pre></pre>
<p>The module <code>storage</code> and the function <code>mutations()</code> are readily available for us from the expansion
of the <code>gen_from_file</code> macro. The resulting object is of type
<code>Vec&lt;essential_types::solution::Mutation&gt;</code> from the
<a href="https://docs.rs/essential-types/latest/essential_types/index.html"><code>essential_types</code></a> crate.</p>
<p>Because all state mutations are optional, they need to be set individually using their own builder
methods (unlike predicate arguments). For simple types like <code>int</code>, <code>bool</code>, <code>b256</code>, and unions, the
syntax is self explanatory. Those types have corresponding Rust types as for predicate arguments:</p>
<div class="table-wrapper"><table><thead><tr><th>Pint Type</th><th>Rust Type</th></tr></thead><tbody>
<tr><td><code>int</code></td><td><code>i64</code></td></tr>
<tr><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td><code>b256</code></td><td><code>[i64, 4]</code></td></tr>
<tr><td>Union</td><td>Enum</td></tr>
</tbody></table>
</div>
<p>For more complex types like tuples, arrays, and storage maps, you need to provide <em>closures</em> that
specify how to set each part of the compound type:</p>
<ol>
<li>For tuples, you have available the builder methods <code>_0(..)</code>, <code>_1(..)</code>, etc. that specify a value
for each individual entry of the tuple. you may skip some of these methods if you do not want to
propose any mutations to the corresponding tuple field.</li>
<li>For arrays, you have the builder method <code>entry(..)</code> which takes an integer index and a value to
set the array value at that particular index. Not all array indices need to be set.</li>
<li>For storage maps, you also have the builder method <code>entry(..)</code> which takes a key and a value to
set the map value at that particularly key. The types of the key and the value must match the
types of the key and the value of the map.</li>
</ol>
<h3 id="contract-and-predicate-addresses"><a class="header" href="#contract-and-predicate-addresses">Contract and Predicate Addresses</a></h3>
<p>The expansion of the macro <code>gen_from_file</code> also provides the address of the contract and the address
of each predicate as constants:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let contract_address = ADDRESS;
    let my_predicate_address = MyPredicate::ADDRESS;
<span class="boring">}</span></code></pre></pre>
<p>These constants can be used to construct solutions when specifying what predicate is being solved.</p>
<h3 id="producing-solutions"><a class="header" href="#producing-solutions">Producing Solutions</a></h3>
<p>We now have everything we need to produce a solution. When working with the EssentialVM, a
<code>Solution</code> object can be constructed as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let solution = essential_types::solution::Solution {
        data: vec![essential_types::solution::SolutionData {
            predicate_to_solve: MyPredicate::ADDRESS,
            decision_variables: arguments.into(),
            state_mutations,
        }],
    };
<span class="boring">}</span></code></pre></pre>
<p>where we have used the address of the <code>MyPredicate</code> to specify which predicate to solve, the vector
<code>arguments</code> to specify values for <code>decision_variables</code> (recall that we sometimes refer to predicate
parameters as decision variables), and the vector <code>state_mutations</code> to specify the proposed state
mutations.</p>
<p>Note that this solutions only has a single <code>SolutionsData</code>. In general, solutions may contain
multiple <code>SolutionData</code> objects which can all be produced by following the steps above.</p>
<h3 id="storage-keys"><a class="header" href="#storage-keys">Storage Keys</a></h3>
<p>It is sometimes useful to know the storage keys where a particular storage variable (or some of its
parts) are stored. The expansion of the <code>gen_from_file</code> macro also provides the builder method
<code>storage::keys()</code> which can be used as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let keys: Vec&lt;essential_types::Key&gt; = storage::keys()
        .s_x()
        .s_y()
        .s_z(|tup| tup._0()._1())
        .s_a(|arr| {
            arr.entry(0, |tup| tup._0()._1())
                .entry(1, |tup| tup._0()._1())
        })
        .s_u()
        .m1(|map| map.entry(42))
        .m2(|map| map.entry(5, |map| map.entry(6, |tup| tup._0()._1())))
        .into();
<span class="boring">}</span></code></pre></pre>
<p>The method <code>keys()</code> is readily available in the module <code>storage</code>. Similarly to <code>mutations()</code>, the
key(s) for each storage variable must be appended using the corresponding builder method and the
syntax is fairly similarly to the builder methods for state mutations. The result is a vector of
<code>Key</code>s which can be used to query the state for example.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="appendix-d-known-issues-and-missing-features"><a class="header" href="#appendix-d-known-issues-and-missing-features">Appendix D: Known Issues and Missing Features</a></h2>
<h3 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h3>
<ul>
<li><a href="https://github.com/essential-contributions/pint/issues/913">#913</a>: type checker sometimes misses
type errors in <code>const</code> initializers.</li>
</ul>
<h3 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h3>
<ul>
<li>Strings</li>
<li>Dynamic arrays, i.e., array types where the size is a value that is not known at compile time.</li>
<li>Morphisms such that <code>map</code>, <code>fold</code>, <code>filter</code>, etc. that will allow morphing arrays.</li>
<li>Storage vectors</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pint.js"></script>
        <script src="theme/bnf.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
