<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Macros - The Book of Pint</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../the-book-of-pint.html">The Book of Pint</a></li><li class="chapter-item expanded "><a href="../getting_started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting_started/installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../getting_started/quickstart.html"><strong aria-hidden="true">1.2.</strong> Quickstart Guide</a></li></ol></li><li class="chapter-item expanded "><a href="../examples/index.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/counter.html"><strong aria-hidden="true">2.1.</strong> Counter</a></li><li class="chapter-item expanded "><a href="../examples/subcurrency.html"><strong aria-hidden="true">2.2.</strong> Subcurrency</a></li></ol></li><li class="chapter-item expanded "><a href="../smart_contracts/index.html"><strong aria-hidden="true">3.</strong> Pint Smart Contracts</a></li><li class="chapter-item expanded "><a href="../basics/index.html"><strong aria-hidden="true">4.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/variables.html"><strong aria-hidden="true">4.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../basics/data_types.html"><strong aria-hidden="true">4.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="../basics/comments.html"><strong aria-hidden="true">4.3.</strong> Comments</a></li><li class="chapter-item expanded "><a href="../basics/conditionals.html"><strong aria-hidden="true">4.4.</strong> Conditionals</a></li><li class="chapter-item expanded "><a href="../basics/custom_types.html"><strong aria-hidden="true">4.5.</strong> Custom Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/custom_types/type_aliases.html"><strong aria-hidden="true">4.5.1.</strong> Type Aliases</a></li><li class="chapter-item expanded "><a href="../basics/custom_types/unions.html"><strong aria-hidden="true">4.5.2.</strong> Unions</a></li><li class="chapter-item expanded "><a href="../basics/custom_types/match.html"><strong aria-hidden="true">4.5.3.</strong> The match Construct</a></li></ol></li><li class="chapter-item expanded "><a href="../basics/constraints.html"><strong aria-hidden="true">4.6.</strong> Constraints</a></li><li class="chapter-item expanded "><a href="../basics/constants.html"><strong aria-hidden="true">4.7.</strong> Constants</a></li></ol></li><li class="chapter-item expanded "><a href="../storage/index.html"><strong aria-hidden="true">5.</strong> Storage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../storage/static.html"><strong aria-hidden="true">5.1.</strong> Statically-Sized Storage Types</a></li><li class="chapter-item expanded "><a href="../storage/dynamic.html"><strong aria-hidden="true">5.2.</strong> Dynamically-Sized Storage Types</a></li><li class="chapter-item expanded "><a href="../storage/external.html"><strong aria-hidden="true">5.3.</strong> External Storage Access</a></li></ol></li><li class="chapter-item expanded "><a href="../projects/index.html"><strong aria-hidden="true">6.</strong> Managing Growing Projects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../projects/packages.html"><strong aria-hidden="true">6.1.</strong> Pint Projects</a></li><li class="chapter-item expanded "><a href="../projects/modules.html"><strong aria-hidden="true">6.2.</strong> Defining Modules</a></li><li class="chapter-item expanded "><a href="../projects/paths.html"><strong aria-hidden="true">6.3.</strong> Paths for Referring to an item in a Module Tree</a></li><li class="chapter-item expanded "><a href="../projects/use.html"><strong aria-hidden="true">6.4.</strong> Bringing Paths into Scope with the use Keyword</a></li></ol></li><li class="chapter-item expanded "><a href="../advanced/index.html"><strong aria-hidden="true">7.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced/invoking_predicates.html"><strong aria-hidden="true">7.1.</strong> Invoking Predicates</a></li><li class="chapter-item expanded "><a href="../advanced/macros.html" class="active"><strong aria-hidden="true">7.2.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="../pint-reference/index.html"><strong aria-hidden="true">8.</strong> Pint Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pint-reference/cli.html"><strong aria-hidden="true">8.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="../pint-reference/manifest.html"><strong aria-hidden="true">8.2.</strong> Manifest</a></li></ol></li><li class="chapter-item expanded "><a href="../appendix/index.html"><strong aria-hidden="true">9.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../appendix/keywords.html"><strong aria-hidden="true">9.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="../appendix/intrinsics.html"><strong aria-hidden="true">9.2.</strong> B - Compiler Intrinsics</a></li><li class="chapter-item expanded "><a href="../appendix/abi.html"><strong aria-hidden="true">9.3.</strong> C - Application Binary Interface (ABI) Spec</a></li><li class="chapter-item expanded "><a href="../appendix/known_issues.html"><strong aria-hidden="true">9.4.</strong> A - Known Issues and Missing Features</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Book of Pint</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/essential-contributions/pint" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>Macros are a way of writing code that writes other code, which is known as <em>metaprogramming</em>.
Metaprogramming is useful for reducing the amount of code you have to write and maintain. Most
programming languages have &quot;functions&quot; which somewhat serve a similar purpose. Macros, however, are
a lot more powerful. While Pint does not have &quot;functions&quot;, its macro system is powerful enough to
cover their use case.</p>
<p>Macro <em>expansion</em> is the very first operation performed by the compiler. This property implies that
macros can contain <em>anything</em> as long as the code they produce is parsable, i.e. does not violate
the <em>grammar</em> of Pint. Later stages of the compiler will then validate the semantics of the expanded
code.</p>
<p>Macros in Pint have two main forms:</p>
<ul>
<li><strong>Simple Macros</strong>: these are macros that accept a fixed number of parameters and do not support
recursion.</li>
<li><strong>Variadic Macros</strong>: these are macros that accept a variable number of parameters and can support
recursion.</li>
</ul>
<h3 id="simple-macros"><a class="header" href="#simple-macros">Simple Macros</a></h3>
<p>Simple macros take a fixed number of parameters, each starting with <code>$</code>. Consider the following
simple macro:</p>
<pre><code class="language-pint">macro @in_range($v, $num) {
    constraint $v &gt;= $num;
    constraint $v &lt; ($num * $num);
}
</code></pre>
<p>Macro definitions always start with the keyword <code>macro</code> followed by the name of the macro, which
must start with <code>@</code>. Then, a list of named parameters is provided in between parentheses. The body
of the macro is provided in between curly braces and can contain any code that uses the macro
parameters.</p>
<p>The macro above is named <code>@in_range</code> and takes 2 parameters named <code>$v</code> and <code>$num</code>. In the body of
this macro, these parameters are used as expressions but this is not always necessarily the case!
When this macro is used, two constraints are always produced. Let's use this macro as follows:</p>
<pre><code class="language-pint">let x = 42;
@in_range(x; 10);
</code></pre>
<p>To call the macro, we write its name followed by a list of arguments, separated by a semicolon
(<code>;</code>), in between parentheses. The number of arguments must match the number of parameters that the
macro expects.</p>
<blockquote>
<p><strong>Note</strong>: yes, the arguments are separated by a semicolon (<code>;</code>) and not a comma (<code>,</code>).</p>
</blockquote>
<p>After the macro gets expanded, the compiler will produce code that is equivalent to the following:</p>
<pre><code class="language-pint">let x = 42;
constraint x &gt;= 10;
constraint x &lt; (10 * 10);
</code></pre>
<p>It should hopefully be quite clear to you how this substitution happened. The compiler simply
rewrote the body of the macro by replacing <code>$v</code> with <code>x</code> and <code>$num</code> with <code>10</code>. The resulting code is
then <em>pasted</em> exactly where the macro was called.</p>
<h4 id="arbitrary-tokens-as-macro-arguments"><a class="header" href="#arbitrary-tokens-as-macro-arguments">Arbitrary Tokens as Macro Arguments</a></h4>
<p>The arguments to a macro call may be collections of tokens which do not necessarily parse to a
proper expression, as in the previous example. For example, an operator like <code>+</code> or a type name such
as <code>int</code> are valid!. If the token is an identifier, then it may be used as a name, such as the name
of a decision variable or a new type. Here's an example:</p>
<pre><code class="language-pint">macro @do_decls($a, $a_expr, $b, $b_expr, $ty, $op) {
    let $a: $ty = $a_expr;
    let $b: $ty = $b_expr;
    constraint $b $op $a;
}
</code></pre>
<p>The author of this macro likely expects:</p>
<ul>
<li><code>$a</code> and <code>$b</code> to be identifiers.</li>
<li><code>$a_expr</code> and <code>$b_expr</code> to be expressions.</li>
<li><code>$ty</code> to be a type.</li>
<li><code>$op</code> to be a binary operator such as <code>+</code>, <code>-</code>, etc.</li>
</ul>
<p>In fact, if the rules above are not respected when calling the macro, the program will likely fail
to parse correctly resulting in a failed compilation.</p>
<p>If we call the macro above with:</p>
<pre><code class="language-pint">@do_decls(x1; 42; x2; 69; int; &gt;);
</code></pre>
<p>the compiler will expand the macro call to:</p>
<pre><code class="language-pint">let x1: int = 42;
let x2: int = 69;
constraint x2 &gt; x1;
</code></pre>
<p>Hopefully this gives you an idea of how powerful macros can be.</p>
<h4 id="macro-expressions"><a class="header" href="#macro-expressions">Macro Expressions</a></h4>
<p>So far, we've only looked at example macros where the body is a list of declarations (such as <code>let</code>
declarations or constraints). Macros are even more versatile than that! Macros can, in fact, produce
an expression. This would be akin to functions that return values in other programming languages.</p>
<p>The expression that you want produced by the macro must always be the last statement in the macro
body. For example:</p>
<pre><code class="language-pint">macro @quotion($a, $b) {
    constraint $b &gt; 0;  // Declaration.
    $a / $b             // Final expression.
}
</code></pre>
<p>Because this macro produces an expression, a call to it can be used as an expression as well. For
example:</p>
<pre><code class="language-pint">let e: int = 4;
let f: int = 2;
let q: int = @quotion(e; f);
</code></pre>
<p>As a result, the compiler will expand the macro call to:</p>
<pre><code class="language-pint">let e: int = 4;
let f: int = 2;
constraint f &gt; 0;
let q: int = e / f;
</code></pre>
<p>Note that the expression is always inserted at the exact location where the macro was called, but
any declaration items in the macro body are inserted <em>right before</em> the call.</p>
<!--
TODO: re-enable after making `let` variables hygienic
#### Declaring Variables in Macro Bodies

Earlier, we looked at an example macro that uses some of its parameters as identifiers to declare
some local variables. When that macro is called multiple times with different arguments, the
resulting variable declarations will not cause any name conflicts. Now, what happens if, instead, we
were to directly use an identifier in a macro body when declaring new variables? Here's an example:

```pint
macro @is_even($a) {
    let half: int = $a / 2;
    constraint $a == half * 2 || $a == half * 2 + 1;
}
```

In a naive macro system, if `@is_even` was called more than once within the same module, then after
expansion there would be multiple `half` variable declarations, resulting a name clash error.

To avoid this problem Pint's macro expansion aims to be **hygienic** and places newly declared
symbols into a unique anonymous namespace. Note that this is only done for symbols which are **not**
macro parameters. To illustrate this, consider the following:

```pint
// macro @var_decls($a) {
//     let foo: int = 42;     // Hygienic anonymous binding for `foo`.
//     let $a: bool = true;   // Lexical binding for `$a`.
// }
```

If we call the macro above using `@let_decls(foo)` there would not be an error as the expansion
would be equivalent to:

```pint
let anon_0::foo: int = 42;
let foo: bool = true;
```

And even when called multiple times with different arguments there would be no error:

```pint
// @var_decls(foo);
// @var_decls(bar);
```

Becomes equivalent to:

```pint
let anon_0::foo: int = 42;
let foo: bool = true;
let anon_1::foo: int = 42;
let bar: bool = true;
```

Of course, if `@let_decls` was called with the argument `foo` multiple times there would be an
error!

-->
<h3 id="recursion-and-variadic-macros"><a class="header" href="#recursion-and-variadic-macros">Recursion and Variadic Macros</a></h3>
<p>The second type of macros we will look at is &quot;Variadic Macros&quot;. Variadic macros allow a special type
of recursion via <em>variadic parameters</em>. Such special parameters allow macros to call themselves,
essentially entering an <em>expansion loop</em>. Think of this as <strong>recursive code generation</strong>.</p>
<p>The term &quot;variadic&quot; means that the macro accepts a variable number of parameters. In the parameter
list of the macro definition this is indicated using a special parameter whose name starts with an
<code>&amp;</code>. Recursion may be performed via one or more recursing macros and at least one non-recursing, or
<em>terminating</em> macros. The recursing macros call other versions of itself but with a different number
of - usually fewer - arguments. The terminating macros do not call another version of itself. This
is best explained with an example, so let's consider the following macro which implements a sum
operation over an arbitrary number of named variables:</p>
<pre><code class="language-pint">// Recursive Macro
macro @sum($x, $y, &amp;rest) {
    // Called only when `&amp;rest` is not empty.  
    // We recurse by adding `$x` and `$y` and using `&amp;rest` as the second argument.
    @sum($x + $y; &amp;rest)
}

// Terminating Macro
macro @sum($x, $y) {
    // Called only when the number of arguments is exactly 2.
    $x + $y
}
</code></pre>
<p>We have two versions of the <code>@sum</code> macro. Despite the apparent name clash, this is actually okay
because the two macros accept a different number of parameters. The first version of <code>@sum</code> accepts
<code>$x</code>, <code>$y</code>, and <code>&amp;rest</code> while the second version accepts only <code>$x</code> and <code>$y</code>. The parameter <code>&amp;rest</code>
is special and is referred to as a &quot;parameter pack&quot;. The parameter pack is never empty, therefore in
order to call the first version of <code>@sum</code>, we must pass 3 or more arguments.</p>
<blockquote>
<p><strong>Note</strong>: The parameter pack is not addressable in any way. It may only be used as an argument to
another macro call.</p>
</blockquote>
<p>Now let's walk through how the compiler would expand a call to <code>@sum</code>. You will notice that the
compiler will always try to match the number of arguments provided to the number of parameters in
each macro, and the best match will be selected.</p>
<p>Calling <code>@sum(a; b)</code> will expand directly using the terminating macro to the expression <code>a + b</code>.</p>
<p>Calling <code>@sum(a; b; c; d)</code> will expand as follows:</p>
<ul>
<li><code>@sum(a; b; c; d)</code> calls the recursive macro as <code>@sum(a; b; [c, d])</code> where <code>[c, d]</code> is <code>&amp;rest</code>.</li>
<li><code>@sum(a; b; [c, d])</code> expands to <code>@sum(a + b; c; d)</code>.</li>
<li><code>@sum(a + b; c; d)</code> calls the recursive macro again, as <code>@sum(a + b; c; [d])</code>.</li>
<li><code>@sum(a + b; c; [d])</code> expands to <code>@sum(a + b + c; d)</code>.</li>
<li><code>@sum(a + b + c; d)</code> calls the terminating macro.</li>
<li><code>@sum(a + b + c; d)</code> expands to <code>a + b + c + d</code>, which is the final expanded form of the macro
call.</li>
</ul>
<p>Note that, since the <code>&amp;rest</code> parameter pack is passed in its expanded form, the above <code>@sum</code> macros
could instead be rewritten as follows, to the same effect:</p>
<pre><code class="language-pint">// Recursive Macro
macro @sum_v2($x, &amp;rest) {
    @sum_v2($x + &amp;rest)
}

// Terminating Macro
macro @sum_v2($x) {
    $x
}
</code></pre>
<!---
TODO: come up with a better example that does not require declaring decision variables in the macro

Parameter packs can also be used by non-recursive macros which wish to call other recursive macros.
A more interesting use of variadic macros might be to chain variables together in relative
constraints:

```pint
// macro @chain($a, &rest) {
//     // Add the first link in the chain, then move to the rest.
//     var $a: int;
//     @chain_next($a; &rest)
// }
// 
// macro @chain_next($prev, $next, &rest) {
//     // Add the next link:
//     // constrain based on the previous link and continue.
//     var $next: int;
//     constraint $next > $prev + 10;
//     @chain_next($next; &rest)
// }
// 
// macro @chain_next($prev, $last) {
//     // Just expand to the final link.
//     var $last: int;
//     constraint $last > $prev + 10;
//     $last
// }
```

When called as `var r = @chain(m; n; p)`, the following code would be produced:

```pint
// var m: int;
// var n: int;
// constraint n > m + 10;
// var p: int;
// constraint p > n + 10;
// var r = p;
```
-->
<h4 id="array-argument-splicing"><a class="header" href="#array-argument-splicing">Array Argument Splicing</a></h4>
<p>An extension to macro argument packing is the concept of <em>array splicing</em>. Array splicing allows
passing the elements of an array variable, in place, as the arguments to a macro call. This is done
by prefixing the array name with a tilde <code>~</code>.</p>
<p>Say we want to find the sum of the elements of some array of integers. If we were to use the
variadic macro <code>@sum</code> from earlier, we would have to write something like:</p>
<pre><code class="language-pint">let sum_of_array = @sum(array[0]; array[1]; array[2]; array[3]);
</code></pre>
<p>The issue with the above is that it's quite verbose, especially when the array size is large.
Instead, array splicing allows us to write this instead:</p>
<pre><code class="language-pint">let sum_of_array_v2 = @sum(~array);
</code></pre>
<p>The compiler will then split <code>array</code> into its individual elements and pass them as separate
arguments to <code>@sum</code>, so that the resulting expansion is</p>
<pre><code class="language-pint">let sum_of_array_v2 = @sum(array[0]; array[1]; array[2]; array[3]);
</code></pre>
<p>Array splicing is usually only useful with variadic macros which can handle arrays of different
sizes, though a non-variadic macro may be called with array splicing if the array size exactly
matches the number of required arguments.</p>
<p>An important property of array splicing is that the array element accesses are expanded in place and
the argument separators are only placed between them and not at their ends! The following:</p>
<pre><code class="language-pint">@foo(~two + ~two + ~two);
</code></pre>
<p>expands to:</p>
<pre><code class="language-pint">@foo(two[0]; two[1] + two[0]; two[1] + two[0]; two[1]);
</code></pre>
<p>This may be a bit surprising at first, but what is really happening here is that each <code>~two</code> gets
replaced <em>verbatim</em> with <code>two[0]; two[1]</code> and the <code>+</code> signs stay exact where they were. So, the
three spliced arrays make up a total of 4 separate arguments in this specific case.</p>
<p>Similarly,</p>
<pre><code class="language-pint">constraint @sum(100 + ~nums * 200) &lt; 1000;
</code></pre>
<p>expands to:</p>
<pre><code class="language-pint">constraint @sum(100 + nums[0]; nums[1]; nums[2] * 200) &lt; 1000;
</code></pre>
<p>The arithmetic add and multiply are applied to the first and last elements of the array in this
example.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../advanced/invoking_predicates.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../pint-reference/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../advanced/invoking_predicates.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../pint-reference/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/pint.js"></script>
        <script src="../theme/bnf.js"></script>


    </div>
    </body>
</html>
