// ANCHOR: storage_block
storage {
    x: int,
    a: b256,
    t: { int, bool },
    y: bool,
    w: int,
    arr: { int, int }[3],
    v: { int, { bool, b256 } },
}
// ANCHOR_END: storage_block

predicate test(value: int) {
// ANCHOR: storage_access_1
let x = storage::x;
let a = storage::a;
let t = storage::t;
let t_1 = storage::t.1;
let arr_2_1 = storage::arr[2].1;
// ANCHOR_END: storage_access_1

// ANCHOR: let 
let not_annotated = (storage::x * storage::w) + 1;
let annotated: { b256, b256, int[3] } = { storage::a, storage::v.1.1, [ 1, 2, 3 ] };
// ANCHOR_END: let 

// ANCHOR: constraint
let t_0 = storage::t.0 + 1;
let y = !storage::y;
constraint y && t_0 >= 42;
// ANCHOR_END: constraint

// ANCHOR: next_state
let bal = mut storage::x;
constraint bal' >= bal + 42;
// ANCHOR_END: next_let 

// ANCHOR: mut 
let inner: { bool, b256 } = mut storage::v.1;
// ANCHOR_END: mut 

// ANCHOR: nil 
let w = mut storage::w;
constraint value == (w == nil ? 0 : w);
// ANCHOR_END: nil 

// ANCHOR: update_to_nil 
if w != nil {
    constraint w' == nil;
}
// ANCHOR_END: update_to_nil 
}
