// <no-solve>

use ::b::c;
use ::d::MyEnum;
use b;

let c1 = ::b::c;
let c2 = b::c;
let c3 = c;
let c4 = b::c;

let a_variant = MyEnum::A;
let b_variant = d::MyEnum::B;

solve satisfy;

// intermediate <<<
// var ::c1;
// var ::c2;
// var ::c3;
// var ::c4;
// var ::a_variant;
// var ::b_variant;
// var ::b::c;
// enum ::d::MyEnum = A | B;
// constraint (::c1 == ::b::c);
// constraint (::c2 == ::b::c);
// constraint (::c3 == ::b::c);
// constraint (::c4 == ::b::c);
// constraint (::a_variant == ::d::MyEnum::A);
// constraint (::b_variant == ::d::MyEnum::B);
// constraint (::b::c == 5);
// solve satisfy;
// >>>

// flattened <<<
// var ::c1: int;
// var ::c2: int;
// var ::c3: int;
// var ::c4: int;
// var ::a_variant: int;
// var ::b_variant: int;
// var ::b::c: int;
// enum ::d::MyEnum = A | B;
// constraint (::c1 == ::b::c);
// constraint (::c2 == ::b::c);
// constraint (::c3 == ::b::c);
// constraint (::c4 == ::b::c);
// constraint (::a_variant == 0);
// constraint (::b_variant == 1);
// constraint (::b::c == 5);
// constraint (::a_variant >= 0);
// constraint (::a_variant <= 1);
// constraint (::b_variant >= 0);
// constraint (::b_variant <= 1);
// solve satisfy;
// >>>
