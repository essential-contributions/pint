// <no-solve>

let k: int;
let l: int;
let r: real;
let A: int[4];
let B: int[4];

constraint forall i in 0..3, j in 0..3 where !(i >= j), i - 1 >= 0 && j > 0 { k > i + j || j > k };
constraint forall i in 0..3, j in 0..3 where !(i >= j), i - 1 >= 0 && j > 0 { !(i - j < k) };
//constraint forall i in 0..3, j in 0..3 where !(i >= j), i - 1 >= 0 && j > 0 { k == foo(i) + foo(j) };
constraint forall i in 0..3, j in 0..3 where !(i >= j), i - 1 >= 0 && j > 0 { if i > 0 { j > 0 } else { k > 1 } };
constraint forall i in 0..3, j in 0..3 where !(i >= j), i - 1 >= 0 && j > 0 { k in [i, j, l] };
constraint forall i in 0..3, j in 0..3 where !(i >= j), i - 1 >= 0 && j > 0 { A[i] != A[j] + k };
constraint forall i in 0..3, j in 0..3 where !(i >= j), i - 1 >= 0 && j > 0 { k in {i, j, l} };
constraint forall i in 0..3, j in 0..3 where !(i >= j), i - 1 >= 0 && j > 0 { {i, j, k}.0 != {i, j, k}.1 };
constraint forall i in 0..3, j in 0..3 where !(i >= j), i - 1 >= 0 && j > 0 { {i, j, k}.0 != {i, j, k}.1 };
constraint forall i in 0..3, j in 0..3 where !(i >= j), i - 1 >= 0 && j > 0 { i as real / j as real >= r };
constraint forall i in 0..3, j in 0..3 where !(i >= j), i - 1 >= 0 && j > 0 { i in j..k };
constraint forall i in 0..3 {
    forall j in 0..3 {
        A[i] < B[j]
    }
};
constraint   forall i in 0..3 { A[i] != 0 }
          && forall j in 0..3 { A[j] != 0 };

solve satisfy;

// intermediate <<<
// var ::k: int;
// var ::l: int;
// var ::r: real;
// var ::A: int[4];
// var ::B: int[4];
// constraint forall i in 0..3, j in 0..3, where !(::i >= ::j), (((::i - 1) >= 0) && (::j > 0)) { ((::k > (::i + ::j)) || (::j > ::k)) };
// constraint forall i in 0..3, j in 0..3, where !(::i >= ::j), (((::i - 1) >= 0) && (::j > 0)) { !((::i - ::j) < ::k) };
// constraint forall i in 0..3, j in 0..3, where !(::i >= ::j), (((::i - 1) >= 0) && (::j > 0)) { if (::i > 0) { (::j > 0) } else { (::k > 1) } };
// constraint forall i in 0..3, j in 0..3, where !(::i >= ::j), (((::i - 1) >= 0) && (::j > 0)) { ::k in [::i, ::j, ::l] };
// constraint forall i in 0..3, j in 0..3, where !(::i >= ::j), (((::i - 1) >= 0) && (::j > 0)) { (::A[::i] != (::A[::j] + ::k)) };
// constraint forall i in 0..3, j in 0..3, where !(::i >= ::j), (((::i - 1) >= 0) && (::j > 0)) { ::k in {::i, ::j, ::l} };
// constraint forall i in 0..3, j in 0..3, where !(::i >= ::j), (((::i - 1) >= 0) && (::j > 0)) { ({::i, ::j, ::k}.0 != {::i, ::j, ::k}.1) };
// constraint forall i in 0..3, j in 0..3, where !(::i >= ::j), (((::i - 1) >= 0) && (::j > 0)) { ({::i, ::j, ::k}.0 != {::i, ::j, ::k}.1) };
// constraint forall i in 0..3, j in 0..3, where !(::i >= ::j), (((::i - 1) >= 0) && (::j > 0)) { ((::i as real / ::j as real) >= ::r) };
// constraint forall i in 0..3, j in 0..3, where !(::i >= ::j), (((::i - 1) >= 0) && (::j > 0)) { ::i in ::j..::k };
// constraint forall i in 0..3, { forall j in 0..3, { (::A[::i] < ::B[::j]) } };
// constraint (forall i in 0..3, { (::A[::i] != 0) } && forall j in 0..3, { (::A[::j] != 0) });
// solve satisfy;
// >>>

// flattened <<<
// var ::k: int;
// var ::l: int;
// var ::r: real;
// var ::B[0]: int;
// var ::A[0]: int;
// var ::A[1]: int;
// var ::A[2]: int;
// var ::A[3]: int;
// var ::B[1]: int;
// var ::B[2]: int;
// var ::B[3]: int;
// constraint (((1 && ((::k > (1 + 2)) || (2 > ::k))) && ((::k > (1 + 3)) || (3 > ::k))) && ((::k > (2 + 3)) || (3 > ::k)));
// constraint (((1 && !((1 - 2) < ::k)) && !((1 - 3) < ::k)) && !((2 - 3) < ::k));
// constraint (((1 && if (1 > 0) { (2 > 0) } else { (::k > 1) }) && if (1 > 0) { (3 > 0) } else { (::k > 1) }) && if (2 > 0) { (3 > 0) } else { (::k > 1) });
// constraint (((1 && ::k in [1, 2, ::l]) && ::k in [1, 3, ::l]) && ::k in [2, 3, ::l]);
// constraint (((1 && (::A[1] != (::A[2] + ::k))) && (::A[1] != (::A[3] + ::k))) && (::A[2] != (::A[3] + ::k)));
// constraint (((1 && ::k in {1, 2, ::l}) && ::k in {1, 3, ::l}) && ::k in {2, 3, ::l});
// constraint (((1 && ({1, 2, ::k}.0 != {1, 2, ::k}.1)) && ({1, 3, ::k}.0 != {1, 3, ::k}.1)) && ({2, 3, ::k}.0 != {2, 3, ::k}.1));
// constraint (((1 && ({1, 2, ::k}.0 != {1, 2, ::k}.1)) && ({1, 3, ::k}.0 != {1, 3, ::k}.1)) && ({2, 3, ::k}.0 != {2, 3, ::k}.1));
// constraint (((1 && ((1 as real / 2 as real) >= ::r)) && ((1 as real / 3 as real) >= ::r)) && ((2 as real / 3 as real) >= ::r));
// constraint (((1 && 1 in 2..::k) && 1 in 3..::k) && 2 in 3..::k);
// constraint ((((1 && ((((1 && (::A[0] < ::B[0])) && (::A[0] < ::B[1])) && (::A[0] < ::B[2])) && (::A[0] < ::B[3]))) && ((((1 && (::A[1] < ::B[0])) && (::A[1] < ::B[1])) && (::A[1] < ::B[2])) && (::A[1] < ::B[3]))) && ((((1 && (::A[2] < ::B[0])) && (::A[2] < ::B[1])) && (::A[2] < ::B[2])) && (::A[2] < ::B[3]))) && ((((1 && (::A[3] < ::B[0])) && (::A[3] < ::B[1])) && (::A[3] < ::B[2])) && (::A[3] < ::B[3])));
// constraint (((((1 && (::A[0] != 0)) && (::A[1] != 0)) && (::A[2] != 0)) && (::A[3] != 0)) && ((((1 && (::A[0] != 0)) && (::A[1] != 0)) && (::A[2] != 0)) && (::A[3] != 0)));
// solve satisfy;
// >>>
