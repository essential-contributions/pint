// Model for determining relationships between a 1 year loan repaying every quarter

// variables
let r: real;  // quarterly repayment
let p: real;  // principal initially borrowed
let i: real;  // interest rate (per quarter)

// intermediate variables
let b1: real; // balance after one quarter
let b2: real; // balance after two quarters
let b3: real; // balance after three quarters
let b4: real; // balance owing at end

constraint b1 == p + p * i - r;
constraint b2 == b1 + b1 * i - r;
constraint b3 == b2 + b2 * i - r;
constraint b4 == b3 + b3 * i - r;

solve satisfy;

// intermediate <<<
// var ::r: real;
// var ::p: real;
// var ::i: real;
// var ::b1: real;
// var ::b2: real;
// var ::b3: real;
// var ::b4: real;
// constraint (::b1 == ((::p + (::p * ::i)) - ::r));
// constraint (::b2 == ((::b1 + (::b1 * ::i)) - ::r));
// constraint (::b3 == ((::b2 + (::b2 * ::i)) - ::r));
// constraint (::b4 == ((::b3 + (::b3 * ::i)) - ::r));
// solve satisfy;
// >>>

// compiled_intent <<<
// Intent { states: [], vars: [Variable { name: "::r", ty: Real }, Variable { name: "::p", ty: Real }, Variable { name: "::i", ty: Real }, Variable { name: "::b1", ty: Real }, Variable { name: "::b2", ty: Real }, Variable { name: "::b3", ty: Real }, Variable { name: "::b4", ty: Real }], constraints: [BinaryOp { op: Equal, lhs: Path("::b1"), rhs: BinaryOp { op: Sub, lhs: BinaryOp { op: Add, lhs: Path("::p"), rhs: BinaryOp { op: Mul, lhs: Path("::p"), rhs: Path("::i") } }, rhs: Path("::r") } }, BinaryOp { op: Equal, lhs: Path("::b2"), rhs: BinaryOp { op: Sub, lhs: BinaryOp { op: Add, lhs: Path("::b1"), rhs: BinaryOp { op: Mul, lhs: Path("::b1"), rhs: Path("::i") } }, rhs: Path("::r") } }, BinaryOp { op: Equal, lhs: Path("::b3"), rhs: BinaryOp { op: Sub, lhs: BinaryOp { op: Add, lhs: Path("::b2"), rhs: BinaryOp { op: Mul, lhs: Path("::b2"), rhs: Path("::i") } }, rhs: Path("::r") } }, BinaryOp { op: Equal, lhs: Path("::b4"), rhs: BinaryOp { op: Sub, lhs: BinaryOp { op: Add, lhs: Path("::b3"), rhs: BinaryOp { op: Mul, lhs: Path("::b3"), rhs: Path("::i") } }, rhs: Path("::r") } }], directive: Satisfy }
// >>>

// solve_failure <<<
// internal error: pcp solver: only addition is expected in expressions
// >>>
