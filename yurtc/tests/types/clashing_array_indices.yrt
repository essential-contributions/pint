let a: int[4];
let b: int[4];

// The inner `i` is shadowing the outer `i` which is probably not what we want to allow, considering
// we disallow shadowing everywhere else in Yurt.

constraint forall i in 0..3 {
    b[i] == i &&
    forall i in 0..3 {
        a[i] > b[i]
    }
};

solve satisfy;

// intermediate <<<
// var ::a: int[4];
// var ::b: int[4];
// constraint forall i in 0..3, { ((::b[::i] == ::i) && forall i in 0..3, { (::a[::i] > ::b[::i]) }) };
// solve satisfy;
// >>>

// flattened <<<
// var ::b[0]: int;
// var ::a[0]: int;
// var ::a[1]: int;
// var ::a[2]: int;
// var ::a[3]: int;
// var ::b[1]: int;
// var ::b[2]: int;
// var ::b[3]: int;
// constraint ((((true && ((::b[0] == 0) && ((((true && (::a[0] > ::b[0])) && (::a[1] > ::b[1])) && (::a[2] > ::b[2])) && (::a[3] > ::b[3])))) && ((::b[1] == 1) && ((((true && (::a[0] > ::b[0])) && (::a[1] > ::b[1])) && (::a[2] > ::b[2])) && (::a[3] > ::b[3])))) && ((::b[2] == 2) && ((((true && (::a[0] > ::b[0])) && (::a[1] > ::b[1])) && (::a[2] > ::b[2])) && (::a[3] > ::b[3])))) && ((::b[3] == 3) && ((((true && (::a[0] > ::b[0])) && (::a[1] > ::b[1])) && (::a[2] > ::b[2])) && (::a[3] > ::b[3]))));
// solve satisfy;
// >>>
