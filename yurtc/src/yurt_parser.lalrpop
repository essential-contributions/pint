use crate::{
    contract::{ContractDecl, InterfaceDecl},
    error::{Error, ParseError},
    expr::*,
    intent::intermediate::{ExprKey, SolveFunc, VarKey},
    lexer,
    parser::{ParserContext, UseTree},
    types::{self, EnumDecl, ExternDecl, FnSig, NewTypeDecl, PrimitiveKind, Type},
};

grammar<'sc>(
    context: &mut ParserContext<'sc>,
    errors: &mut Vec<Error>,
);

pub Yurt: () = {
    Decl*,
};

////////////////////
/// Declarations ///
////////////////////

Decl: () = {
    UseStatement ";",
    LetDecl ";",
    StateDecl ";",
    ConstraintDecl ";",
    SolveDecl ";",
    EnumDecl ";",
    NewTypeDecl ";",
    InterfaceDecl,
    ContractDecl,
    ExternDecl,
};

UseStatement: () = {
    "use" <abs:"::"?> <ut:UseTree> => {
        // <FMT_OPEN>
        // Convert the use tree into use paths, prepend the current mod path
        // prefix to each iff the use tree is not absolute, and append to the
        // current list of use paths in our context.
        let mut new_use_paths = ut
            .gather_paths()
            .into_iter()
            .map(|mut use_path| {
                if abs.is_none() {
                    use_path.add_prefix(context.mod_path.to_vec());
                }

                // This is a bit strange.  We're taking the last element of the
                // use path, prefixing it with the current mod path and
                // inserting that as a top-level symbol.  This is to avoid
                // local decls clashing with the `use` path, though those
                // symbols are all absolute.
                //
                // e.g.,
                // use some::other::mod::a;
                // let a: int;      // Inserted as ::local::mod::a.
                context
                    .ii
                    .add_top_level_symbol(
                        context.mod_prefix,
                        &Ident {
                            name: use_path.path[use_path.path.len() - 1].clone(),
                            span: use_path.span.clone(),
                        },
                        use_path.span.clone(),
                    )
                    .map(|_| use_path.clone())
                    .unwrap_or_else(|error| {
                        errors.push(Error::Parse { error });
                        use_path
                    })
            })
            .collect::<Vec<_>>();

        context.use_paths.append(&mut new_use_paths);
        // <FMT_CLOSE>
    }
};

pub UseTree: UseTree = {
    <name:Ident> => UseTree::Name { name },
    <prefix:Ident> "::" <suffix:UseTree> => UseTree::Path { prefix, suffix: Box::new(suffix) },
    "{" <imports:SepList<UseTree, ",">> "}" => UseTree::Group { imports },
    <name:Ident> "as" <alias:Ident> => UseTree::Alias { name, alias },
};

pub LetDecl: (VarKey, Option<ExprKey>) = {
    <l:@L> "let" <name:Ident> ":" <ty:Type> <init:LetInit?> <r:@R> => {
        // <FMT_OPEN>
        context
            .ii
            .insert_var(context.mod_prefix, &name, Some(ty))
            .map(|var_key| {
                if let Some(expr_key) = init {
                    context
                        .ii
                        .insert_eq_constraint(var_key, expr_key, (context.span_from)(l, r));
                }
                (var_key, init)
            })
            .unwrap_or_else(|error| {
                // Recover with some default values. This is not great but not
                // too important because these are only used for testing.
                errors.push(Error::Parse { error });
                (VarKey::default(), None)
            })
        // <FMT_CLOSE>
    },
    <l:@L> "let" <name:Ident> <init:LetInit> <r:@R> => {
        // <FMT_OPEN>
        context
            .ii
            .insert_var(context.mod_prefix, &name, None)
            .map(|var_key| {
                context
                    .ii
                    .insert_eq_constraint(var_key, init, (context.span_from)(l, r));
                (var_key, Some(init))
            })
            .unwrap_or_else(|error| {
                // Recover with some default values. This is not great but not
                // too important because these are only used for testing.
                errors.push(Error::Parse { error });
                (VarKey::default(), None)
            })
        // <FMT_CLOSE>
    },
    <l:@L> "let" <name:Ident> <r:@R> => {
        // <FMT_OPEN>
        errors.push(Error::Parse {
            error: ParseError::UntypedVariable {
                name: name.name,
                span: (context.span_from)(l, r),
            },
        });
        // Recover with some default values. This is not great but not
        // too important because these are only used for testing.
        (VarKey::default(), None)
        // <FMT_CLOSE>
    }
};

LetInit: ExprKey = {
    "=" <Range>,
    "=" <Expr>,
};

pub StateDecl: (&'static str, usize) = {
    <l:@L> "state" <name:Ident> <ty:(":" <Type>)?> "=" <init:CallExpr> <r:@R> => {
        // <FMT_OPEN>
        // Return the index to the new state in the IntermediateIntent::states Vec.
        let init_key = context.ii.exprs.insert(init);
        context
            .ii
            .insert_state(
                context.mod_prefix,
                &name,
                ty,
                init_key,
                (context.span_from)(l, r),
            )
            .map(|idx| ("state_idx", idx))
            .unwrap_or_else(|error| {
                // Recover with some default values. This is not great but not
                // too important because these are only used for testing.
                errors.push(Error::Parse { error });
                ("", 0)
            })
        // <FMT_CLOSE>
    }
};

pub ConstraintDecl: ExprKey = {
    <l:@L> "constraint" <e:Expr> <r:@R> => {
        context.ii.constraints.push((e, (context.span_from)(l, r)));
        e
    }
};

pub SolveDecl: SolveFunc = {
    <l:@L> <sd:SolveDeclInner> <r:@R> => {
        context.ii.directives.push((sd.clone(), (context.span_from)(l, r)));
        sd
    }
}

SolveDeclInner: SolveFunc = {
    "solve" "satisfy" => SolveFunc::Satisfy,
    "solve" "minimize" <e:Expr> => SolveFunc::Minimize(e),
    "solve" "maximize" <e:Expr> => SolveFunc::Maximize(e),
};

pub EnumDecl: EnumDecl = {
    <l:@L> "enum" <name:Ident> "=" <variants:Sep1ListNoTrail<Ident, "|">> <r:@R> => {
        // <FMT_OPEN>
        let enum_decl = EnumDecl {
            name: name.to_full_path(context.mod_prefix),
            variants,
            span: (context.span_from)(l, r),
        };
        context.ii.enums.push(enum_decl.clone());
        enum_decl
        // <FMT_CLOSE>
    }
}

pub NewTypeDecl: NewTypeDecl = {
    <l:@L> "type" <name:Ident> "=" <ty:Type> <r:@R> => {
        // <FMT_OPEN>
        let new_type_decl = NewTypeDecl {
            name: name.to_full_path(context.mod_prefix),
            ty,
            span: (context.span_from)(l, r),
        };
        context.ii.new_types.push(new_type_decl.clone());
        new_type_decl
        // <FMT_CLOSE>
    }
}

FnParam: (Ident, Type)  = {
    <name:Ident> ":" <ty:Type> => (name, ty)
}

FnSig: FnSig = {
    <l:@L> "fn" <name:Ident> "(" <params:SepList<FnParam, ",">> ")"  "->" <return_type:Type> <r:@R> => {
        FnSig {
            name,
            params,
            return_type,
            span: (context.span_from)(l, r),
        }
    }
}

pub InterfaceDecl: InterfaceDecl = {
    <l:@L> "interface" <name:Ident> "{" <functions:(<FnSig> ";")*> "}" <r:@R> => {
        // <FMT_OPEN>
        let full_interface_path = name.to_full_path(context.mod_prefix);
        let interface_decl = InterfaceDecl {
            name: full_interface_path.clone(),
            functions: functions
                .iter()
                .map(|fn_sig| FnSig {
                    name: fn_sig
                        .name
                        .to_full_path(&(full_interface_path.name.clone() + "::")),
                    ..fn_sig.clone()
                })
                .collect(),
            span: (context.span_from)(l, r),
        };
        context.ii.interfaces.push(interface_decl.clone());
        interface_decl
        // <FMT_CLOSE>
    }
}

pub ContractDecl: ContractDecl = {
    <l:@L> "contract" <name:Ident> "(" <id:Expr> ")"
        <interfaces: ("implements" <Sep1ListNoTrail<Path, ",">>)?>
        "{" <functions:(<FnSig> ";")*> "}" <r:@R> => {
        // <FMT_OPEN>
        let full_contract_path = name.to_full_path(context.mod_prefix);
        let contract_decl = ContractDecl {
            name: name.to_full_path(context.mod_prefix),
            id,
            interfaces: interfaces.unwrap_or_default().to_vec(),
            functions: functions
                .iter()
                .map(|fn_sig| FnSig {
                    name: fn_sig
                        .name
                        .to_full_path(&(full_contract_path.name.clone() + "::")),
                    ..fn_sig.clone()
                })
                .collect(),
            span: (context.span_from)(l, r),
        };
        context.ii.contracts.push(contract_decl.clone());
        contract_decl
        // <FMT_CLOSE>
    }
}

pub ExternDecl: ExternDecl = {
    <l:@L> "extern" "{" <functions:(<FnSig> ";")*> "}" <r:@R> => {
        // <FMT_OPEN>
        context.ii.externs.push((
            functions
                .iter()
                .map(|fn_sig| FnSig {
                    name: fn_sig.name.to_full_path(context.mod_prefix),
                    ..fn_sig.clone()
                })
                .collect(),
            (context.span_from)(l, r),
        ));
        ExternDecl { functions }
        // <FMT_CLOSE>
    }
}

/////////////
/// Types ///
/////////////

pub Type: Type = {
    <ArrayType>,
    <TypeAtom>,
};

TypeAtom: Type = {
    <l:@L> <kind:PrimitiveType> <r:@R> => Type::Primitive {
        kind,
        span: (context.span_from)(l, r),
    },
    <l:@L> "{" <fields:TupleFields> "}" <r:@R> => {
        Type::Tuple {
            fields,
            span: (context.span_from)(l, r),
        }
    },
    <l:@L> "{" "}" <r:@R> => {
        // <FMT_OPEN>
        let span = (context.span_from)(l, r);
        errors.push(Error::Parse {
            error: ParseError::EmptyTupleType { span: span.clone() },
        });

        // Recover with a malformed type
        Type::Error(span)
        // <FMT_CLOSE>
    },
    <l:@L> <path:Path> <r:@R> => Type::CustomType {
        path,
        span: (context.span_from)(l, r),
    },
};

ArrayType: Type = {
    <l:@L> <ty:TypeAtom> <ranges: ("[" <Expr> "]")+ > <r:@R> => {
        // <FMT_OPEN>
        // Multi-dimensional arrays have their innermost dimension on the far
        // right. Hence, we need to reverse the iterator.
        // For example, `int[3][5]` is actually an array of size 3 that
        // contains arrays of size 5 of `int`s.
        ranges.iter().rev().fold(ty, |acc, range| Type::Array {
            ty: Box::new(acc),
            range: *range,
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
    },
    <l:@L> <ty:TypeAtom> "[" "]" <r:@R> => {
        // <FMT_OPEN>
        let span = (context.span_from)(l, r);
        errors.push(Error::Parse {
            error: ParseError::EmptyArrayType { span: span.clone() },
        });

        // Recover with a malformed type
        Type::Error(span)
        // <FMT_CLOSE>
    },
};

PrimitiveType: PrimitiveKind = {
    "int_ty" => PrimitiveKind::Int,
    "real_ty" => PrimitiveKind::Real,
    "bool_ty" => PrimitiveKind::Bool,
    "string_ty" => PrimitiveKind::String,
}

TupleFields: Vec<(Option<Ident>, Type)> = {
    <field:TupleField> => vec![field],
    <Sep1List<TupleField, ",">>,
};

TupleField: (Option<Ident>, Type) = {
    <id:(<Ident> ":")?> <ty:Type> => (id, ty),
};

///////////////////
/// Expressions ///
///////////////////

pub Expr: ExprKey = {
    <LogicalOrOp>,
};

LogicalOrOp: ExprKey = {
    <l:@L> <lhs:LogicalOrOp> "||" <rhs:LogicalAndOp> <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::BinaryOp {
            op: BinaryOp::LogicalOr,
            lhs,
            rhs,
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
    },
    <LogicalAndOp>,
};

LogicalAndOp: ExprKey = {
    <l:@L> <lhs:LogicalAndOp> "&&" <rhs:Comparison> <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::BinaryOp {
            op: BinaryOp::LogicalAnd,
            lhs,
            rhs,
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
    },
    <Comparison>,
};

Comparison: ExprKey = {
    <l:@L> <lhs:Comparison> <op:RelOpOp> <rhs:InOp> <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::BinaryOp {
            op,
            lhs,
            rhs,
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
    },
    <InOp>,
};

RelOpOp: BinaryOp = {
    "==" => BinaryOp::Equal,
    "!=" => BinaryOp::NotEqual,
    "<" => BinaryOp::LessThan,
    "<=" => BinaryOp::LessThanOrEqual,
    ">" => BinaryOp::GreaterThan,
    ">=" => BinaryOp::GreaterThanOrEqual,
};

InOp: ExprKey = {
     <l:@L> <value:InOp> "in" <collection:Additive> <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::In {
            value,
            collection,
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
     },
     <l:@L> <value:InOp> "in" <collection:Range> <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::In {
            value,
            collection,
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
     },
    <Additive>,
};

Additive: ExprKey = {
    <l:@L> <lhs:Additive> <op:AddOpOp> <rhs:Multiplicative> <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::BinaryOp {
            op,
            lhs,
            rhs,
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
    },
    <Multiplicative>,
};

AddOpOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

Multiplicative: ExprKey = {
    <l:@L> <lhs:Multiplicative> <op:MultOpOp> <rhs:AsOp> <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::BinaryOp {
            op,
            lhs,
            rhs,
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
    },
    <AsOp>,
};

MultOpOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
};

AsOp: ExprKey = {
     <l:@L> <value:AsOp> "as" <ty:Type> <r:@R> => {
         context.ii.exprs.insert(
            Expr::Cast { value, ty: Box::new(ty), span: (context.span_from)(l, r) },
        )
     },
    <TupleFieldOp>,
};

TupleFieldOp: ExprKey = {
    <l:@L> <tuple:TupleFieldOp> "." <name:Ident> <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::TupleFieldAccess {
            tuple,
            field: TupleAccess::Name(name),
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
    },
    <l:@L> <tuple:TupleFieldOp> "." <m:@L> <num_str:"int_lit"> <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::TupleFieldAccess {
            tuple,
            field: num_str
                .parse::<usize>()
                .map(TupleAccess::Index)
                .unwrap_or_else(|_| {
                    // Recover with a malformed field access
                    errors.push(Error::Parse {
                        error: ParseError::InvalidIntegerTupleIndex {
                            span: (context.span_from)(m, r),
                            index: num_str.to_string(),
                        },
                    });
                    TupleAccess::Error
                }),
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
    },
    <l:@L> <tuple:TupleFieldOp> "." <m:@L> <num_str:"real_lit"> <r:@R> => {
        // <FMT_OPEN>
        match num_str.chars().position(|c| c == '.') {
            Some(dot_index) => {
                let first_index = num_str[0..dot_index]
                    .parse::<usize>()
                    .map(TupleAccess::Index)
                    .unwrap_or_else(|_| {
                        errors.push(Error::Parse {
                            error: ParseError::InvalidIntegerTupleIndex {
                                span: (context.span_from)(m, m + dot_index),
                                index: num_str[0..dot_index].to_string(),
                            },
                        });

                        // Recover with a malformed tuple access
                        TupleAccess::Error
                    });

                let second_index = num_str[(dot_index + 1)..]
                    .parse::<usize>()
                    .map(TupleAccess::Index)
                    .unwrap_or_else(|_| {
                        errors.push(Error::Parse {
                            error: ParseError::InvalidIntegerTupleIndex {
                                span: (context.span_from)(m + dot_index + 1, r),
                                index: num_str[(dot_index + 1)..].to_string(),
                            },
                        });

                        // Recover with a malformed tuple access
                        TupleAccess::Error
                    });

                let lhs_access_key = context.ii.exprs.insert(Expr::TupleFieldAccess {
                    tuple,
                    field: first_index,
                    span: (context.span_from)(l, m + dot_index),
                });

                context.ii.exprs.insert(Expr::TupleFieldAccess {
                    tuple: lhs_access_key,
                    field: second_index,
                    span: (context.span_from)(l, r),
                })
            }
            None => {
                errors.push(Error::Parse {
                    error: ParseError::InvalidTupleIndex {
                        span: (context.span_from)(m, r),
                        index: num_str.to_string(),
                    },
                });

                // Recover with a malformed tuple access
                context.ii.exprs.insert(Expr::TupleFieldAccess {
                    tuple,
                    field: TupleAccess::Error,
                    span: (context.span_from)(l, r),
                })
            }
        }
        // <FMT_CLOSE>
    },
    <ArrayElOp>,
};

ArrayElOp: ExprKey = {
    <l:@L> <array:ArrayElOp> "[" <index:Expr> "]" <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::ArrayElementAccess {
            array,
            index,
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
    },
    <l:@L> <array:ArrayElOp> "[" "]" <r:@R> => {
        // <FMT_OPEN>
        let span = (context.span_from)(l, r);
        errors.push(Error::Parse {
            error: ParseError::EmptyArrayAccess { span: span.clone() },
        });

        // Recover with a malformed expression
        context.ii.exprs.insert(Expr::Error(span))
        // <FMT_CLOSE>
    },
    <PrimeOp>,
};

PrimeOp: ExprKey = {
    <l:@L> <expr:PrimeOp> "'" <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::UnaryOp {
            op: UnaryOp::NextState,
            expr,
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
    },
    <UnaryOp>,
}

UnaryOp: ExprKey = {
    <l:@L> <op:UnaryOpOp> <expr:UnaryOp> <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::UnaryOp {
            op,
            expr,
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
    },
    <Term>,
};

UnaryOpOp: UnaryOp = {
    "+" => UnaryOp::Pos,
    "-" => UnaryOp::Neg,
    "!" => UnaryOp::Not,
};

Term: ExprKey = {
    <e:TermInner> => context.ii.exprs.insert(e),
    <CondExpr>,
    "(" <Expr> ")",
    <BlockExpr>,
};

TermInner: Expr = {
    <l:@L> <imm:Immediate> <r:@R> => {
        // <FMT_OPEN>
        Expr::Immediate {
            value: imm,
            span: (context.span_from)(l, r),
        }
        // <FMT_CLOSE>
    },
    <IfExpr>,
    <CallExpr>,
    <ArrayExpr>,
    <TupleExpr>,
    <l:@L> <path:Path> <r:@R> => Expr::PathByName(path, (context.span_from)(l, r)),
};

BlockDecl: () = {
    LetDecl ";",
    ConstraintDecl ";",
};

BlockExpr: ExprKey = {
    "{" BlockDecl* <Expr> "}"
};

IfExpr: Expr = {
    <l:@L> "if" <condition:Expr> <then_block:BlockExpr> "else" <else_block:BlockExpr> <r:@R> => {
        // <FMT_OPEN>
        Expr::If {
            condition,
            then_block,
            else_block,
            span: (context.span_from)(l, r),
        }
        // <FMT_CLOSE>
    }
}

CondBranch: (ExprKey, ExprKey) = {
    <condition:Expr> "=>" <result:Expr> "," => (condition, result)
};

ElseBranch: ExprKey = {
    "else" "=>" <else_result:Expr> ","? => else_result
};

CondExpr: ExprKey = {
    <l:@L> "cond" "{" <cond_branches: (<CondBranch>)*> <else_branch: ElseBranch> "}" <r:@R> => {
        // <FMT_OPEN>
        // De-sugar a `cond` into an `if/else` chain.
        //
        // Build the `if/else` chain starting with the else branch and going up,
        // hence the need to reverse the iterator below.
        cond_branches
            .iter()
            .rev()
            .fold(else_branch, |acc, (condition, result)| {
                context.ii.exprs.insert(Expr::If {
                    condition: *condition,
                    then_block: *result,
                    else_block: acc,
                    span: (context.span_from)(l, r),
                })
            })
        // <FMT_CLOSE>
    }
};

CallExpr: Expr = {
    <l:@L> <path:Path> "(" <args:SepList<Expr, ",">> ")" <r:@R> => {
        // <FMT_OPEN>
        Expr::Call {
            name: path,
            args,
            span: (context.span_from)(l, r),
        }
        // <FMT_CLOSE>
    },
};

ArrayExpr: Expr = {
    <l:@L> "[" <elements:SepList<Expr, ",">> "]" <r:@R> => {
        // <FMT_OPEN>
        Expr::Array {
            elements,
            span: (context.span_from)(l, r),
        }
        // <FMT_CLOSE>
    },
};

TupleExpr: Expr = {
    <l:@L> "{" <fields:TupleExprFields> "}" <r:@R> => {
        // <FMT_OPEN>
        Expr::Tuple {
            fields,
            span: (context.span_from)(l, r),
        }
        // <FMT_CLOSE>
    },
    <l:@L> "{" "}" <r:@R> => {
        // <FMT_OPEN>
        let span = (context.span_from)(l, r);
        errors.push(Error::Parse {
            error: ParseError::EmptyTupleExpr { span: span.clone() },
        });

        Expr::Error(span)
        // <FMT_CLOSE>
    },

};

TupleExprFields: Vec<(Option<Ident>, ExprKey)> = {
    <id:Ident> ":" <expr:Expr> => {
        // Special case for a single field with a field label which does not require the trailing
        // comma to distinguish it from a block expression.
        vec![(Some(id), expr)]
    },
    <Sep1List<TupleExprField, ",">>,
};

TupleExprField: (Option<Ident>, ExprKey) = {
    <id:(<Ident> ":")?> <expr:Expr> => (id, expr),
};

pub Range: ExprKey = {
    <l:@L> <lb:Additive> ".." <ub:Additive> <r:@R> => {
        // <FMT_OPEN>
        context.ii.exprs.insert(Expr::Range {
            lb,
            ub,
            span: (context.span_from)(l, r),
        })
        // <FMT_CLOSE>
    }
}

pub Path: types::Path = {
    <l:@L> "::" <els:(<Ident> "::")*> <last:Ident> <r:@R> => {
        // <FMT_OPEN>
        if !els.is_empty() {
            context
                .next_paths
                .push((true, els.iter().map(|el| el.to_string()).collect()));
        }
        let path = format!(
            "::{}{last}",
            els.iter()
                .map(|el| format!("{el}::"))
                .collect::<Vec<_>>()
                .concat()
        );
        path
        // <FMT_CLOSE>
    },

    <l:@L> <els:(<Ident> "::")*> <last:Ident> <r:@R> => {
        // <FMT_OPEN>
        // Check if any of the use statement matches the path. This requires
        // that the alias (if it exists) or the last ident in the use statement
        // matches the first ident in the path.
        // For example:
        // - `use a::b` and `b::c` match.
        // - `use a::b as d` and `d::e` match.
        let path_prefix = els
            .first()
            .map(|id| id.to_string())
            .unwrap_or_else(|| last.to_string());
        let full_absolute_path = context
            .use_paths
            .iter()
            .find(|use_path| use_path.matches_suffix(&path_prefix))
            .map(|use_path| {
                // We've found a use path which matches.  Construct a full path by joining the it
                // with the parsed path. `parsed_path_iter` is our parsed path except for the first
                // element.
                let parsed_path_iter = els
                    .iter()
                    .chain(std::iter::once(&last))
                    .skip(1)
                    .map(|el| el.to_string());

                let mut full_path = use_path
                    .path
                    .iter()
                    .cloned()
                    .chain(parsed_path_iter)
                    .collect::<Vec<_>>();

                let full_path_str = full_path
                    .iter()
                    .map(|el| format!("::{el}"))
                    .collect::<Vec<_>>()
                    .concat();

                // The next paths don't include the final element, only paths to modules.
                full_path.pop();
                context.next_paths.push((true, full_path));

                full_path_str
            })
            .unwrap_or_else(|| {
                // We didn't find a matching use path.  Just return the parsed path as is.
                if !els.is_empty() {
                    context
                        .next_paths
                        .push((false, els.iter().map(|el| el.to_string()).collect()));
                }
                format!(
                    "{}{}{last}",
                    context.mod_prefix,
                    els.iter()
                        .map(|el| format!("{el}::"))
                        .collect::<Vec<_>>()
                        .concat()
                )
            });

        full_absolute_path
        // <FMT_CLOSE>
    }
};

pub Immediate: Immediate = {
    ImmediateInt,
    <s:"real_lit"> => Immediate::Real(s.parse().unwrap()),
    "true" => Immediate::Bool(true),
    "false" => Immediate::Bool(false),
    <s:"str_lit"> => Immediate::String(s),
};

ImmediateInt: Immediate = {
    <s:"int_lit"> => {
        use num_traits::Num;

        let (radix, offset) = match s.chars().nth(1) {
            Some('b') => (2, 2),
            Some('x') => (16, 2),
            _ => (10, 0),
        };

        // Try to parse as an i64 first
        i64::from_str_radix(&s[offset..], radix)
            .map(Immediate::Int)
            .or_else(|_| {
                // Try a big-int if that fails and return an Immedate::BigInt.  The BigInt
                // FromStr::from_str() isn't smart about radices though.
                num_bigint::BigInt::from_str_radix(&s[offset..], radix)
                    .map(Immediate::BigInt)
            })
            .unwrap()
    }

};

// NEED TO BLOCK KEYWORDS.  If the keywords are in the lexer above ident then ident should never
// match them though.  It will do longest match, earliest match priority.  Need to test this.
// Maybe if ident is last in the token enum then it'll never match a keyword.
pub Ident: Ident = {
    <l:@L> <id:"ident"> <r:@R> => Ident {
        name: id.to_string(),
        span: (context.span_from)(l, r),
    }
};

/////////////
/// Utils ///
/////////////

// List of zero or more Ty separated by Sep, allowing a trailing Sep.
SepList<Ty, Sep>: Vec<Ty> = {
    <mut v: (<Ty> Sep)*> <e:Ty?> => {
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

// List of one or more Ty separated by Sep, allowing a trailing Sep.  The separator is required in
// the single element case.
Sep1List<Ty, Sep>: Vec<Ty> = {
    <mut v: (<Ty> Sep)+> <e:Ty?> => {
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

// List of one or more Ty separated by Sep, disallowing a trailing Sep.
Sep1ListNoTrail<Ty, Sep>: Vec<Ty> = {
    <mut v: (<Ty> Sep)*> <e:Ty> => {
        v.push(e);
        v
    }
};

/////////////
/// Lexer ///
/////////////

extern {
    type Location = usize;
    type Error = ParseError;

    enum lexer::Token<'sc> {
        ":" => lexer::Token::Colon,
        "::" => lexer::Token::DoubleColon,
        ";" => lexer::Token::Semi,
        "," => lexer::Token::Comma,
        "=" => lexer::Token::Eq,

        "==" => lexer::Token::EqEq,
        "!=" => lexer::Token::NotEq,
        "<" => lexer::Token::Lt,
        "<=" => lexer::Token::LtEq,
        ">" => lexer::Token::Gt,
        ">=" => lexer::Token::GtEq,

        "&&" => lexer::Token::DoubleAmpersand,
        "||" => lexer::Token::DoublePipe,

        "*" => lexer::Token::Star,
        "/" => lexer::Token::Div,
        "%" => lexer::Token::Mod,

        "+" => lexer::Token::Plus,
        "-" => lexer::Token::Minus,
        "!" => lexer::Token::Bang,
        "'" => lexer::Token::SingleQuote,

        "(" => lexer::Token::ParenOpen,
        ")" => lexer::Token::ParenClose,
        "{" => lexer::Token::BraceOpen,
        "}" => lexer::Token::BraceClose,
        "[" => lexer::Token::BracketOpen,
        "]" => lexer::Token::BracketClose,
        "->" => lexer::Token::Arrow,
        "=>" => lexer::Token::HeavyArrow,
        "." => lexer::Token::Dot,
        ".." => lexer::Token::TwoDots,
        "|" => lexer::Token::Pipe,

        "int_ty" => lexer::Token::Int,
        "real_ty" => lexer::Token::Real,
        "bool_ty" => lexer::Token::Bool,
        "string_ty" => lexer::Token::String,

        "int_lit" => lexer::Token::IntLiteral(<&'sc str>),
        "real_lit" => lexer::Token::RealLiteral(<&'sc str>),
        "str_lit" => lexer::Token::StringLiteral(<String>),

        "true" => lexer::Token::True,
        "false" => lexer::Token::False,

        "fn" => lexer::Token::Fn,
        "if" => lexer::Token::If,
        "else" => lexer::Token::Else,
        "cond" => lexer::Token::Cond,

        "use" => lexer::Token::Use,
        "let" => lexer::Token::Let,
        "state" => lexer::Token::State,
        "enum" => lexer::Token::Enum,
        "type" => lexer::Token::Type,
        "constraint" => lexer::Token::Constraint,
        "as" => lexer::Token::As,
        "interface" => lexer::Token::Interface,
        "contract" => lexer::Token::Contract,
        "implements" => lexer::Token::Implements,
        "extern" => lexer::Token::Extern,

        "solve" => lexer::Token::Solve,
        "satisfy" => lexer::Token::Satisfy,
        "minimize" => lexer::Token::Minimize,
        "maximize" => lexer::Token::Maximize,

        "in" => lexer::Token::In,

        "ident" => lexer::Token::Ident(<&'sc str>),
    }
}
