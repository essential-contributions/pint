use crate::{
    error::{Error, ParseError},
    expr::*,
    intermediate::{ExprKey, SolveFunc, IntermediateIntent},
    lexer,
    macros::{MacroCall, MacroDecl},
    parser::{ParserContext, UsePath, UseTree::{self, Path as UseTreePath}, NextModPath},
    types::{EnumDecl, Path, FnSig, NewTypeDecl, PrimitiveKind, Type},
    span,
};

grammar<'a>(
    context: &mut ParserContext<'a>,
    errors: &mut Vec<Error>,
);

pub Yurt: () = {
    Decl*,
};

////////////////////
/// Declarations ///
////////////////////

Decl: () = {
    IntentDecl,
    DeclBarringMacro,
    MacroDecl,
};

DeclBarringMacro: () = {
    UseStatement ";",
    LetDecl ";",
    StateDecl ";",
    ConstraintDecl ";",
    SolveDecl ";",
    EnumDecl ";",
    NewTypeDecl ";",
    MacroCallDecl ";",
};

pub IntentOpen: () = {
    <l:@L> "intent" <name:Ident> "{" <r:@R> => {
        context
            .iis
            .insert(name.to_string(), IntermediateIntent::default());
        *context.current_ii = name.to_string();
    }
}

pub IntentDecl: () = {
    <l:@L> IntentOpen DeclBarringMacro* IntentClose <r:@R> => { }
}

pub IntentClose: () = {
    <l:@L> "}" <r:@R> => {
        *context.current_ii = "".to_string();
    }
}

UseStatement: () = {
    "use" <l:@L> <abs:"::"?> <ut:UseTree> <r:@R> => {
        // Convert the use tree into use paths, prepend the current mod path prefix to each iff the
        // use tree is not absolute, and append to the current list of use paths in our context.
        let mut local_errors = Vec::new();
        let mut new_use_paths = ut
            .gather_paths()
            .into_iter()
            .filter_map(|mut use_path| {
                if abs.is_none() {
                    use_path.add_prefix(context.mod_path.to_vec());
                }

                // If any of the idents in the path, other than the last one, is a `self`,
                // immediately error out
                if use_path
                    .path
                    .iter()
                    .take(use_path.path.len() - 1)
                    .any(|elem| elem == "self")
                {
                    local_errors.push(Error::Parse {
                        error: ParseError::SelfNotAtTheEnd {
                            // We can use a better span here but that's okay for now. Ideally, we
                            // would use the span of the `self` ident itself, but we don't have that
                            // right now.
                            span: (context.span_from)(l, r),
                        },
                    });
                    return None;
                }

                // Paths that end in `self` get a special handling
                if use_path.path[use_path.path.len() - 1] == "self" {
                    // First, remove `self` because a path that ends in `self` is the same as its
                    // prefix For example: `a::b::self` is the same as `a::b`
                    use_path.path.pop();

                    // Paths with only `self` (i.e. nothing before it) are not valid
                    //
                    // Check that the prefix `use_path.path` matches the current `mod_path` because
                    // we may in a module other than the root module
                    if use_path.path == context.mod_path {
                        local_errors.push(Error::Parse {
                            error: ParseError::SelfWithEmptyPrefix {
                                span: use_path.span.clone(),
                            },
                        });
                        return None;
                    }
                }

                Some(use_path.clone())
            })
            .map(|use_path| {
                // This is a bit strange.  We're taking the alias or the last element of the use
                // path, prefixing it with the current mod path and inserting that as a top-level
                // symbol.  This is to avoid local decls clashing with the `use` path, though those
                // symbols are all absolute.
                //
                // e.g.,
                // use some::other::mod::a;       // Inserted as ::local::mod::a
                // let a: int;                    // Inserted as ::local::mod::a
                //
                // use some::other::mod::b as c;  // Inserted as ::local::mod::c
                // let c: int;                    // Inserted as ::local::mod::c
                //
                // There is one special case with `self` where the previous ident in the path is
                // considered instead. This is automatically handled by the `filter_map` above. For
                // example:
                //
                // use a::b::mod::my_mod::self;    // Inserted as ::local::mod::my_mod
                context
                    .iis
                    .get_mut(context.current_ii)
                    .unwrap()
                    .add_top_level_symbol(
                        context.mod_prefix,
                        None,
                        &Ident {
                            name: use_path
                                .alias
                                .clone()
                                .unwrap_or(use_path.path[use_path.path.len() - 1].clone()),
                            span: use_path.span.clone(),
                        },
                        use_path.span.clone(),
                    )
                    .map(|_| use_path.clone())
                    .unwrap_or_else(|error| {
                        errors.push(Error::Parse { error });
                        use_path
                    })
            })
            .collect::<Vec<_>>();

        errors.extend(local_errors);
        context.use_paths.append(&mut new_use_paths);
    }
};

pub UsePathIdent: Ident = {
    Ident,
    IdentFromToken<"self">,
    MacroName,
}

pub UseTree: UseTree = {
    <name:UsePathIdent> => UseTree::Name { name },
    <prefix:UsePathIdent> "::" <suffix:UseTree> => UseTreePath { prefix, suffix: Box::new(suffix) },
    "{" <imports:SepList<UseTree, ",">> "}" => UseTree::Group { imports },
    <name:UsePathIdent> "as" <alias:Ident> => UseTree::Alias { name, alias },
};

pub LetDecl: () = {
    <l:@L> "let" <let_name:LetName> ":" <ty:Type> <init:LetInit?> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .insert_var(context.mod_prefix, let_name.1, &let_name.0, Some(ty))
            .map(|var_key| {
                if let Some(expr_key) = init {
                    context
                        .iis
                        .get_mut(context.current_ii)
                        .unwrap()
                        .var_inits
                        .insert(var_key, expr_key);
                    context
                        .iis
                        .get_mut(context.current_ii)
                        .unwrap()
                        .insert_eq_or_ineq_constraint(var_key, expr_key, (context.span_from)(l, r));
                }
            })
            .unwrap_or_else(|error| {
                errors.push(Error::Parse { error });
            });
    },
    <l:@L> "let" <let_name:LetName> <init:LetInit> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .insert_var(context.mod_prefix, let_name.1, &let_name.0, None)
            .map(|var_key| {
                context
                    .iis
                    .get_mut(context.current_ii)
                    .unwrap()
                    .var_inits
                    .insert(var_key, init);
                context
                    .iis
                    .get_mut(context.current_ii)
                    .unwrap()
                    .insert_eq_or_ineq_constraint(var_key, init, (context.span_from)(l, r));
            })
            .unwrap_or_else(|error| {
                errors.push(Error::Parse { error });
            });
    },
    <l:@L> "let" <name:Ident> <r:@R> => {
        errors.push(Error::Parse {
            error: ParseError::UntypedVariable {
                name: name.name,
                span: (context.span_from)(l, r),
            },
        });
    }
};

LetName: (Ident, Option<&'a str>) = {
    <l:@L> <id:"ident"> <r:@R> => {
        // We special case the let name here, as we're interested in the associated flag (and this
        // is the only place where we care).  The flag indicates that this identifier was
        // substituted as a part of a macro argument during macro expansion.
        //
        // This is to implement macro body hygiene.
        //
        // If we have an identifier which is NOT from a macro arg AND a local prefix set in the
        // parser context indicating we're currently parsing a macro body, then we need to add a Use
        // path to make sure this name is referred to using that local prefix.  We're adding hygiene
        // using the prefix.

        let local_scope = (!id.1).then_some(()).and(context.local_scope);

        if let Some(prefix) = local_scope {
            let mut path = context.mod_path.to_vec();
            path.push(prefix.to_owned());
            path.push(id.0.to_owned());
            context.use_paths.push(UsePath {
                path,
                alias: None,
                is_absolute: true,
                span: span::empty_span(),
            });
        }

        let name = Ident {
            name: id.0.to_owned(),
            span: (context.span_from)(l, r),
        };

        (name, local_scope)
    }
};

LetInit: ExprKey = {
    "=" <Range>,
    "=" <Expr>,
};

pub StateDecl: () = {
    <l:@L> "state" <name:Ident> <ty:(":" <Type>)?> "=" <init:FnCallExpr> <r:@R> => {
        // Return the index to the new state in the IntermediateIntent::states Vec.
        let init_key = context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(init);
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .insert_state(
                context.mod_prefix,
                &name,
                ty,
                init_key,
                (context.span_from)(l, r),
            )
            .map(|_| ())
            .unwrap_or_else(|error| {
                errors.push(Error::Parse { error });
            });
    }
};

pub ConstraintDecl: () = {
    <l:@L> "constraint" <e:Expr> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .constraints
            .push((e, (context.span_from)(l, r)));
    }
};

pub SolveDecl: () = {
    <l:@L> <sd:SolveDeclInner> <r:@R> => {
        if let Some((_, prev_span)) = context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .directives
            .first()
        {
            errors.push(Error::Parse {
                error: ParseError::TooManySolveDirectives {
                    span: (context.span_from)(l, r),
                    prev_span: prev_span.clone(),
                },
            });
        } else if !context.mod_path.is_empty() {
            errors.push(Error::Parse {
                error: ParseError::SolveDirectiveMustBeTopLevel {
                    span: (context.span_from)(l, r),
                },
            });
        } else {
            context
                .iis
                .get_mut(context.current_ii)
                .unwrap()
                .directives
                .push((sd.clone(), (context.span_from)(l, r)));
        }
    }
}

SolveDeclInner: SolveFunc = {
    "solve" "satisfy" => SolveFunc::Satisfy,
    "solve" "minimize" <e:Expr> => SolveFunc::Minimize(e),
    "solve" "maximize" <e:Expr> => SolveFunc::Maximize(e),
};

pub EnumDecl: () = {
    <l:@L> "enum" <name:Ident> "=" <variants:Sep1ListNoTrail<Ident, "|">> <r:@R> => {
        let current_ii = context.current_ii.clone();
        let enum_decl = EnumDecl {
            name: context.add_top_level_symbol(&current_ii, name, context.mod_prefix, errors),
            variants,
            span: (context.span_from)(l, r),
        };
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .enums
            .push(enum_decl);
    }
}

pub NewTypeDecl: () = {
    <l:@L> "type" <name:Ident> "=" <ty:Type> <r:@R> => {
        let current_ii = context.current_ii.clone();
        let new_type_decl = NewTypeDecl {
            name: context.add_top_level_symbol(&current_ii, name, context.mod_prefix, errors),
            ty,
            span: (context.span_from)(l, r),
        };
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .new_types
            .push(new_type_decl);
    }
}

MacroName: Ident = IdentFromToken<"macro_name">;

pub MacroDecl: () = {
    "macro" <l:@L> <mut name:MacroName> "("
        <params:MacroParamList>
    ")" <r:@R>
    <body:"macro_body"> => {
        // Prefix the name with the module.  We can't use `add_top_level_symbol()` to do this as we
        // must avoid the regular name clash error we'd get with variadic macros.
        name.name = context.mod_prefix.to_string() + &name.name;
        context.macros.push(MacroDecl {
            name,
            params: params.0,
            pack: params.1,
            body,
            sig_span: (context.span_from)(l, r),
        });
    }
}

MacroParamList: (Vec<Ident>, Option<Ident>) = {
    <mut v: (<MacroParam> ",")*> <e:MacroParam>
    <p:("," <IdentFromToken<"macro_param_pack">>)?> ","? => {
        v.push(e);
        (v, p)
    }
}

MacroParam: Ident = IdentFromToken<"macro_param">;

MacroCallDecl: () = {
    MacroCallExpr => (),
}

pub MacroBody: Option<ExprKey> = {
    "{" DeclBarringMacro* <Expr?> "}"
}

FnParam: (Ident, Type)  = {
    <name:Ident> ":" <ty:Type> => (name, ty)
}

FnSig: FnSig = {
    <l:@L> "fn" <name:Ident> "(" <params:SepList<FnParam, ",">> ")"  "->" <return_type:Type> <r:@R> => {
        FnSig {
            name,
            params,
            return_type,
            span: (context.span_from)(l, r),
        }
    }
}

/////////////
/// Types ///
/////////////

pub Type: Type = {
    <ArrayType>,
    <TypeAtom>,
};

TypeAtom: Type = {
    <l:@L> <kind:PrimitiveType> <r:@R> => Type::Primitive {
        kind,
        span: (context.span_from)(l, r),
    },
    <l:@L> "{" <fields:TupleFields> "}" <r:@R> => {
        Type::Tuple {
            fields,
            span: (context.span_from)(l, r),
        }
    },
    <l:@L> "{" "}" <r:@R> => {
        let span = (context.span_from)(l, r);
        errors.push(Error::Parse {
            error: ParseError::EmptyTupleType { span: span.clone() },
        });

        // Recover with a malformed type
        Type::Error(span)
    },
    <l:@L> <path:Path> <r:@R> => Type::Custom {
        path,
        span: (context.span_from)(l, r),
    },
};

ArrayType: Type = {
    <l:@L> <ty:TypeAtom> <ranges: ("[" <Expr> "]")+ > <r:@R> => {
        // Multi-dimensional arrays have their innermost dimension on the far
        // right. Hence, we need to reverse the iterator.
        // For example, `int[3][5]` is actually an array of size 3 that
        // contains arrays of size 5 of `int`s.
        ranges.iter().rev().fold(ty, |acc, range| Type::Array {
            ty: Box::new(acc),
            range: *range,
            span: (context.span_from)(l, r),
        })
    },
    <l:@L> <ty:TypeAtom> "[" "]" <r:@R> => {
        let span = (context.span_from)(l, r);
        errors.push(Error::Parse {
            error: ParseError::EmptyArrayType { span: span.clone() },
        });

        // Recover with a malformed type
        Type::Error(span)
    },
};

PrimitiveType: PrimitiveKind = {
    "int_ty" => PrimitiveKind::Int,
    "real_ty" => PrimitiveKind::Real,
    "bool_ty" => PrimitiveKind::Bool,
    "string_ty" => PrimitiveKind::String,
    "b256_ty" => PrimitiveKind::B256,
}

TupleFields: Vec<(Option<Ident>, Type)> = {
    <field:TupleField> => vec![field],
    <Sep1List<TupleField, ",">>,
};

TupleField: (Option<Ident>, Type) = {
    <id:(<Ident> ":")?> <ty:Type> => (id, ty),
};

///////////////////
/// Expressions ///
///////////////////

pub Expr: ExprKey = {
    <LogicalOrOp>,
};

LogicalOrOp: ExprKey = {
    <l:@L> <lhs:LogicalOrOp> "||" <rhs:LogicalAndOp> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::BinaryOp {
                op: BinaryOp::LogicalOr,
                lhs,
                rhs,
                span: (context.span_from)(l, r),
            })
    },
    <LogicalAndOp>,
};

LogicalAndOp: ExprKey = {
    <l:@L> <lhs:LogicalAndOp> "&&" <rhs:Comparison> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::BinaryOp {
                op: BinaryOp::LogicalAnd,
                lhs,
                rhs,
                span: (context.span_from)(l, r),
            })
    },
    <Comparison>,
};

Comparison: ExprKey = {
    <l:@L> <lhs:Comparison> <op:RelOpOp> <rhs:InOp> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::BinaryOp {
                op,
                lhs,
                rhs,
                span: (context.span_from)(l, r),
            })
    },
    <InOp>,
};

RelOpOp: BinaryOp = {
    "==" => BinaryOp::Equal,
    "!=" => BinaryOp::NotEqual,
    "<" => BinaryOp::LessThan,
    "<=" => BinaryOp::LessThanOrEqual,
    ">" => BinaryOp::GreaterThan,
    ">=" => BinaryOp::GreaterThanOrEqual,
};

InOp: ExprKey = {
     <l:@L> <value:InOp> "in" <collection:Additive> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::In {
                value,
                collection,
                span: (context.span_from)(l, r),
            })
     },
     <l:@L> <value:InOp> "in" <collection:Range> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::In {
                value,
                collection,
                span: (context.span_from)(l, r),
            })
     },
    <Additive>,
};

Additive: ExprKey = {
    <l:@L> <lhs:Additive> <op:AddOpOp> <rhs:Multiplicative> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::BinaryOp {
                op,
                lhs,
                rhs,
                span: (context.span_from)(l, r),
            })
    },
    <Multiplicative>,
};

AddOpOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

Multiplicative: ExprKey = {
    <l:@L> <lhs:Multiplicative> <op:MultOpOp> <rhs:AsOp> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::BinaryOp {
                op,
                lhs,
                rhs,
                span: (context.span_from)(l, r),
            })
    },
    <AsOp>,
};

MultOpOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
};

AsOp: ExprKey = {
     <l:@L> <value:AsOp> "as" <ty:Type> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::Cast {
                value,
                ty: Box::new(ty),
                span: (context.span_from)(l, r),
            })
     },
    <TupleFieldOp>,
};

TupleFieldOp: ExprKey = {
    <l:@L> <tuple:TupleFieldOp> "." <name:Ident> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::TupleFieldAccess {
                tuple,
                field: TupleAccess::Name(name),
                span: (context.span_from)(l, r),
            })
    },
    <l:@L> <tuple:TupleFieldOp> "." <m:@L> <num_str:"int_lit"> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::TupleFieldAccess {
                tuple,
                field: num_str
                    .parse::<usize>()
                    .map(TupleAccess::Index)
                    .unwrap_or_else(|_| {
                        // Recover with a malformed field access
                        errors.push(Error::Parse {
                            error: ParseError::InvalidIntegerTupleIndex {
                                span: (context.span_from)(m, r),
                                index: num_str.to_string(),
                            },
                        });
                        TupleAccess::Error
                    }),
                span: (context.span_from)(l, r),
            })
    },
    <l:@L> <tuple:TupleFieldOp> "." <m:@L> <num_str:"real_lit"> <r:@R> => {
        match num_str.chars().position(|c| c == '.') {
            Some(dot_index) => {
                let first_index = num_str[0..dot_index]
                    .parse::<usize>()
                    .map(TupleAccess::Index)
                    .unwrap_or_else(|_| {
                        errors.push(Error::Parse {
                            error: ParseError::InvalidIntegerTupleIndex {
                                span: (context.span_from)(m, m + dot_index),
                                index: num_str[0..dot_index].to_string(),
                            },
                        });

                        // Recover with a malformed tuple access
                        TupleAccess::Error
                    });

                let second_index = num_str[(dot_index + 1)..]
                    .parse::<usize>()
                    .map(TupleAccess::Index)
                    .unwrap_or_else(|_| {
                        errors.push(Error::Parse {
                            error: ParseError::InvalidIntegerTupleIndex {
                                span: (context.span_from)(m + dot_index + 1, r),
                                index: num_str[(dot_index + 1)..].to_string(),
                            },
                        });

                        // Recover with a malformed tuple access
                        TupleAccess::Error
                    });

                let lhs_access_key = context
                    .iis
                    .get_mut(context.current_ii)
                    .unwrap()
                    .exprs
                    .insert(Expr::TupleFieldAccess {
                        tuple,
                        field: first_index,
                        span: (context.span_from)(l, m + dot_index),
                    });

                context
                    .iis
                    .get_mut(context.current_ii)
                    .unwrap()
                    .exprs
                    .insert(Expr::TupleFieldAccess {
                        tuple: lhs_access_key,
                        field: second_index,
                        span: (context.span_from)(l, r),
                    })
            }
            None => {
                errors.push(Error::Parse {
                    error: ParseError::InvalidTupleIndex {
                        span: (context.span_from)(m, r),
                        index: num_str.to_string(),
                    },
                });

                // Recover with a malformed tuple access
                context
                    .iis
                    .get_mut(context.current_ii)
                    .unwrap()
                    .exprs
                    .insert(Expr::TupleFieldAccess {
                        tuple,
                        field: TupleAccess::Error,
                        span: (context.span_from)(l, r),
                    })
            }
        }
    },
    <ArrayElOp>,
};

ArrayElOp: ExprKey = {
    <l:@L> <array:ArrayElOp> "[" <index:Expr> "]" <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::ArrayElementAccess {
                array,
                index,
                span: (context.span_from)(l, r),
            })
    },
    <l:@L> <array:ArrayElOp> "[" "]" <r:@R> => {
        let span = (context.span_from)(l, r);
        errors.push(Error::Parse {
            error: ParseError::EmptyArrayAccess { span: span.clone() },
        });

        // Recover with a malformed expression
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::Error(span))
    },
    <PrimeOp>,
};

PrimeOp: ExprKey = {
    <l:@L> <expr:PrimeOp> "'" <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::UnaryOp {
                op: UnaryOp::NextState,
                expr,
                span: (context.span_from)(l, r),
            })
    },
    <UnaryOp>,
}

UnaryOp: ExprKey = {
    <l:@L> <op:UnaryOpOp> <expr:UnaryOp> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::UnaryOp {
                op,
                expr,
                span: (context.span_from)(l, r),
            })
    },
    <Term>,
};

UnaryOpOp: UnaryOp = {
    <l:@L> "+" <r:@R> => {
        errors.push(Error::Parse {
            error: ParseError::UnsupportedLeadingPlus {
                span: (context.span_from)(l, r),
            },
        });
        UnaryOp::Error
    },
    "-" => UnaryOp::Neg,
    "!" => UnaryOp::Not,
};

Term: ExprKey = {
    <e:TermInner> => context.iis.get_mut(context.current_ii).unwrap().exprs.insert(e),
    <MacroCallExpr>,
    <CondExpr>,
    "(" <Expr> ")",
    <BlockExpr>,
};

TermInner: Expr = {
    <l:@L> <imm:Immediate> <r:@R> => {
        Expr::Immediate {
            value: imm,
            span: (context.span_from)(l, r),
        }
    },
    <IfExpr>,
    <ForAllExpr>,
    <FnCallExpr>,
    <ArrayExpr>,
    <TupleExpr>,
    <l:@L> <path:Path> <r:@R> => Expr::PathByName(path, (context.span_from)(l, r)),
};

BlockExpr: ExprKey = {
    "{" (ConstraintDecl ";")* <Expr> "}"
};

GeneratorRange: (Ident, ExprKey) = {
    <index:Ident> "in" <range:Range> => {
        // Generators for `forall` are always `int`s and need to be saved in the ephemeral list.
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .insert_ephemeral(
                context.mod_prefix,
                &index,
                Type::Primitive {
                    kind: PrimitiveKind::Int,
                    span: index.span.clone(),
                },
            )
            .unwrap_or_else(|error| {
                errors.push(Error::Parse { error });
            });
        (index, range)
    }
}

ForAllExpr: Expr = {
    <l:@L> "forall" <gen_ranges:Sep1ListNoTrail<GeneratorRange, ",">>
            <conditions: ("where" <Sep1ListNoTrail<Expr, ",">>)?>
            "{" <body:Expr> "}" <r:@R> => {
        Expr::ForAll {
            gen_ranges,
            conditions: conditions.unwrap_or_default(),
            body,
            span: (context.span_from)(l, r),
        }
    }
}

IfExpr: Expr = {
    <l:@L> "if" <condition:Expr> <then_block:BlockExpr> "else" <else_block:BlockExpr> <r:@R> => {
        Expr::If {
            condition,
            then_block,
            else_block,
            span: (context.span_from)(l, r),
        }
    }
}

CondBranch: (ExprKey, ExprKey) = {
    <condition:Expr> "=>" <result:Expr> "," => (condition, result)
};

ElseBranch: ExprKey = {
    "else" "=>" <else_result:Expr> ","? => else_result
};

CondExpr: ExprKey = {
    <l:@L> "cond" "{" <cond_branches: (<CondBranch>)*> <else_branch: ElseBranch> "}" <r:@R> => {
        // De-sugar a `cond` into an `if/else` chain.
        //
        // Build the `if/else` chain starting with the else branch and going up,
        // hence the need to reverse the iterator below.
        cond_branches
            .iter()
            .rev()
            .fold(else_branch, |acc, (condition, result)| {
                context
                    .iis
                    .get_mut(context.current_ii)
                    .unwrap()
                    .exprs
                    .insert(Expr::If {
                        condition: *condition,
                        then_block: *result,
                        else_block: acc,
                        span: (context.span_from)(l, r),
                    })
            })
    }
};

MacroCallExpr: ExprKey = {
    <l:@L> <name:MacroPath> <tag:"macro_tag"?> <args:"macro_call_args"> <r:@L> => {
        let call_key = context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .calls
            .insert(name.clone());
        let span = (context.span_from)(l, r);
        let call_data = MacroCall {
            name,
            mod_path: context.mod_path.to_vec(),
            args,
            span: span.clone(),
            tag: tag.flatten(),
        };
        let call_expr_key = context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::MacroCall {
                call: call_key,
                span,
            });
        context
            .macro_calls
            .insert(call_key, (call_expr_key, call_data));
        call_expr_key
    },
};

FnCallExpr: Expr = {
    <l:@L> <path:Path> "(" <args:SepList<Expr, ",">> ")" <r:@R> => {
        Expr::FnCall {
            name: path,
            args,
            span: (context.span_from)(l, r),
        }
    },
};

ArrayExpr: Expr = {
    <l:@L> "[" <il:@L> <elements:SepList<Expr, ",">> <ir:@R> "]" <r:@R> => {
        let range_expr = context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::Immediate {
                value: Immediate::Int(elements.len() as i64),
                span: (context.span_from)(il, ir),
            });
        Expr::Array {
            elements,
            range_expr,
            span: (context.span_from)(l, r),
        }
    },
};

TupleExpr: Expr = {
    <l:@L> "{" <fields:TupleExprFields> "}" <r:@R> => {
        Expr::Tuple {
            fields,
            span: (context.span_from)(l, r),
        }
    },
    <l:@L> "{" "}" <r:@R> => {
        let span = (context.span_from)(l, r);
        errors.push(Error::Parse {
            error: ParseError::EmptyTupleExpr { span: span.clone() },
        });

        Expr::Error(span)
    },

};

TupleExprFields: Vec<(Option<Ident>, ExprKey)> = {
    <id:Ident> ":" <expr:Expr> => {
        // Special case for a single field with a field label which does not require the trailing
        // comma to distinguish it from a block expression.
        vec![(Some(id), expr)]
    },
    <Sep1List<TupleExprField, ",">>,
};

TupleExprField: (Option<Ident>, ExprKey) = {
    <id:(<Ident> ":")?> <expr:Expr> => (id, expr),
};

pub Range: ExprKey = {
    <l:@L> <lb:Additive> ".." <ub:Additive> <r:@R> => {
        context
            .iis
            .get_mut(context.current_ii)
            .unwrap()
            .exprs
            .insert(Expr::Range {
                lb,
                ub,
                span: (context.span_from)(l, r),
            })
    }
}

pub Path: Path = {
    <PathWithLast<Ident>>,
};

MacroPath: Path = {
    <PathWithLast<IdentFromToken<"macro_name">>>,
};

PathWithLast<Last>: Path = {
    <l:@L> "::" <els:(<Ident> "::")*> <last:Last> <r:@R> => {
        if !els.is_empty() {
            let path: Vec<_> = els.iter().map(|el| el.to_string()).collect();
            context.next_paths.push(NextModPath {
                is_abs: true,
                mod_path_strs: path.clone(),
                suffix: last.to_string(),
                enum_path_strs: (path.len() > 1)
                    .then_some(path.iter().take(path.len() - 1).cloned().collect()),
                span: (context.span_from)(l, r),
            });
        }

        let path = format!(
            "::{}{last}",
            els.iter()
                .map(|el| format!("{el}::"))
                .collect::<Vec<_>>()
                .concat()
        );
        path
    },

    <l:@L> <els:(<Ident> "::")*> <last:Last> <r:@R> => {
        // Check if any of the use statement matches the path. This requires
        // that the alias (if it exists) or the last ident in the use statement
        // matches the first ident in the path.
        // For example:
        // - `use a::b` and `b::c` match.
        // - `use a::b as d` and `d::e` match.
        let path_prefix = els
            .first()
            .map(|id| id.to_string())
            .unwrap_or_else(|| last.to_string());
        let full_absolute_path = context
            .use_paths
            .iter()
            .find(|use_path| use_path.matches_suffix(&path_prefix))
            .map(|use_path| {
                // We've found a use path which matches.  Construct a full path by joining the it
                // with the parsed path. `parsed_path_iter` is our parsed path except for the first
                // element.
                let parsed_path_iter = els
                    .iter()
                    .chain(std::iter::once(&last))
                    .skip(1)
                    .map(|el| el.to_string());

                let mut full_path = use_path
                    .path
                    .iter()
                    .cloned()
                    .chain(parsed_path_iter)
                    .collect::<Vec<_>>();

                let full_path_str = full_path
                    .iter()
                    .map(|el| format!("::{el}"))
                    .collect::<Vec<_>>()
                    .concat();

                // The next paths don't include the final element, only paths to modules or enums.
                full_path.pop();
                context.next_paths.push(NextModPath {
                    is_abs: true,
                    mod_path_strs: full_path.clone(),
                    suffix: last.to_string(),
                    enum_path_strs: (full_path.len() > 1).then_some(
                        full_path
                            .iter()
                            .take(full_path.len() - 1)
                            .cloned()
                            .collect(),
                    ),
                    span: (context.span_from)(l, r),
                });

                full_path_str
            })
            .unwrap_or_else(|| {
                // We didn't find a matching use path.  Just return the parsed path as is.
                if !els.is_empty() {
                    let path: Vec<_> = els.iter().map(|el| el.to_string()).collect();
                    context.next_paths.push(NextModPath {
                        is_abs: false,
                        mod_path_strs: path.clone(),
                        suffix: last.to_string(),
                        enum_path_strs: (path.len() > 1)
                            .then_some(path.iter().take(path.len() - 1).cloned().collect()),
                        span: (context.span_from)(l, r),
                    });
                }
                format!(
                    "{}{}{last}",
                    context.mod_prefix,
                    els.iter()
                        .map(|el| format!("{el}::"))
                        .collect::<Vec<_>>()
                        .concat()
                )
            });

        full_absolute_path
    }
};

pub Immediate: Immediate = {
    ImmediateInt,
    <s:"real_lit"> => Immediate::Real(s.parse().unwrap()),
    "true" => Immediate::Bool(true),
    "false" => Immediate::Bool(false),
    <s:"str_lit"> => Immediate::String(s),
};

ImmediateInt: Immediate = {
    <l:@L> <s:"int_lit"> <r:@R>=> {
        let span = (context.span_from)(l, r);
        match s.chars().nth(1) {
            Some('b') => {
                let digits = s.len() - 2;
                match digits {
                    1..=63 => Immediate::Int(i64::from_str_radix(&s[2..], 2).unwrap()),
                    64 => {
                        // Full 64 bits are specified: check the MSB which represents the sign bit,
                        // and parse accordingly.
                        if &s[2..3] == "1" {
                            // Negative integer. Parse as `u64` then convert to `i64`.
                            Immediate::Int(u64::from_str_radix(&s[2..], 2).unwrap() as i64)
                        } else {
                            // Positive integer. Parse as `i64` directly.
                            Immediate::Int(i64::from_str_radix(&s[2..], 2).unwrap())
                        }
                    }
                    256 => {
                        let offset = 2;
                        Immediate::B256([
                            u64::from_str_radix(&s[offset..offset + 64], 2).unwrap(),
                            u64::from_str_radix(&s[offset + 64..offset + 128], 2).unwrap(),
                            u64::from_str_radix(&s[offset + 128..offset + 192], 2).unwrap(),
                            u64::from_str_radix(&s[offset + 192..offset + 256], 2).unwrap(),
                        ])
                    }
                    _ => {
                        errors.push(Error::Parse {
                            error: ParseError::BinaryLiteralLength {
                                digits,
                                span: span.clone(),
                            },
                        });
                        Immediate::Error
                    }
                }
            }
            Some('x') => {
                let digits = s.len() - 2;
                match digits {
                    1..=15 => Immediate::Int(i64::from_str_radix(&s[2..], 16).unwrap()),
                    16 => {
                        // Full 16 hex digits are specified: check the MSB which represents the sign
                        // bit, and parse accordingly.
                        match &s[2..3] {
                            // Negative integer. Parse as `u64` then convert to `i64`.
                            "8" | "9" | "a" | "A" | "b" | "B" | "c" | "C" | "d" | "D" | "e"
                            | "E" | "f" | "F" => {
                                Immediate::Int(u64::from_str_radix(&s[2..], 16).unwrap() as i64)
                            }
                            // Positive integer. Parse as `i64` directly.
                            _ => Immediate::Int(i64::from_str_radix(&s[2..], 16).unwrap()),
                        }
                    }
                    64 => {
                        let offset = 2;
                        Immediate::B256([
                            u64::from_str_radix(&s[offset..offset + 16], 16).unwrap(),
                            u64::from_str_radix(&s[offset + 16..offset + 32], 16).unwrap(),
                            u64::from_str_radix(&s[offset + 32..offset + 48], 16).unwrap(),
                            u64::from_str_radix(&s[offset + 48..offset + 64], 16).unwrap(),
                        ])
                    }
                    _ => {
                        errors.push(Error::Parse {
                            error: ParseError::HexLiteralLength {
                                digits,
                                span: span.clone(),
                            },
                        });
                        Immediate::Error
                    }
                }
            }
            _ => match s.parse::<i64>() {
                Ok(val) => Immediate::Int(val),
                Err(_) => {
                    errors.push(Error::Parse {
                        error: ParseError::IntLiteralTooLarge { span: span.clone() },
                    });
                    Immediate::Error
                }
            },
        }
    }
};

pub Ident: Ident = {
    <l:@L> <id:"ident"> <r:@R> => Ident {
        name: id.0.to_string(),
        span: (context.span_from)(l, r),
    }
}

IdentFromToken<Tok>: Ident = {
    <l:@L> <id:Tok> <r:@R> => Ident {
        name: id.to_string(),
        span: (context.span_from)(l, r),
    }
}

/////////////
/// Utils ///
/////////////

// List of zero or more Ty separated by Sep, allowing a trailing Sep.
SepList<Ty, Sep>: Vec<Ty> = {
    <mut v: (<Ty> Sep)*> <e:Ty?> => {
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

// List of one or more Ty separated by Sep, allowing a trailing Sep.  The separator is required in
// the single element case.
Sep1List<Ty, Sep>: Vec<Ty> = {
    <mut v: (<Ty> Sep)+> <e:Ty?> => {
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

// List of one or more Ty separated by Sep, disallowing a trailing Sep.
Sep1ListNoTrail<Ty, Sep>: Vec<Ty> = {
    <mut v: (<Ty> Sep)*> <e:Ty> => {
        v.push(e);
        v
    }
};

/////////////
/// Lexer ///
/////////////

extern {
    type Location = usize;
    type Error = ParseError;

    enum lexer::Token {
        ":" => lexer::Token::Colon,
        "::" => lexer::Token::DoubleColon,
        ";" => lexer::Token::Semi,
        "," => lexer::Token::Comma,
        "=" => lexer::Token::Eq,

        "==" => lexer::Token::EqEq,
        "!=" => lexer::Token::NotEq,
        "<" => lexer::Token::Lt,
        "<=" => lexer::Token::LtEq,
        ">" => lexer::Token::Gt,
        ">=" => lexer::Token::GtEq,

        "&&" => lexer::Token::DoubleAmpersand,
        "||" => lexer::Token::DoublePipe,

        "*" => lexer::Token::Star,
        "/" => lexer::Token::Div,
        "%" => lexer::Token::Mod,

        "+" => lexer::Token::Plus,
        "-" => lexer::Token::Minus,
        "!" => lexer::Token::Bang,
        "'" => lexer::Token::SingleQuote,

        "(" => lexer::Token::ParenOpen,
        ")" => lexer::Token::ParenClose,
        "{" => lexer::Token::BraceOpen,
        "}" => lexer::Token::BraceClose,
        "[" => lexer::Token::BracketOpen,
        "]" => lexer::Token::BracketClose,
        "->" => lexer::Token::Arrow,
        "=>" => lexer::Token::HeavyArrow,
        "." => lexer::Token::Dot,
        ".." => lexer::Token::TwoDots,
        "|" => lexer::Token::Pipe,

        "int_ty" => lexer::Token::Int,
        "real_ty" => lexer::Token::Real,
        "bool_ty" => lexer::Token::Bool,
        "string_ty" => lexer::Token::String,
        "b256_ty" => lexer::Token::B256,

        "int_lit" => lexer::Token::IntLiteral(<String>),
        "real_lit" => lexer::Token::RealLiteral(<String>),
        "str_lit" => lexer::Token::StringLiteral(<String>),

        "true" => lexer::Token::True,
        "false" => lexer::Token::False,

        "fn" => lexer::Token::Fn,
        "if" => lexer::Token::If,
        "else" => lexer::Token::Else,
        "cond" => lexer::Token::Cond,

        "use" => lexer::Token::Use,
        "self" => lexer::Token::SelfTok,
        "let" => lexer::Token::Let,
        "state" => lexer::Token::State,
        "enum" => lexer::Token::Enum,
        "type" => lexer::Token::Type,
        "constraint" => lexer::Token::Constraint,
        "as" => lexer::Token::As,
        "intent" => lexer::Token::Intent,

        "solve" => lexer::Token::Solve,
        "satisfy" => lexer::Token::Satisfy,
        "minimize" => lexer::Token::Minimize,
        "maximize" => lexer::Token::Maximize,

        "in" => lexer::Token::In,

        "forall" => lexer::Token::ForAll,
        "where" => lexer::Token::Where,

        "ident" => lexer::Token::Ident(<(String, bool)>),

        "macro" => lexer::Token::Macro,
        "macro_name" => lexer::Token::MacroName(<String>),
        "macro_param" => lexer::Token::MacroParam(<String>),
        "macro_param_pack" => lexer::Token::MacroParamPack(<String>),
        "macro_body" => lexer::Token::MacroBody(<Vec<(usize, lexer::Token, usize)>>),
        "macro_call_args" => lexer::Token::MacroCallArgs(<Vec<Vec<(usize, lexer::Token, usize)>>>),
        "macro_tag" => lexer::Token::MacroTag(<Option<u64>>),
    }
}
