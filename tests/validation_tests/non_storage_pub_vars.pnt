interface Baz {
    predicate Foo {
        pub var a: int;
        pub var b: bool;
        pub var c: b256;
        pub var d: int[3];
        pub var e: { int, b256 };
        pub var f: A;
        pub var g: A;
        pub var h: A;
        pub var i: A;
        pub var j: A;
        pub var k: A;
        pub var l: NewInt;
        pub var m: NewBool;
        pub var n: NewB256;
        pub var o: NewTuple;
        pub var p: NewArray;
    }
}

union A = a(int) | b | c(bool) | d(b256) | e({int, int}) | f(int[2]);
type NewInt = int;
type NewBool = bool;
type NewB256 = b256;
type NewTuple = { bool, int };
type NewArray = bool[4];


predicate Simple {
    pub var a: int;
    pub var b: bool;
    pub var c: b256;
    pub var d: int[3];
    pub var e: { int, b256 };
    pub var f: A;
    pub var g: A;
    pub var h: A;
    pub var i: A;
    pub var j: A;
    pub var k: A;
    pub var l: NewInt;
    pub var m: NewBool;
    pub var n: NewB256;
    pub var o: NewTuple;
    pub var p: NewArray;

    constraint a == 1;
    constraint a + a == 2;
    constraint b == true;
    constraint !b == false;
    constraint c == 0x0000000000000009000000000000000900000000000000090000000000000009;
    constraint d == [1, 2, 3];
    constraint e == { 30, 0x0000000000000001000000000000000100000000000000010000000000000001 };
    constraint f == A::a(1);
    constraint g == A::b;
    constraint h == A::c(false);
    constraint i == A::d(0x0000000000000004000000000000000400000000000000040000000000000004);
    constraint j == A::e({ 23, 33 });
    constraint k == A::f([48, 98]);
    constraint l == 1;
    constraint m != true;
    constraint n == 0x0000000000000001000000000000000200000000000000030000000000000004;
    constraint o == { true, 456 };
    constraint p == [true, false, true, false ];

    var foo_addr = 0x0000000000000000000000000000000000000000000000000000000000000000;
    interface BazInstance = Baz(0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE);
    predicate FooInstance = BazInstance::Foo(foo_addr);
    constraint FooInstance::a == 1;
    constraint FooInstance::a + FooInstance::a == 2;
    constraint FooInstance::b == true;
    constraint !FooInstance::b == false;
    constraint FooInstance::c == 0x0000000000000009000000000000000900000000000000090000000000000009;
    constraint FooInstance::d == [1, 2, 3];
    constraint FooInstance::e == { 30, 0x0000000000000001000000000000000100000000000000010000000000000001 };
    constraint FooInstance::f == A::a(1);
    constraint FooInstance::g == A::b;
    constraint FooInstance::h == A::c(false);
    constraint FooInstance::i == A::d(0x0000000000000004000000000000000400000000000000040000000000000004);
    constraint FooInstance::j == A::e({ 23, 33 });
    constraint FooInstance::k == A::f([48, 98]);
    constraint FooInstance::l == 1;
    constraint FooInstance::m != true;
    constraint FooInstance::n == 0x0000000000000001000000000000000200000000000000030000000000000004;
    constraint FooInstance::o == { true, 456 };
    constraint FooInstance::p == [true, false, true, false ];

    predicate FooSC = FooSameContract();
    constraint FooSC::a == 1;
    constraint FooSC::a + FooSC::a == 2;
    constraint FooSC::b == true;
    constraint !FooSC::b == false;
    constraint FooSC::c == 0x0000000000000009000000000000000900000000000000090000000000000009;
    constraint FooSC::d == [1, 2, 3];
    constraint FooSC::e == { 30, 0x0000000000000001000000000000000100000000000000010000000000000001 };
    constraint FooSC::f == A::a(1);
    constraint FooSC::g == A::b;
    constraint FooSC::h == A::c(false);
    constraint FooSC::i == A::d(0x0000000000000004000000000000000400000000000000040000000000000004);
    constraint FooSC::j == A::e({ 23, 33 });
    constraint FooSC::k == A::f([48, 98]);
    constraint FooSC::l == 1;
    constraint FooSC::m != true;
    constraint FooSC::n == 0x0000000000000001000000000000000200000000000000030000000000000004;
    constraint FooSC::o == { true, 456 };
    constraint FooSC::p == [true, false, true, false ];
}

predicate FooSameContract {
    pub var a: int;
    pub var b: bool;
    pub var c: b256;
    pub var d: int[3];
    pub var e: { int, b256 };
    pub var f: A;
    pub var g: A;
    pub var h: A;
    pub var i: A;
    pub var j: A;
    pub var k: A;
    pub var l: NewInt;
    pub var m: NewBool;
    pub var n: NewB256;
    pub var o: NewTuple;
    pub var p: NewArray;
    var nonce = 0;
}