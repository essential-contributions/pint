// db <<<
// 0, 42
// 1, 43
// 3, 1 1 1 1
// 6 0, 9
// >>>

storage {
    x: int,
    y: int,
    z: int,
    w: b256,
    t: { b256, int },
    a: int[2][3],
    t2: { int, int, { int, int } },
}

// Constraint set with address `0x0000000000000000000000000000000000000000000000000000000000000000`
predicate Foo() {
    let x = storage::x;
    let y = storage::y;
    let z = storage::z;
    let w = storage::w;
    let t = storage::t;
    let a = storage::a;
    let t2 = storage::t2;

    // `x` is set in the pre let db and in the solution
    constraint x != nil;
    constraint storage::x != nil;
    constraint storage::x := 42;

    // `y` is set in the pre let db and in the solution
    constraint nil != y;
    constraint nil != storage::y;
    constraint storage::y := 98;

    // `z` is not set in the pre let db but is set in the solution
    constraint z == nil;
    constraint storage::z == nil;
    constraint storage::z := 44;

    // `w` is set in the pre let db but unset in the solution
    constraint w != nil;
    constraint storage::w != nil;
    constraint storage::w := nil;

    // `t` is not set in the pre let db but is set in the solution
    constraint t == nil;
    constraint storage::t == nil;
    constraint storage::t := {
        0x0000000000000004000000000000000500000000000000060000000000000007, 8
    };

    // `a` is not set in the pre let db and is partially set in the solution.
    constraint a == nil;
    constraint storage::a == nil;
    constraint storage::a := [[0, 1, 2], [3, 4, 5]];

    // `t2` is partially set in the pre let db and is set to nil in the solution.
    constraint t2 != nil;
    constraint storage::t2 != nil;
    constraint storage::t2 := nil;
}
