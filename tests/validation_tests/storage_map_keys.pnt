union MyUnion = x | a(bool) | b(b256) | c(int) | d({ int, b256 }) | e({ b256, bool });
type MyAlias = MyUnion;

storage {
    a: (int => b256),
    b: (bool => int),
    c: (b256 => bool),
    d: ({ bool, int } => b256),
    e: ({ int, b256 } => bool),
    f: (MyUnion => int),
    g: (int[5] => int),
    h: ({ bool, int }[2][3] => int),
    i: (MyAlias => bool),
}

predicate Test() {
    constraint storage::a[25] := 0x0000000000000001000000000000000100000000000000010000000000000001;

    constraint storage::b[true] := 111;

    constraint storage::c[0x0000000000000002000000000000000300000000000000040000000000000005] := false;

    constraint storage::d[{ true, 30 }] := 0x0000000000000001000000000000000200000000000000030000000000000004;

    constraint storage::e[{ 490, 0x0000000000000009000000000000000800000000000000070000000000000006}] := true;

    constraint storage::f[MyUnion::d({ 576, 0x0000000000000003000000000000000400000000000000030000000000000004 })] := 652;

    constraint storage::g[[0, 1, 2, 3, 4]] := 10;

    constraint storage::h[[[{ false, 2 }, { true, 40 }, { false, 24 }], [{ true, 42 }, { false, 21 }, { false, 25 }]]] := 49;

    // TODO: Change to MyAlias when alias access for unions is supported
    constraint storage::i[MyUnion::a(false)] := false;
}
