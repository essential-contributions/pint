// db <<<
// 0, 69
// 1, 42
// >>>

storage {
    s1: int,
    s2: int,
}

predicate foo() {
    let y = 5555;
    let z = 3333;
    let w = 2222;

    let sum: int = asm(w, y, z) {
        PUSH 0 // store back result at this memory location

        PUSH 0
        LOD // load w
        PUSH 1
        LOD // load y
        ADD
        PUSH 2
        LOD // load z
        ADD
       
        PUSH 1 
        FREE // keep only 1 word
        STO
    };

    constraint sum == w + y + z;

    let equal: bool = asm({ w, y, z }, w, y, z) {
        PUSH 0 // store back result at this memory location

        PUSH 0
        PUSH 3
        LODR // load { w, y, z }
        PUSH 3
        LOD // load w
        PUSH 4
        LOD // load y
        PUSH 5
        LOD // load z
        PUSH 3
        EQRA

        PUSH 1 
        FREE // keep only 1 word
        STO
    };

    constraint equal;

    let load_s: int = asm(storage::s2'!) {
        PUSH 0 // store back result at this memory location

        // Memory starts with [ <storage::s2'!> ]

        PUSH 0 // storage key for `s1`
        PUSH 1 // key len for `s1`
        PUSH 1 // num keys for `s1`
        PUSH 3 
        ALOC   // allocate 3 words mem_addr for `s1`: addr, len, value
        KRNG
        // Now the memory looks like: [ <storage::s2'!>, 3, 1, 69 ]

        PUSH 3 
        LOD    // load from mem index 3 wat this memory location the data lives
                
        PUSH 0
        LOD    // load storage::s2'!
        
        ADD

        PUSH 1 
        FREE // keep only 1 word
        STO
    };

    constraint load_s == mut storage::s1! + mut storage::s2'!;
    constraint load_s' == mut storage::s1'! + mut storage::s2'!;
}

// Diamond-shaped dependency graph 
predicate bar(z: int) {
    // i.e. let y = z_ * x + z;
    let y: int = asm(z_, x, z, w) {
        PUSH 0 // store back result at this memory location

        PUSH 0
        LOD // load z_
        PUSH 1
        LOD // load x
        MUL // z_ * x
        PUSH 2
        LOD // load z
        ADD // z_ * x + z
        PUSH 3
        LOD // load w
        MUL // (z_ * x + z) * w

        PUSH 1 
        FREE // keep only 1 word
        STO
    };

    // i.e. let x = z + 1;
    let x: int = asm(z_) {
        PUSH 0 // store back result at this memory location

        PUSH 0
        LOD // load z_
        PUSH 1
        ADD // z_ + 1

        PUSH 1 
        FREE // keep only 1 word
        STO
    };

    let w: int = asm(z_) {
        PUSH 0 // store back result at this memory location

        PUSH 0
        LOD // load z_
        PUSH 2
        MUL // z_ * 2

        PUSH 1 
        FREE // keep only 1 word
        STO
    };

    // i.e. let z_ = z;
    let z_: int =  asm() {
        PUSH 0 // store back result at this memory location

        PUSH 0
        PUSH 0
        PUSH 1
        DATA // load z

        PUSH 1 
        ALOC  // allocate memory for the returned data
        POP
        STO
    };

    constraint y == (z_ * x + z ) * w;

    // More expressively 
    constraint y == (z * (z + 1) + z ) * (z * 2);
}
