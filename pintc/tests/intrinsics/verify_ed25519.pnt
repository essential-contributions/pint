let hash0: b256;
let hash1: b256;
let hash2: b256;
let sig: { b256, b256 } = { hash0, hash1 };

let verify_ed25519_0: bool = __verify_ed25519(69, { hash0, hash1 }, hash2);


let x: int;
let verify_ed25519_1: bool = __verify_ed25519(x, sig, hash2);

let verify_ed25519_2: bool = __verify_ed25519({ 69, { x, x } }, sig, hash2);

let t: { int, bool, { b256, b256 } }; 
let verify_ed25519_3: bool = __verify_ed25519(t, sig, hash2);
let verify_ed25519_4: bool = __verify_ed25519(t.2, sig, hash2);

let y: int;
let verify_ed25519_5: bool = __verify_ed25519([1, 2, 3, x, y], sig, hash2);

let a: int[2][3][4];
let verify_ed25519_6: bool = __verify_ed25519(a, sig, hash2);
let verify_ed25519_7: bool = __verify_ed25519(a[1], sig, hash2);
let verify_ed25519_8: bool = __verify_ed25519(a[1][2], sig, hash2);
let verify_ed25519_9: bool = __verify_ed25519(a[1][2][3], sig, hash2);

solve satisfy;

// intermediate <<<,
// var ::hash0: b256;
// var ::hash1: b256;
// var ::hash2: b256;
// var ::sig: {b256, b256};
// var ::verify_ed25519_0: bool;
// var ::x: int;
// var ::verify_ed25519_1: bool;
// var ::verify_ed25519_2: bool;
// var ::t: {int, bool, {b256, b256}};
// var ::verify_ed25519_3: bool;
// var ::verify_ed25519_4: bool;
// var ::y: int;
// var ::verify_ed25519_5: bool;
// var ::a: int[4][3][2];
// var ::verify_ed25519_6: bool;
// var ::verify_ed25519_7: bool;
// var ::verify_ed25519_8: bool;
// var ::verify_ed25519_9: bool;
// constraint (::sig == {::hash0, ::hash1});
// constraint (::verify_ed25519_0 == __verify_ed25519(69, {::hash0, ::hash1}, ::hash2));
// constraint (::verify_ed25519_1 == __verify_ed25519(::x, ::sig, ::hash2));
// constraint (::verify_ed25519_2 == __verify_ed25519({69, {::x, ::x}}, ::sig, ::hash2));
// constraint (::verify_ed25519_3 == __verify_ed25519(::t, ::sig, ::hash2));
// constraint (::verify_ed25519_4 == __verify_ed25519(::t.2, ::sig, ::hash2));
// constraint (::verify_ed25519_5 == __verify_ed25519([1, 2, 3, ::x, ::y], ::sig, ::hash2));
// constraint (::verify_ed25519_6 == __verify_ed25519(::a, ::sig, ::hash2));
// constraint (::verify_ed25519_7 == __verify_ed25519(::a[1], ::sig, ::hash2));
// constraint (::verify_ed25519_8 == __verify_ed25519(::a[1][2], ::sig, ::hash2));
// constraint (::verify_ed25519_9 == __verify_ed25519(::a[1][2][3], ::sig, ::hash2));
// solve satisfy;
// >>>

// flattened <<<,
// var ::hash0: b256;
// var ::hash1: b256;
// var ::hash2: b256;
// var ::verify_ed25519_0: int;
// var ::x: int;
// var ::verify_ed25519_1: int;
// var ::verify_ed25519_2: int;
// var ::verify_ed25519_3: int;
// var ::verify_ed25519_4: int;
// var ::y: int;
// var ::verify_ed25519_5: int;
// var ::a[0][1][0]: int;
// var ::verify_ed25519_6: int;
// var ::verify_ed25519_7: int;
// var ::verify_ed25519_8: int;
// var ::verify_ed25519_9: int;
// var ::a[0][0][0]: int;
// var ::a[1][0][0]: int;
// var ::a[0][2][0]: int;
// var ::a[1][1][0]: int;
// var ::a[0][0][1]: int;
// var ::a[0][0][2]: int;
// var ::a[0][0][3]: int;
// var ::a[1][2][0]: int;
// var ::sig.0: b256;
// var ::a[1][0][1]: int;
// var ::a[1][0][2]: int;
// var ::a[1][0][3]: int;
// var ::a[0][1][1]: int;
// var ::a[0][1][2]: int;
// var ::a[0][1][3]: int;
// var ::a[0][2][1]: int;
// var ::a[0][2][2]: int;
// var ::a[0][2][3]: int;
// var ::a[1][1][1]: int;
// var ::a[1][1][2]: int;
// var ::a[1][1][3]: int;
// var ::a[1][2][1]: int;
// var ::a[1][2][2]: int;
// var ::a[1][2][3]: int;
// var ::sig.1: b256;
// var ::t.0: int;
// var ::t.1: int;
// var ::t.2.0: b256;
// var ::t.2.1: b256;
// constraint ((::sig.0 == ::hash0) && (::sig.1 == ::hash1));
// constraint (::verify_ed25519_0 == __verify_ed25519(69, {::hash0, ::hash1}, ::hash2));
// constraint (::verify_ed25519_1 == __verify_ed25519(::x, {::sig.0, ::sig.1}, ::hash2));
// constraint (::verify_ed25519_2 == __verify_ed25519({69, {::x, ::x}}, {::sig.0, ::sig.1}, ::hash2));
// constraint (::verify_ed25519_3 == __verify_ed25519({::t.0, ::t.1, {::t.2.0, ::t.2.1}}, {::sig.0, ::sig.1}, ::hash2));
// constraint (::verify_ed25519_4 == __verify_ed25519({::t.2.0, ::t.2.1}, {::sig.0, ::sig.1}, ::hash2));
// constraint (::verify_ed25519_5 == __verify_ed25519([1, 2, 3, ::x, ::y], {::sig.0, ::sig.1}, ::hash2));
// constraint (::verify_ed25519_6 == __verify_ed25519([[[::a[0][0][0], ::a[0][0][1], ::a[0][0][2], ::a[0][0][3]], [::a[0][1][0], ::a[0][1][1], ::a[0][1][2], ::a[0][1][3]], [::a[0][2][0], ::a[0][2][1], ::a[0][2][2], ::a[0][2][3]]], [[::a[1][0][0], ::a[1][0][1], ::a[1][0][2], ::a[1][0][3]], [::a[1][1][0], ::a[1][1][1], ::a[1][1][2], ::a[1][1][3]], [::a[1][2][0], ::a[1][2][1], ::a[1][2][2], ::a[1][2][3]]]], {::sig.0, ::sig.1}, ::hash2));
// constraint (::verify_ed25519_7 == __verify_ed25519([[::a[1][0][0], ::a[1][0][1], ::a[1][0][2], ::a[1][0][3]], [::a[1][1][0], ::a[1][1][1], ::a[1][1][2], ::a[1][1][3]], [::a[1][2][0], ::a[1][2][1], ::a[1][2][2], ::a[1][2][3]]], {::sig.0, ::sig.1}, ::hash2));
// constraint (::verify_ed25519_8 == __verify_ed25519([::a[1][2][0], ::a[1][2][1], ::a[1][2][2], ::a[1][2][3]], {::sig.0, ::sig.1}, ::hash2));
// constraint (::verify_ed25519_9 == __verify_ed25519(::a[1][2][3], {::sig.0, ::sig.1}, ::hash2));
// solve satisfy;
// >>>
