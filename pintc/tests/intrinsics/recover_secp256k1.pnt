var hash0: b256;
var hash1: b256;
var hash2: b256;
var sig_1: { b256, b256, int } = { hash1, hash2, 69 };

var recover_secp256k1_0: { b256, int } = __recover_secp256k1(hash0, { hash1, hash2, 69 });

var recover_secp256k1_1: { b256, int } = __recover_secp256k1(hash0, sig_1);

solve satisfy;

// parsed <<<,
// var ::hash0: b256;
// var ::hash1: b256;
// var ::hash2: b256;
// var ::sig_1: {b256, b256, int};
// var ::recover_secp256k1_0: {b256, int};
// var ::recover_secp256k1_1: {b256, int};
// constraint (::sig_1 == {::hash1, ::hash2, 69});
// constraint (::recover_secp256k1_0 == __recover_secp256k1(::hash0, {::hash1, ::hash2, 69}));
// constraint (::recover_secp256k1_1 == __recover_secp256k1(::hash0, ::sig_1));
// solve satisfy;
// >>>

// flattened <<<,
// var ::hash0: b256;
// var ::hash1: b256;
// var ::hash2: b256;
// var ::sig_1.0: b256;
// var ::sig_1.1: b256;
// var ::sig_1.2: int;
// var ::recover_secp256k1_0.0: b256;
// var ::recover_secp256k1_0.1: int;
// var ::recover_secp256k1_1.0: b256;
// var ::recover_secp256k1_1.1: int;
// constraint (((::sig_1.0 == ::hash1) && (::sig_1.1 == ::hash2)) && (::sig_1.2 == 69));
// constraint ({::recover_secp256k1_0.0, ::recover_secp256k1_0.1} == __recover_secp256k1(::hash0, {::hash1, ::hash2, 69}));
// constraint ({::recover_secp256k1_1.0, ::recover_secp256k1_1.1} == __recover_secp256k1(::hash0, {::sig_1.0, ::sig_1.1, ::sig_1.2}));
// solve satisfy;
// >>>
