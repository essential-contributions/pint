var hash0: b256;
var hash1: b256;
var hash2: b256;
var sig_1: { b256, b256, int } = { hash1, hash2, 69 };

var recover_secp256k1_0: { b256, int } = __recover_secp256k1(hash0, { hash1, hash2, 69 });

var recover_secp256k1_1: { b256, int } = __recover_secp256k1(hash0, sig_1);

solve satisfy;

// parsed <<<,
// var ::hash0: b256;
// var ::hash1: b256;
// var ::hash2: b256;
// var ::sig_1: {b256, b256, int};
// var ::recover_secp256k1_0: {b256, int};
// var ::recover_secp256k1_1: {b256, int};
// constraint (::sig_1 == {::hash1, ::hash2, 69});
// constraint (::recover_secp256k1_0 == __recover_secp256k1(::hash0, {::hash1, ::hash2, 69}));
// constraint (::recover_secp256k1_1 == __recover_secp256k1(::hash0, ::sig_1));
// solve satisfy;
// >>>

// flattened <<<,
// var ::hash0: b256;
// var ::hash1: b256;
// var ::hash2: b256;
// var ::sig_1: {b256, b256, int};
// var ::recover_secp256k1_0: {b256, int};
// var ::recover_secp256k1_1: {b256, int};
// constraint (::sig_1 == {::hash1, ::hash2, 69});
// constraint (::recover_secp256k1_0 == __recover_secp256k1(::hash0, {::hash1, ::hash2, 69}));
// constraint (::recover_secp256k1_1 == __recover_secp256k1(::hash0, ::sig_1));
// solve satisfy;
// >>>
