use module::__x;

storage {
    __y: int,
}
interface __MyInterface {
    storage {}
}
type T = { __x: int, y: bool };

enum ___E = A | B;
type __MyType = int;
var __x = 5;

constraint __x == 0;

solve satisfy;

// parse_failure <<<
// expected identifier, found intrinsic name `__x`
// @12..15: expected identifier, found intrinsic name
// names that start with `__` are reserved for compiler intrinsics
// expected identifier, found intrinsic name `__y`
// @32..35: expected identifier, found intrinsic name
// names that start with `__` are reserved for compiler intrinsics
// expected identifier, found intrinsic name `__MyInterface`
// @54..67: expected identifier, found intrinsic name
// names that start with `__` are reserved for compiler intrinsics
// expected identifier, found intrinsic name `__x`
// @98..101: expected identifier, found intrinsic name
// names that start with `__` are reserved for compiler intrinsics
// expected identifier, found intrinsic name `___E`
// @125..129: expected identifier, found intrinsic name
// names that start with `__` are reserved for compiler intrinsics
// expected identifier, found intrinsic name `__MyType`
// @144..152: expected identifier, found intrinsic name
// names that start with `__` are reserved for compiler intrinsics
// expected identifier, found intrinsic name `__x`
// @164..167: expected identifier, found intrinsic name
// names that start with `__` are reserved for compiler intrinsics
// symbol `__x` has already been declared
// @12..15: previous declaration of the symbol `__x` here
// @164..167: `__x` redeclared here
// `__x` must be declared or imported only once in this scope
// expected identifier, found intrinsic name `__x`
// @185..188: expected identifier, found intrinsic name
// names that start with `__` are reserved for compiler intrinsics
// >>> 
