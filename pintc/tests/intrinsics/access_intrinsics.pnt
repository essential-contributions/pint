predicate test {
    var mut_keys_len: int = __mut_keys_len();

    var key: int[5];
    var mut_keys_contains_1: bool = __mut_keys_contains(key);

    var z: int;
    var t: { int, int };
    var mut_keys_contains_2: bool = __mut_keys_contains([69, 70, 71, z, t.0]);

    var this_address: b256 = __this_address();

    var this_set_address: b256 = __this_set_address();

    var this_pathway: int = __this_pathway();
}

// parsed <<<,
// predicate ::test {
//     var ::mut_keys_len: int;
//     var ::key: int[5];
//     var ::mut_keys_contains_1: bool;
//     var ::z: int;
//     var ::t: {int, int};
//     var ::mut_keys_contains_2: bool;
//     var ::this_address: b256;
//     var ::this_set_address: b256;
//     var ::this_pathway: int;
//     constraint (::mut_keys_len == __mut_keys_len());
//     constraint (::mut_keys_contains_1 == __mut_keys_contains(::key));
//     constraint (::mut_keys_contains_2 == __mut_keys_contains([69, 70, 71, ::z, ::t.0]));
//     constraint (::this_address == __this_address());
//     constraint (::this_set_address == __this_set_address());
//     constraint (::this_pathway == __this_pathway());
// }
// >>>

// flattened <<<,
// predicate ::test {
//     var ::mut_keys_len: int;
//     var ::key: int[5];
//     var ::mut_keys_contains_1: bool;
//     var ::z: int;
//     var ::t: {int, int};
//     var ::mut_keys_contains_2: bool;
//     var ::this_address: b256;
//     var ::this_set_address: b256;
//     var ::this_pathway: int;
//     constraint (::mut_keys_len == __mut_keys_len());
//     constraint (::mut_keys_contains_1 == __mut_keys_contains(::key));
//     constraint (::mut_keys_contains_2 == __mut_keys_contains([69, 70, 71, ::z, ::t.0]));
//     constraint (::this_address == __this_address());
//     constraint (::this_set_address == __this_set_address());
//     constraint (::this_pathway == __this_pathway());
// }
// >>>
