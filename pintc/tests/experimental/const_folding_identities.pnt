predicate Test {
    var x: real;

    var a = 0.0 + x;
    var b = x + 0.0;
    var c = x - 0.0;
    var d = 0.0 * x;
    var e = x * 0.0;
    var f = 0.0 / x - 0.0;
    var g = x / 1.0;
    var h = x % 1.0;
    var i = (0.0 + x) + (x - 0.0);
    var j = (x + 0.0) * (0.0 * x);
    var k = (x - 0.0) / (x / 1.0);
    var l = (0.0 * x) + (x % 1.0);
    var m = (x * 0.0) - (0.0 + x);
    var n = (0.0 / x) - (0.0 * x);
    var o = (x / 1.0) + (x - 0.0);
    var p = (x % 1.0) * (0.0 + x);
}

// parsed <<<
// predicate ::Test {
//     var ::x: real;
//     var ::a;
//     var ::b;
//     var ::c;
//     var ::d;
//     var ::e;
//     var ::f;
//     var ::g;
//     var ::h;
//     var ::i;
//     var ::j;
//     var ::k;
//     var ::l;
//     var ::m;
//     var ::n;
//     var ::o;
//     var ::p;
//     constraint (::a == (0e0 + ::x));
//     constraint (::b == (::x + 0e0));
//     constraint (::c == (::x - 0e0));
//     constraint (::d == (0e0 * ::x));
//     constraint (::e == (::x * 0e0));
//     constraint (::f == ((0e0 / ::x) - 0e0));
//     constraint (::g == (::x / 1e0));
//     constraint (::h == (::x % 1e0));
//     constraint (::i == ((0e0 + ::x) + (::x - 0e0)));
//     constraint (::j == ((::x + 0e0) * (0e0 * ::x)));
//     constraint (::k == ((::x - 0e0) / (::x / 1e0)));
//     constraint (::l == ((0e0 * ::x) + (::x % 1e0)));
//     constraint (::m == ((::x * 0e0) - (0e0 + ::x)));
//     constraint (::n == ((0e0 / ::x) - (0e0 * ::x)));
//     constraint (::o == ((::x / 1e0) + (::x - 0e0)));
//     constraint (::p == ((::x % 1e0) * (0e0 + ::x)));
// }
// >>>

// flattened <<<
// predicate ::Test {
//     var ::x: real;
//     var ::a: real;
//     var ::b: real;
//     var ::c: real;
//     var ::d: real;
//     var ::e: real;
//     var ::f: real;
//     var ::g: real;
//     var ::h: real;
//     var ::i: real;
//     var ::j: real;
//     var ::k: real;
//     var ::l: real;
//     var ::m: real;
//     var ::n: real;
//     var ::o: real;
//     var ::p: real;
//     constraint (::a == (0e0 + ::x));
//     constraint (::b == (::x + 0e0));
//     constraint (::c == (::x - 0e0));
//     constraint (::d == (0e0 * ::x));
//     constraint (::e == (::x * 0e0));
//     constraint (::f == ((0e0 / ::x) - 0e0));
//     constraint (::g == (::x / 1e0));
//     constraint (::h == (::x % 1e0));
//     constraint (::i == ((0e0 + ::x) + (::x - 0e0)));
//     constraint (::j == ((::x + 0e0) * (0e0 * ::x)));
//     constraint (::k == ((::x - 0e0) / (::x / 1e0)));
//     constraint (::l == ((0e0 * ::x) + (::x % 1e0)));
//     constraint (::m == ((::x * 0e0) - (0e0 + ::x)));
//     constraint (::n == ((0e0 / ::x) - (0e0 * ::x)));
//     constraint (::o == ((::x / 1e0) + (::x - 0e0)));
//     constraint (::p == ((::x % 1e0) * (0e0 + ::x)));
//     constraint __eq_set(__mut_keys(), {0});
// }
// >>>

// optimized <<<
// predicate ::Test {
//     var ::x: real;
//     var ::a: real;
//     var ::b: real;
//     var ::c: real;
//     var ::d: real;
//     var ::e: real;
//     var ::f: real;
//     var ::g: real;
//     var ::h: real;
//     var ::i: real;
//     var ::j: real;
//     var ::k: real;
//     var ::l: real;
//     var ::m: real;
//     var ::n: real;
//     var ::o: real;
//     var ::p: real;
//     constraint (::a == ::x);
//     constraint (::b == ::x);
//     constraint (::c == ::x);
//     constraint (::d == 0e0);
//     constraint (::e == 0e0);
//     constraint (::f == 0e0);
//     constraint (::g == ::x);
//     constraint (::h == ::x);
//     constraint (::i == (::x + ::x));
//     constraint (::j == 0e0);
//     constraint (::k == (::x / ::x));
//     constraint (::l == ::x);
//     constraint (::m == (0e0 - ::x));
//     constraint (::n == 0e0);
//     constraint (::o == (::x + ::x));
//     constraint (::p == (::x * ::x));
//     constraint __eq_set(__mut_keys(), {0});
// }
// >>>