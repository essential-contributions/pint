use lib::ERC20_2;
use ::lib::ERC20_1;

storage {
    x: int,
    y: bool,
    map: (int => (int => b256)),
}

interface ERC20_0 {
    storage {
        x: int,
        y: bool,
        map: (int => (int => b256)),
    }
}

predicate Foo() {
    let addr0 = 0x0000000000000000000000000000000000000000000000000000000000000000;
    let addr1 = 0x1111111111111111111111111111111111111111111111111111111111111111;
    let addr2 = 0x2222222222222222222222222222222222222222222222222222222222222222;

    let internal_x = storage::x;
    let internal_y = storage::y;
    let internal_map = storage::map[3][4];

    let external_x_0 = ::ERC20_0@[addr0]::storage::x;
    let external_y_0 = ERC20_0@[addr0]::storage::y;
    let external_map_0 = ERC20_0@[addr0]::storage::map[3][4];

    let external_x_1 = ERC20_1@[addr1]::storage::x;
    let external_y_1 = ERC20_1@[addr1]::storage::y;
    let external_map_1 = ERC20_1@[addr1]::storage::map[3][4];

    let external_x_2 = lib::ERC20_2@[addr2]::storage::x;
    let external_y_2 = lib::ERC20_2@[addr2]::storage::y;
    let external_map_2 = lib::ERC20_2@[addr2]::storage::map[3][4];
}

predicate Bar() {
    let addr0 = 0x0000000000000000000000000000000000000000000000000000000000000000;
    let addr1 = 0x1111111111111111111111111111111111111111111111111111111111111111;
    let addr2 = 0x2222222222222222222222222222222222222222222222222222222222222222;

    let internal_x = storage::x;
    let internal_y = storage::y;
    let internal_map = storage::map[3][4];

    let external_x_0 = ::ERC20_0@[addr0]::storage::x;
    let external_y_0 = ERC20_0@[addr0]::storage::y;
    let external_map_0 = ERC20_0@[addr0]::storage::map[3][4];

    let external_x_1 = ::lib::ERC20_1@[addr1]::storage::x;
    let external_y_1 = ::lib::ERC20_1@[addr1]::storage::y;
    let external_map_1 = ::lib::ERC20_1@[addr1]::storage::map[3][4];

    let external_x_2 = ERC20_2@[addr2]::storage::x;
    let external_y_2 = ERC20_2@[addr2]::storage::y;
    let external_map_2 = ERC20_2@[addr2]::storage::map[3][4];
}

// parsed <<<
// storage {
//     x: int,
//     y: bool,
//     map: ( int => ( int => b256 ) ),
// }
// interface ::ERC20_0 {
//     storage {
//         x: int,
//         y: bool,
//         map: ( int => ( int => b256 ) ),
//     }
// }
// interface ::lib::ERC20_1 {
//     storage {
//         x: int,
//         y: bool,
//         map: ( int => ( int => b256 ) ),
//     }
// }
// interface ::lib::ERC20_2 {
//     storage {
//         x: int,
//         y: bool,
//         map: ( int => ( int => b256 ) ),
//     }
// }
// 
// predicate ::Foo(
// ) {
//     let ::addr0 = 0x0000000000000000000000000000000000000000000000000000000000000000;
//     let ::addr1 = 0x1111111111111111111111111111111111111111111111111111111111111111;
//     let ::addr2 = 0x2222222222222222222222222222222222222222222222222222222222222222;
//     let ::internal_x = storage::x;
//     let ::internal_y = storage::y;
//     let ::internal_map = storage::map[3][4];
//     let ::external_x_0 = ::ERC20_0@[::addr0]::storage::x;
//     let ::external_y_0 = ::ERC20_0@[::addr0]::storage::y;
//     let ::external_map_0 = ::ERC20_0@[::addr0]::storage::map[3][4];
//     let ::external_x_1 = ::lib::ERC20_1@[::addr1]::storage::x;
//     let ::external_y_1 = ::lib::ERC20_1@[::addr1]::storage::y;
//     let ::external_map_1 = ::lib::ERC20_1@[::addr1]::storage::map[3][4];
//     let ::external_x_2 = ::lib::ERC20_2@[::addr2]::storage::x;
//     let ::external_y_2 = ::lib::ERC20_2@[::addr2]::storage::y;
//     let ::external_map_2 = ::lib::ERC20_2@[::addr2]::storage::map[3][4];
// }
// 
// predicate ::Bar(
// ) {
//     let ::addr0 = 0x0000000000000000000000000000000000000000000000000000000000000000;
//     let ::addr1 = 0x1111111111111111111111111111111111111111111111111111111111111111;
//     let ::addr2 = 0x2222222222222222222222222222222222222222222222222222222222222222;
//     let ::internal_x = storage::x;
//     let ::internal_y = storage::y;
//     let ::internal_map = storage::map[3][4];
//     let ::external_x_0 = ::ERC20_0@[::addr0]::storage::x;
//     let ::external_y_0 = ::ERC20_0@[::addr0]::storage::y;
//     let ::external_map_0 = ::ERC20_0@[::addr0]::storage::map[3][4];
//     let ::external_x_1 = ::lib::ERC20_1@[::addr1]::storage::x;
//     let ::external_y_1 = ::lib::ERC20_1@[::addr1]::storage::y;
//     let ::external_map_1 = ::lib::ERC20_1@[::addr1]::storage::map[3][4];
//     let ::external_x_2 = ::lib::ERC20_2@[::addr2]::storage::x;
//     let ::external_y_2 = ::lib::ERC20_2@[::addr2]::storage::y;
//     let ::external_map_2 = ::lib::ERC20_2@[::addr2]::storage::map[3][4];
// }
// >>>

// flattened <<<
// storage {
//     x: int,
//     y: bool,
//     map: ( int => ( int => b256 ) ),
// }
// interface ::ERC20_0 {
//     storage {
//         x: int,
//         y: bool,
//         map: ( int => ( int => b256 ) ),
//     }
// }
// interface ::lib::ERC20_1 {
//     storage {
//         x: int,
//         y: bool,
//         map: ( int => ( int => b256 ) ),
//     }
// }
// interface ::lib::ERC20_2 {
//     storage {
//         x: int,
//         y: bool,
//         map: ( int => ( int => b256 ) ),
//     }
// }
// 
// predicate ::Foo(
// ) {
//     let ::addr0: b256 = 0x0000000000000000000000000000000000000000000000000000000000000000;
//     let ::addr1: b256 = 0x1111111111111111111111111111111111111111111111111111111111111111;
//     let ::addr2: b256 = 0x2222222222222222222222222222222222222222222222222222222222222222;
//     let ::internal_x: int = __storage_get({0});
//     let ::internal_y: bool = __storage_get({1});
//     let ::internal_map: b256 = __storage_get({2, 3, 4});
//     let ::external_x_0: int = __storage_get_extern(::addr0, {0});
//     let ::external_y_0: bool = __storage_get_extern(::addr0, {1});
//     let ::external_map_0: b256 = __storage_get_extern(::addr0, {2, 3, 4});
//     let ::external_x_1: int = __storage_get_extern(::addr1, {0});
//     let ::external_y_1: bool = __storage_get_extern(::addr1, {1});
//     let ::external_map_1: b256 = __storage_get_extern(::addr1, {2, 3, 4});
//     let ::external_x_2: int = __storage_get_extern(::addr2, {0});
//     let ::external_y_2: bool = __storage_get_extern(::addr2, {1});
//     let ::external_map_2: b256 = __storage_get_extern(::addr2, {2, 3, 4});
//     constraint __eq_set(__mut_keys(), {0});
// }
// 
// predicate ::Bar(
// ) {
//     let ::addr0: b256 = 0x0000000000000000000000000000000000000000000000000000000000000000;
//     let ::addr1: b256 = 0x1111111111111111111111111111111111111111111111111111111111111111;
//     let ::addr2: b256 = 0x2222222222222222222222222222222222222222222222222222222222222222;
//     let ::internal_x: int = __storage_get({0});
//     let ::internal_y: bool = __storage_get({1});
//     let ::internal_map: b256 = __storage_get({2, 3, 4});
//     let ::external_x_0: int = __storage_get_extern(::addr0, {0});
//     let ::external_y_0: bool = __storage_get_extern(::addr0, {1});
//     let ::external_map_0: b256 = __storage_get_extern(::addr0, {2, 3, 4});
//     let ::external_x_1: int = __storage_get_extern(::addr1, {0});
//     let ::external_y_1: bool = __storage_get_extern(::addr1, {1});
//     let ::external_map_1: b256 = __storage_get_extern(::addr1, {2, 3, 4});
//     let ::external_x_2: int = __storage_get_extern(::addr2, {0});
//     let ::external_y_2: bool = __storage_get_extern(::addr2, {1});
//     let ::external_map_2: b256 = __storage_get_extern(::addr2, {2, 3, 4});
//     constraint __eq_set(__mut_keys(), {0});
// }
// >>>
