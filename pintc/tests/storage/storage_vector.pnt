storage {
    v0: int[],
    v1: bool[],
    v2: b256[],
}

interface Bar {
    storage {
        u0: int[],
        u1: bool[],
        u2: b256[],
    }
}

predicate Foo() {
    let addr = 0x0000000000000000000000000000000000000000000000000000000000000000;
    let v0_0 = storage::v0[0];
    let v0_1 = storage::v0[1];
    let v1_1 = storage::v1[1];
    let v2_2 = storage::v2[2];

    constraint v0_0! == 0;
    constraint v0_1! == 0;
    constraint v0_0'! == 1;
    constraint v0_1'! == 1;

    let u0_0 = Bar@[addr]::storage::u0[0];
    let u0_1 = Bar@[addr]::storage::u0[1];
    let u1_1 = Bar@[addr]::storage::u1[1];
    let u2_2 = Bar@[addr]::storage::u2[2];

    constraint u0_0! == 0;
    constraint u0_1! == 0;
    constraint u0_0'! == 1;
    constraint u0_1'! == 1;

    constraint u1_1! == (1 == 1);
    constraint u2_2! == 0x0000000000000000000000000000000000000000000000000000000000000000;
    constraint v1_1! == (1 == 1);
    constraint v2_2! == 0x0000000000000000000000000000000000000000000000000000000000000000;
}

// parsed <<<
// storage {
//     v0: int[],
//     v1: bool[],
//     v2: b256[],
// }
// interface ::Bar {
//     storage {
//         u0: int[],
//         u1: bool[],
//         u2: b256[],
//     }
// }
//
// predicate ::Foo(
// ) {
//     let ::addr = 0x0000000000000000000000000000000000000000000000000000000000000000;
//     let ::v0_0 = storage::v0[0];
//     let ::v0_1 = storage::v0[1];
//     let ::v1_1 = storage::v1[1];
//     let ::v2_2 = storage::v2[2];
//     let ::u0_0 = ::Bar@[::addr]::storage::u0[0];
//     let ::u0_1 = ::Bar@[::addr]::storage::u0[1];
//     let ::u1_1 = ::Bar@[::addr]::storage::u1[1];
//     let ::u2_2 = ::Bar@[::addr]::storage::u2[2];
//     constraint (::v0_0! == 0);
//     constraint (::v0_1! == 0);
//     constraint (::v0_0'! == 1);
//     constraint (::v0_1'! == 1);
//     constraint (::u0_0! == 0);
//     constraint (::u0_1! == 0);
//     constraint (::u0_0'! == 1);
//     constraint (::u0_1'! == 1);
//     constraint (::u1_1! == (1 == 1));
//     constraint (::u2_2! == 0x0000000000000000000000000000000000000000000000000000000000000000);
//     constraint (::v1_1! == (1 == 1));
//     constraint (::v2_2! == 0x0000000000000000000000000000000000000000000000000000000000000000);
// }
// >>>

// flattened <<<
// storage {
//     v0: int[],
//     v1: bool[],
//     v2: b256[],
// }
// interface ::Bar {
//     storage {
//         u0: int[],
//         u1: bool[],
//         u2: b256[],
//     }
// }
//
// predicate ::Foo(
// ) {
//     let ::addr: b256 = 0x0000000000000000000000000000000000000000000000000000000000000000;
//     let ::v0_0: int? = ((0 < __pre_state({0})!) ? __pre_state({0, 0}) : __panic_if(true));
//     let ::v0_1: int? = ((1 < __pre_state({0})!) ? __pre_state({0, 1}) : __panic_if(true));
//     let ::v1_1: bool? = ((1 < __pre_state({1})!) ? __pre_state({1, 1}) : __panic_if(true));
//     let ::v2_2: b256? = ((2 < __pre_state({2})!) ? __pre_state({2, 2}) : __panic_if(true));
//     let ::u0_0: int? = ((0 < __pre_state_extern(::addr, {0})!) ? __pre_state_extern(::addr, {0, 0}) : __panic_if(true));
//     let ::u0_1: int? = ((1 < __pre_state_extern(::addr, {0})!) ? __pre_state_extern(::addr, {0, 1}) : __panic_if(true));
//     let ::u1_1: bool? = ((1 < __pre_state_extern(::addr, {1})!) ? __pre_state_extern(::addr, {1, 1}) : __panic_if(true));
//     let ::u2_2: b256? = ((2 < __pre_state_extern(::addr, {2})!) ? __pre_state_extern(::addr, {2, 2}) : __panic_if(true));
//     constraint (::v0_0! == 0);
//     constraint (::v0_1! == 0);
//     constraint (::v0_0'! == 1);
//     constraint (::v0_1'! == 1);
//     constraint (::u0_0! == 0);
//     constraint (::u0_1! == 0);
//     constraint (::u0_0'! == 1);
//     constraint (::u0_1'! == 1);
//     constraint (::u1_1! == (1 == 1));
//     constraint (::u2_2! == 0x0000000000000000000000000000000000000000000000000000000000000000);
//     constraint (::v1_1! == (1 == 1));
//     constraint (::v2_2! == 0x0000000000000000000000000000000000000000000000000000000000000000);
//     constraint __eq_set(__mut_keys(), {0});
// }
// >>>
