use b_mod::c_mod::A::{C, D};
use ::b_mod::c_mod::{A, A::B};

enum U = V | W;

predicate test {
    var s0 = B;
    var s1 = C;
    var s2 = A::B;
    var s3 = b_mod::c_mod::A::C;
    var s4 = ::b_mod::c_mod::A::B;

    constraint s0 == B;
    constraint s1 == C;
    constraint s2 == A::B;
    constraint s3 == b_mod::c_mod::A::C;
    constraint s4 == ::b_mod::c_mod::A::B;
}

// parsed <<<
// enum ::U = V | W;
// enum ::b_mod::c_mod::A = B | C | D;
//
// predicate ::test {
//     var ::s0;
//     var ::s1;
//     var ::s2;
//     var ::s3;
//     var ::s4;
//     constraint (::s0 == ::b_mod::c_mod::A::B);
//     constraint (::s1 == ::b_mod::c_mod::A::C);
//     constraint (::s2 == ::b_mod::c_mod::A::B);
//     constraint (::s3 == ::b_mod::c_mod::A::C);
//     constraint (::s4 == ::b_mod::c_mod::A::B);
//     constraint (::s0 == ::b_mod::c_mod::A::B);
//     constraint (::s1 == ::b_mod::c_mod::A::C);
//     constraint (::s2 == ::b_mod::c_mod::A::B);
//     constraint (::s3 == ::b_mod::c_mod::A::C);
//     constraint (::s4 == ::b_mod::c_mod::A::B);
// }
// >>>

// flattened <<<
// enum ::U = V | W;
// enum ::b_mod::c_mod::A = B | C | D;
//
// predicate ::test {
//     var ::s0: int;
//     var ::s1: int;
//     var ::s2: int;
//     var ::s3: int;
//     var ::s4: int;
//     constraint (::s0 == 0);
//     constraint (::s1 == 1);
//     constraint (::s2 == 0);
//     constraint (::s3 == 1);
//     constraint (::s4 == 0);
//     constraint (::s0 == 0);
//     constraint (::s1 == 1);
//     constraint (::s2 == 0);
//     constraint (::s3 == 1);
//     constraint (::s4 == 0);
//     constraint (::s0 >= 0);
//     constraint (::s0 <= 2);
//     constraint (::s1 >= 0);
//     constraint (::s1 <= 2);
//     constraint (::s2 >= 0);
//     constraint (::s2 <= 2);
//     constraint (::s3 >= 0);
//     constraint (::s3 <= 2);
//     constraint (::s4 >= 0);
//     constraint (::s4 <= 2);
// }
// >>>
