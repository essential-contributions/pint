type myArray = int[2];
type myMultiDimArray = int[2][2];
type myArrayTuple = int[{3, 1}.0];
type myTuple = { x: int };
type myTupleArray = { x: int[5] };
type myNestedArrayTuple = { y: { z: int[{4, 1}.0] } };

predicate Foo {}

// flattened <<<
// type ::myArray = int[2];
// type ::myMultiDimArray = int[2][2];
// type ::myArrayTuple = int[{3, 1}.0];
// type ::myTuple = {x: int};
// type ::myTupleArray = {x: int[5]};
// type ::myNestedArrayTuple = {y: {z: int[{4, 1}.0]}};
//
// predicate ::Foo {
//     type ::myArray = int[2];
//     type ::myMultiDimArray = int[2][2];
//     type ::myArrayTuple = int[{3, 1}.0];
//     type ::myTuple = {x: int};
//     type ::myTupleArray = {x: int[5]};
//     type ::myNestedArrayTuple = {y: {z: int[{4, 1}.0]}};
// }
// >>>

// parsed <<<
// type ::myArray = int[2];
// type ::myMultiDimArray = int[2][2];
// type ::myArrayTuple = int[{3, 1}.0];
// type ::myTuple = {x: int};
// type ::myTupleArray = {x: int[5]};
// type ::myNestedArrayTuple = {y: {z: int[{4, 1}.0]}};
//
// predicate ::Foo {
//     type ::myArray = int[2];
//     type ::myMultiDimArray = int[2][2];
//     type ::myArrayTuple = int[{3, 1}.0];
//     type ::myTuple = {x: int};
//     type ::myTupleArray = {x: int[5]};
//     type ::myNestedArrayTuple = {y: {z: int[{4, 1}.0]}};
// }
// >>>
