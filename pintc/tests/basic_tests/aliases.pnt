type MyInt = int;
type MyReal = real;
type MyBool = bool;
type MyTuple = { int, int };
type MyArray = bool[5];
type MyMap = (b256 => int);
type MyB256 = b256;
type MyNestedAlias = MyInt;

storage {
    r: MyMap,
}

predicate test {
   var m: MyInt;
   var n: MyReal;
   var o: MyBool;
   var p: MyTuple;
   var q: MyArray;
   var s: MyB256;
   var x: MyNestedAlias;
}

// parsed <<<
// type ::MyInt = int;
// type ::MyReal = real;
// type ::MyBool = bool;
// type ::MyTuple = {int, int};
// type ::MyArray = bool[5];
// type ::MyMap = ( b256 => int );
// type ::MyB256 = b256;
// type ::MyNestedAlias = ::MyInt;
// storage {
//     r: ::MyMap,
// }
//
// predicate ::test {
//     var ::m: ::MyInt;
//     var ::n: ::MyReal;
//     var ::o: ::MyBool;
//     var ::p: ::MyTuple;
//     var ::q: ::MyArray;
//     var ::s: ::MyB256;
//     var ::x: ::MyNestedAlias;
// }
// >>>

// flattened <<<
// type ::MyInt = int;
// type ::MyReal = real;
// type ::MyBool = bool;
// type ::MyTuple = {int, int};
// type ::MyArray = bool[5];
// type ::MyMap = ( b256 => int );
// type ::MyB256 = b256;
// type ::MyNestedAlias = ::MyInt (int);
// storage {
//     r: ( b256 => int ),
// }
//
// predicate ::test {
//     var ::m: int;
//     var ::n: real;
//     var ::o: bool;
//     var ::p: {int, int};
//     var ::q: bool[5];
//     var ::s: b256;
//     var ::x: int;
// }
// >>>