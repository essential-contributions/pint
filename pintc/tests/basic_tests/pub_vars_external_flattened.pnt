enum MyEnum = A | B;
type MyType = MyEnum;

interface Contract {
    predicate Foo {
        pub var x1: bool;
        pub var x2: int;
        pub var x3: b256;
        pub var x5: { bool, int };
        pub var x6: int[5];

        pub var y1: bool;
        pub var y2: int;
        pub var y3: b256;
        pub var y5: { bool, int };
        pub var y6: int[5];
    }
}

predicate Foo {
    var addr1: b256;
    var addr2: b256;
    var addr3: b256;
    interface ContractI = Contract(addr1);

    predicate FooI = ContractI::Foo(addr2);
    constraint FooI::x1 == true;
    constraint FooI::x2 == 5;
    constraint FooI::x3 == 0x0000111100001111000011110000111100001111000011110000111100001111;
    constraint FooI::x5 == { true, 2 };
    constraint FooI::x6 == [ 1, 2, 3, 4, 5];

    predicate FooI2 = ContractI::Foo(addr3);
    constraint FooI2::y1 == true;
    constraint FooI2::y2 == 5;
    constraint FooI2::y3 == 0x0000111100001111000011110000111100001111000011110000111100001111;
    constraint FooI2::y5 == { true, 2 };
    constraint FooI2::y6 == [ 1, 2, 3, 4, 5];
}

// parsed <<<
// enum ::MyEnum = A | B;
// type ::MyType = ::MyEnum;
// interface ::Contract {
//     predicate Foo {
//         pub var x1: bool;
//         pub var x2: int;
//         pub var x3: b256;
//         pub var x5: {bool, int};
//         pub var x6: int[5];
//         pub var y1: bool;
//         pub var y2: int;
//         pub var y3: b256;
//         pub var y5: {bool, int};
//         pub var y6: int[5];
//     }
// }
// 
// predicate ::Foo {
//     interface ::ContractI = ::Contract(::addr1)
//     predicate ::FooI = ::ContractI::Foo(::addr2)
//     predicate ::FooI2 = ::ContractI::Foo(::addr3)
//     var ::addr1: b256;
//     var ::addr2: b256;
//     var ::addr3: b256;
//     var __::FooI_pathway: int;
//     var __::FooI2_pathway: int;
//     constraint (::FooI::x1 == true);
//     constraint (::FooI::x2 == 5);
//     constraint (::FooI::x3 == 0x0000111100001111000011110000111100001111000011110000111100001111);
//     constraint (::FooI::x5 == {true, 2});
//     constraint (::FooI::x6 == [1, 2, 3, 4, 5]);
//     constraint (::FooI2::y1 == true);
//     constraint (::FooI2::y2 == 5);
//     constraint (::FooI2::y3 == 0x0000111100001111000011110000111100001111000011110000111100001111);
//     constraint (::FooI2::y5 == {true, 2});
//     constraint (::FooI2::y6 == [1, 2, 3, 4, 5]);
// }
// >>>

// flattened <<<
// enum ::MyEnum = A | B;
// type ::MyType = ::MyEnum;
// interface ::Contract {
//     predicate Foo {
//         pub var x1: bool;
//         pub var x2: int;
//         pub var x3: b256;
//         pub var x5: {bool, int};
//         pub var x6: int[5];
//         pub var y1: bool;
//         pub var y2: int;
//         pub var y3: b256;
//         pub var y5: {bool, int};
//         pub var y6: int[5];
//     }
// }
// 
// predicate ::Foo {
//     interface ::ContractI = ::Contract(::addr1)
//     predicate ::FooI = ::ContractI::Foo(::addr2)
//     predicate ::FooI2 = ::ContractI::Foo(::addr3)
//     var ::addr1: b256;
//     var ::addr2: b256;
//     var ::addr3: b256;
//     var __::FooI_pathway: int;
//     var __::FooI2_pathway: int;
//     constraint (__transient({0}, 1, __::FooI_pathway) == true);
//     constraint (__transient({1}, 1, __::FooI_pathway) == 5);
//     constraint (__transient({2}, 1, __::FooI_pathway) == 0x0000111100001111000011110000111100001111000011110000111100001111);
//     constraint (__transient({3, 0}, 2, __::FooI_pathway) == {true, 2});
//     constraint (__transient({4, 0}, 2, __::FooI_pathway) == [1, 2, 3, 4, 5]);
//     constraint (__transient({5}, 1, __::FooI2_pathway) == true);
//     constraint (__transient({6}, 1, __::FooI2_pathway) == 5);
//     constraint (__transient({7}, 1, __::FooI2_pathway) == 0x0000111100001111000011110000111100001111000011110000111100001111);
//     constraint (__transient({8, 0}, 2, __::FooI2_pathway) == {true, 2});
//     constraint (__transient({9, 0}, 2, __::FooI2_pathway) == [1, 2, 3, 4, 5]);
//     constraint __eq_set(__mut_keys(), {0});
//     constraint (__predicate_at(__::FooI_pathway) == {::addr1, ::addr2});
//     constraint (__predicate_at(__::FooI2_pathway) == {::addr1, ::addr3});
// }
// >>>
