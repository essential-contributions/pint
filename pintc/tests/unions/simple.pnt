type number = int;

union thing = a(bool) | b(number) | c({int, number});
union maybe_addr = no_addr | addr(b256);

type maydr = maybe_addr;

predicate test {
    var x: thing;

    // Boolean match expression.
    constraint match x {
        thing::a(b) => b,
        thing::b(n) => n > 0,
        thing::c(t) => t.0 + t.1 == 11
    };

    // Integer match expression in a constraint with `else`.
    constraint match x {
        thing::b(b) => b,
        else => 22,
    } > 0;

    // Boolean match expression with blocks & constraints.
    constraint match x {
        thing::a(b) => b,
        thing::b(n) => {
            constraint n > 0;
            n * 2 < 10
        },
        thing::c(t) => {
            constraint t.0 == 33;
            constraint t.1 != 44;
            true
        }
    };

    // Non-expression match.  Also refers to other var `d`.
    var d: int;
    match x {
        thing::a(b) => {},
        thing::c(t) => {
            constraint t.0 * t.1 == 66;
            constraint d == t.0 - t.1;
        }
        else => {
            constraint d == 55;
        }
    }

    // Constraining an address to either zero or something.
    //
    // DISABLED until we 'fix' initialisers.  These initialisers would generate constraints like
    // `no_bad_addr == maybe_addr::no_bad_addr` but `==` is illegal for unions.
    //
    //var no_base_addr: maydr = maybe_addr::no_addr;
    //var a_base_addr: maydr = maybe_addr::addr(0x1111111111111111111111111111111111111111111111111111111111111111);

    //var actual_addr = match no_base_addr {
    //    maybe_addr::no_addr => 0x0000000000000000000000000000000000000000000000000000000000000000,
    //    maybe_addr::addr(a) => a,
    //};
}

// parsed <<<
// union ::thing = a(bool) | b(::number) | c({int, ::number});
// union ::maybe_addr = no_addr | addr(b256);
// type ::number = int;
// type ::maydr = ::maybe_addr;
//
// predicate ::test {
//     var ::x: ::thing;
//     var ::d: int;
//     constraint match ::x { ::thing::a(b) => ::b, ::thing::b(n) => (::n > 0), ::thing::c(t) => ((::t.0 + ::t.1) == 11) };
//     constraint (match ::x { ::thing::b(b) => ::b, else => 22 } > 0);
//     constraint match ::x { ::thing::a(b) => ::b, ::thing::b(n) => constraint (::n > 0); ((::n * 2) < 10), ::thing::c(t) => constraint (::t.0 == 33); constraint (::t.1 != 44); true };
//     match ::x {
//         ::thing::a(b) => {
//         }
//         ::thing::c(t) => {
//             constraint ((::t.0 * ::t.1) == 66)
//             constraint (::d == (::t.0 - ::t.1))
//         }
//         else => {
//             constraint (::d == 55)
//         }
//     }
// }
// >>>

// flattened <<<
// union ::thing = a(bool) | b(int) | c({int, int});
// union ::maybe_addr = no_addr | addr(b256);
// type ::number = int;
// type ::maydr = ::maybe_addr;
//
// predicate ::test {
//     var ::x: ::thing;
//     var ::d: int;
//     constraint ((UnTag(::x) == 0) ? UnVal(::x, bool) : ((UnTag(::x) == 1) ? (UnVal(::x, int) > 0) : ((UnVal(::x, {int, int}).0 + UnVal(::x, {int, int}).1) == 11)));
//     constraint (((UnTag(::x) == 1) ? UnVal(::x, int) : 22) > 0);
//     constraint ((UnTag(::x) == 0) ? UnVal(::x, bool) : ((UnTag(::x) == 1) ? ((UnVal(::x, int) * 2) < 10) : true));
//     constraint ((UnTag(::x) == 0) || (!(UnTag(::x) == 2) || ((UnVal(::x, {int, int}).0 * UnVal(::x, {int, int}).1) == 66)));
//     constraint ((UnTag(::x) == 0) || (!(UnTag(::x) == 2) || (::d == (UnVal(::x, {int, int}).0 - UnVal(::x, {int, int}).1))));
//     constraint ((UnTag(::x) == 0) || ((UnTag(::x) == 2) || (::d == 55)));
//     constraint ((UnTag(::x) == 0) || (!(UnTag(::x) == 1) || (UnVal(::x, int) > 0)));
//     constraint ((UnTag(::x) == 0) || ((UnTag(::x) == 1) || (!(UnTag(::x) == 2) || (UnVal(::x, {int, int}).0 == 33))));
//     constraint ((UnTag(::x) == 0) || ((UnTag(::x) == 1) || (!(UnTag(::x) == 2) || (UnVal(::x, {int, int}).1 != 44))));
//     constraint __eq_set(__mut_keys(), {0});
// }
// >>>
