storage {
    i: int,    
    b: bool,
}

state i1 = storage::i;
state b1 = storage::b;

let bad_and = b1 && i1;

solve satisfy;

// intermediate <<<
// storage {
//     i: int,
//     b: bool,
// }
// var ::bad_and;
// state ::i1 = storage::i;
// state ::b1 = storage::b;
// constraint (::bad_and == (::b1 && ::i1));
// solve satisfy;
// >>>

// typecheck_failure <<<
// binary operator type error
// @109..111: operator `&&` argument has unexpected type `int`
// @103..111: expecting type `bool`
// unable to determine expression type
// @93..100: type of this expression is ambiguous
// compiler internal error: missing expr key in expr_types slotmap when checking constraint expr types
// >>>
