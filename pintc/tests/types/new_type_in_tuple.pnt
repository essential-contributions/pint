type A = int;
type B = { x: A, y: A };
type C = A[3];

var a: A;
var b: B = { a, a };
var c: A = b.1;
var d: A = b.x;
var e: C = [a, a, a];
var f: A = e[1];
var g: A = a;

solve satisfy;

// intermediate <<<
// var ::a: ::A;
// var ::b: ::B;
// var ::c: ::A;
// var ::d: ::A;
// var ::e: ::C;
// var ::f: ::A;
// var ::g: ::A;
// type ::A = int;
// type ::B = {x: ::A, y: ::A};
// type ::C = ::A[3];
// constraint (::b == {::a, ::a});
// constraint (::c == ::b.1);
// constraint (::d == ::b.x);
// constraint (::e == [::a, ::a, ::a]);
// constraint (::f == ::e[1]);
// constraint (::g == ::a);
// solve satisfy;
// >>>

// flattened <<<
// var ::a: int;
// var ::b.x: int;
// var ::b.y: int;
// var ::c: int;
// var ::d: int;
// var ::e[0]: int;
// var ::e[1]: int;
// var ::e[2]: int;
// var ::f: int;
// var ::g: int;
// type ::A = int;
// type ::B = {x: ::A (int), y: ::A (int)};
// type ::C = ::A (int)[3];
// constraint ((::b.x == ::a) && (::b.y == ::a));
// constraint (::c == ::b.y);
// constraint (::d == ::b.x);
// constraint (((::e[0] == ::a) && (::e[1] == ::a)) && (::e[2] == ::a));
// constraint (::f == ::e[1]);
// constraint (::g == ::a);
// solve satisfy;
// >>>
