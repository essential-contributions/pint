enum Foo = Bar | Baz;
enum Bar = Baz | Xyzzy;

let a = Baz;

solve satisfy;

// intermediate <<<
// var ::a;
// enum ::Foo = Bar | Baz;
// enum ::Bar = Baz | Xyzzy;
// constraint (::a == ::Baz);
// solve satisfy;
// >>>

// typecheck_failure <<<
// cannot find value `::Baz` in this scope
// @55..58: not found in this scope
// this symbol is a variant of enums `::Foo` and `::Bar` and may need a fully qualified path
// unable to determine expression type
// @51..52: type of this expression is ambiguous
// attempt to index into a non-indexable value
// @47..58: expression for constraint must evaluate to a boolean
// >>>
