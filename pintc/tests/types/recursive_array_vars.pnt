let a = [c[1], b];
let b = c[1];
let c = [[b][0], a[1]];

solve satisfy;

// intermediate <<<
// var ::a;
// var ::b;
// var ::c;
// constraint (::a == [::c[1], ::b]);
// constraint (::b == ::c[1]);
// constraint (::c == [[::b][0], ::a[1]]);
// solve satisfy;
// >>>

// typecheck_failure <<<
// expression has a recursive dependency
// @27..28: cannot determine type of expression due to dependency
// @41..55: dependency on expression is recursive
// expression has a recursive dependency
// @43..44: cannot determine type of expression due to dependency
// @27..31: dependency on expression is recursive
// expression has a recursive dependency
// @27..28: cannot determine type of expression due to dependency
// @41..55: dependency on expression is recursive
// unable to determine expression type
// @4..5: type of this expression is ambiguous
// unable to determine expression type
// @23..24: type of this expression is ambiguous
// unable to determine expression type
// @37..38: type of this expression is ambiguous
// compiler internal error: missing expr key in expr_types slotmap when checking constraint expr types
// compiler internal error: missing expr key in expr_types slotmap when checking constraint expr types
// compiler internal error: missing expr key in expr_types slotmap when checking constraint expr types
// >>>
