use crate::{
    error::{CompileError, Error, Handler, ParseError},
    expr::*,
    intermediate::{ExprKey, IntermediateIntent, Program, ProgramKind, SolveFunc, StorageVar, Extern},
    lexer,
    macros::{MacroCall, MacroDecl},
    parser::{
        ParserContext, UsePath,
        UseTree::{self, Path as UseTreePath},
    },
    span::{self, Spanned},
    types::{EnumDecl, FnSig, NewTypeDecl, Path, PrimitiveKind, Type},
};

grammar<'a>(
    context: &mut ParserContext<'a>,
    handler: &Handler,
);

pub Pint: () = {
    Decl*,
};

////////////////////
/// Declarations ///
////////////////////

Decl: () = {
    DeclBarringMacro,
    IntentDecl,
    MacroDecl,
    StorageDecl,
    ExternDecl,
};

DeclBarringMacro: () = {
    UseStatement ";",
    LetDecl ";",
    StateDecl ";",
    ConstraintDecl ";",
    SolveDecl ";",
    EnumDecl ";",
    NewTypeDecl ";",
    MacroCallDecl ";",
};

pub IntentDecl: () = {
    IntentOpen DeclBarringMacro* IntentClose,
}

pub IntentOpen: () = {
    <l:@L> "intent" <name:Ident> <r:@R> "{" => {
        // To detect name clashes
        let name = context.add_top_level_symbol(
            handler,
            Ident {
                name: name.to_string(),
                hygienic: false,
                span: (context.span_from)(l, r),
            },
            context.mod_prefix,
        );

        // Brand new II in the program
        context
            .program
            .iis
            .insert(name.to_string(), IntermediateIntent::default());

        // Keep track of the macro call in this new intent
        context
            .macro_calls
            .insert(name.to_string(), slotmap::SecondaryMap::default());

        // The program is now considered stateful
        context.program.kind = ProgramKind::Stateful;

        // Switch the current_ii so that the parser inserts items in the right II until the intent
        // closes
        *context.current_ii = name.to_string();
    }
}

pub IntentClose: () = {
    "}" => {
        // At the end of the intent declaration, return back to the root II
        *context.current_ii = Program::ROOT_II_NAME.to_string();
    }
}

pub StorageVar: StorageVar = {
    <l:@L> <name:Ident> ":" <ty:StorageVarType> <r:@R> => {
        let span = (context.span_from)(l, r);
        if ty.is_bool() || ty.is_int() || ty.is_b256() || ty.is_tuple() {
            StorageVar {
                name: name.to_string(),
                ty,
                span,
            }
        } else if let Type::Map {
            ref ty_from,
            ref ty_to,
            ..
        } = ty
        {
            if (ty_from.is_bool() || ty_from.is_int() || ty_from.is_b256())
                && (ty_to.is_bool()
                    || ty_to.is_int()
                    || ty_to.is_b256()
                    || ty_to.is_map()
                    || ty_to.is_tuple())
            {
                StorageVar {
                    name: name.to_string(),
                    ty,
                    span,
                }
            } else {
                // TODO: allow arbitrary types in storage maps
                handler.emit_err(Error::Compile {
                    error: CompileError::Internal {
                        msg: "currently in storage maps, keys must be int, bool, or b256 /
                              and values must be int and bool",
                        span: span::empty_span(),
                    },
                });
                StorageVar {
                    name: name.to_string(),
                    ty: Type::Error(ty.span().clone()),
                    span,
                }
            }
        } else if let Type::Vector {
            ty: ref el_ty,
            ..
        } = ty
        {
            if el_ty.is_bool()
                || el_ty.is_int()
             // || el_ty.is_b256()
             // || el_ty.is_map()
             || el_ty.is_vector()
             // || el_ty.is_tuple()
            {
                StorageVar {
                    name: name.to_string(),
                    ty,
                    span,
                }
            } else {
                // TODO: allow arbitrary types in storage maps
                handler.emit_err(Error::Compile {
                    error: CompileError::Internal {
                        msg: "currently in storage maps, keys must be int, bool, or b256 /
                              and values must be int and bool",
                        span: span::empty_span(),
                    },
                });
                StorageVar {
                    name: name.to_string(),
                    ty: Type::Error(ty.span().clone()),
                    span,
                }
            }
        } else {
            // TODO: allow arbitrary types in storage blocks
            handler.emit_err(Error::Compile {
                error: CompileError::Internal {
                    msg: "only ints, bools, and maps are currently allowed in a storage block",
                    span: span::empty_span(),
                },
            });
            StorageVar {
                name: name.to_string(),
                ty: Type::Error(ty.span().clone()),
                span,
            }
        }
    }
}

pub StorageDecl: () = {
    <l:@L> "storage" "{" <storage_vars:SepList<StorageVar, ",">>  "}" <r:@R> => {
        let span = (context.span_from)(l, r);
        if let Some((_, prev_span)) = &context.current_ii().storage {
            // Multiple `storage` blocks are not allowed
            handler.emit_err(Error::Parse {
                error: ParseError::TooManyStorageBlocks {
                    span,
                    prev_span: prev_span.clone(),
                },
            });
        } else if !context.mod_path.is_empty() {
            // `storage` blocks in sub-modules are not allowed
            handler.emit_err(Error::Parse {
                error: ParseError::StorageDirectiveMustBeTopLevel { span },
            });
        } else {
            context.current_ii().storage = Some((storage_vars, span));
        }
    },
}

pub ExternDecl: () = {
    <l:@L> "extern" <name:Ident> "(" <imm:Immediate> ")" "{"
        "storage" "{" <storage_vars:SepList<StorageVar, ",">> "}"
    "}" <r:@R> => {
        let extern_decl = Extern {
            name: context.add_top_level_symbol(handler, name, context.mod_prefix),
            address: imm,
            storage_vars,
            span: (context.span_from)(l, r),
        };
        context.current_ii().externs.push(extern_decl);
    }
}

UseStatement: () = {
    "use" <l:@L> <abs:"::"?> <ut:UseTree> <r:@R> => {
        // Convert the use tree into use paths, prepend the current mod path prefix to each iff the
        // use tree is not absolute, and append to the current list of use paths in our context.
        let mod_prefix = context.mod_prefix;
        let mod_path = context.mod_path;
        let local_handler = Handler::default();
        let mut new_use_paths = ut
            .gather_paths()
            .into_iter()
            .filter_map(|mut use_path| {
                if abs.is_none() {
                    use_path.add_prefix(mod_path.to_vec());
                }

                // If any of the idents in the path, other than the last one, is a `self`,
                // immediately error out
                if use_path
                    .path
                    .iter()
                    .take(use_path.path.len() - 1)
                    .any(|elem| elem == "self")
                {
                    local_handler.emit_err(Error::Parse {
                        error: ParseError::SelfNotAtTheEnd {
                            // We can use a better span here but that's okay for now. Ideally, we
                            // would use the span of the `self` ident itself, but we don't have that
                            // right now.
                            span: (context.span_from)(l, r),
                        },
                    });
                    return None;
                }

                // Paths that end in `self` get a special handling
                if use_path.path[use_path.path.len() - 1] == "self" {
                    // First, remove `self` because a path that ends in `self` is the same as its
                    // prefix For example: `a::b::self` is the same as `a::b`
                    use_path.path.pop();

                    // Paths with only `self` (i.e. nothing before it) are not valid
                    //
                    // Check that the prefix `use_path.path` matches the current `mod_path` because
                    // we may in a module other than the root module
                    if use_path.path == mod_path {
                        local_handler.emit_err(Error::Parse {
                            error: ParseError::SelfWithEmptyPrefix {
                                span: use_path.span.clone(),
                            },
                        });
                        return None;
                    }
                }

                Some(use_path.clone())
            })
            .map(|use_path| {
                // This is a bit strange.  We're taking the alias or the last element of the use
                // path, prefixing it with the current mod path and inserting that as a top-level
                // symbol.  This is to avoid local decls clashing with the `use` path, though those
                // symbols are all absolute.
                //
                // e.g.,
                // use some::other::mod::a;       // Inserted as ::local::mod::a
                // let a: int;                    // Inserted as ::local::mod::a
                //
                // use some::other::mod::b as c;  // Inserted as ::local::mod::c
                // let c: int;                    // Inserted as ::local::mod::c
                //
                // There is one special case with `self` where the previous ident in the path is
                // considered instead. This is automatically handled by the `filter_map` above. For
                // example:
                //
                // use a::b::mod::my_mod::self;    // Inserted as ::local::mod::my_mod
                context
                    .current_ii()
                    .add_top_level_symbol(
                        &local_handler,
                        mod_prefix,
                        None,
                        &Ident {
                            name: use_path
                                .alias
                                .clone()
                                .unwrap_or(use_path.path[use_path.path.len() - 1].clone()),
                            hygienic: false,
                            span: use_path.span.clone(),
                        },
                        use_path.span.clone(),
                    )
                    .map(|_| use_path.clone())
                    .unwrap_or_else(|error| use_path)
            })
            .collect::<Vec<_>>();

        handler.append(local_handler);
        context.use_paths.append(&mut new_use_paths);
    }
};

pub UsePathIdent: Ident = {
    Ident,
    IdentFromToken<"self">,
    MacroName,
}

pub UseTree: UseTree = {
    <name:UsePathIdent> => UseTree::Name { name },
    <prefix:UsePathIdent> "::" <suffix:UseTree> => UseTreePath { prefix, suffix: Box::new(suffix) },
    "{" <imports:SepList<UseTree, ",">> "}" => UseTree::Group { imports },
    <name:UsePathIdent> "as" <alias:Ident> => UseTree::Alias { name, alias },
};

pub LetDecl: () = {
    <l:@L> "let" <let_name:LetName> ":" <ty:Type> <init:LetInit?> <r:@R> => {
        let mod_prefix = context.mod_prefix;
        let _ = context
            .current_ii()
            .insert_var(handler, mod_prefix, let_name.1, &let_name.0, Some(ty))
            .map(|var_key| {
                if let Some(expr_key) = init {
                    context.current_ii().var_inits.insert(var_key, expr_key);
                    let span = (context.span_from)(l, r);
                    context
                        .current_ii()
                        .insert_eq_or_ineq_constraint(var_key, expr_key, span);
                }
            });
    },
    <l:@L> "let" <let_name:LetName> <init:LetInit> <r:@R> => {
        let mod_prefix = context.mod_prefix;
        let _ = context
            .current_ii()
            .insert_var(handler, mod_prefix, let_name.1, &let_name.0, None)
            .map(|var_key| {
                context.current_ii().var_inits.insert(var_key, init);
                let span = (context.span_from)(l, r);
                context
                    .current_ii()
                    .insert_eq_or_ineq_constraint(var_key, init, span);
            });
    },
    <l:@L> "let" <name:Ident> <r:@R> => {
        handler.emit_err(Error::Parse {
            error: ParseError::UntypedVariable {
                name: name.name,
                span: (context.span_from)(l, r),
            },
        });
    }
};

LetName: (Ident, Option<&'a str>) = {
    <l:@L> <id:"ident"> <r:@R> => {
        // We special case the let name here, as we're interested in the associated flag (and this
        // is the only place where we care).  The flag indicates that this identifier was
        // substituted as a part of a macro argument during macro expansion.
        //
        // This is to implement macro body hygiene.
        //
        // If we have an identifier which is NOT from a macro arg AND a local prefix set in the
        // parser context indicating we're currently parsing a macro body, then we need to add a Use
        // path to make sure this name is referred to using that local prefix.  We're adding hygiene
        // using the prefix.

        let local_scope = (!id.1).then_some(()).and(context.local_scope);

        if let Some(prefix) = local_scope {
            let mut path = context.mod_path.to_vec();
            path.push(prefix.to_owned());
            path.push(id.0.to_owned());
            context.use_paths.push(UsePath {
                path,
                alias: None,
                is_absolute: true,
                span: span::empty_span(),
            });
        }

        let name = Ident {
            name: id.0.to_owned(),
            hygienic: id.1,
            span: (context.span_from)(l, r),
        };

        (name, local_scope)
    }
};

LetInit: ExprKey = {
    "=" <Range>,
    "=" <Expr>,
};

pub StateDecl: () = {
    <l:@L> "state" <name:Ident> <ty:(":" <Type>)?> "=" <init:StateInit> <r:@R> => {
        // Return the index to the new state in the IntermediateIntent::states Vec.
        let span = (context.span_from)(l, r);
        let mod_prefix = context.mod_prefix;
        let _ = context
            .current_ii()
            .insert_state(handler, mod_prefix, &name, ty, init, span)
            .map(|_| ());
    },
};

pub ConstraintDecl: () = {
    <l:@L> "constraint" <e:Expr> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().constraints.push((e, span));
    }
};

pub SolveDecl: () = {
    <l:@L> <sd:SolveDeclInner> <r:@R> => {
        let span = (context.span_from)(l, r);
        if let Some((_, prev_span)) = context.current_ii().directives.first() {
            // Multiple `solve` directives are not allowed
            handler.emit_err(Error::Parse {
                error: ParseError::TooManySolveDirectives {
                    span,
                    prev_span: prev_span.clone(),
                },
            });
        } else if !context.mod_path.is_empty() {
            // `solve` directives in sub-modules are not allowed
            handler.emit_err(Error::Parse {
                error: ParseError::SolveDirectiveMustBeTopLevel { span },
            });
        } else if context.current_ii != Program::ROOT_II_NAME {
            // `solve` directives inside an `intent` declaration are not allowed
            handler.emit_err(Error::Parse {
                error: ParseError::SolveDirectiveMustBeOutsideIntent { span },
            });
        } else {
            context.current_ii().directives.push((sd.clone(), span));
        }
    }
}

SolveDeclInner: SolveFunc = {
    "solve" "satisfy" => SolveFunc::Satisfy,
    "solve" "minimize" <e:Expr> => SolveFunc::Minimize(e),
    "solve" "maximize" <e:Expr> => SolveFunc::Maximize(e),
};

pub EnumDecl: () = {
    <l:@L> "enum" <name:Ident> "=" <variants:Sep1ListNoTrail<Ident, "|">> <r:@R> => {
        let enum_decl = EnumDecl {
            name: context.add_top_level_symbol(handler, name, context.mod_prefix),
            variants,
            span: (context.span_from)(l, r),
        };
        context.current_ii().enums.push(enum_decl);
    }
}

pub NewTypeDecl: () = {
    <l:@L> "type" <name:Ident> "=" <ty:Type> <r:@R> => {
        let new_type_decl = NewTypeDecl {
            name: context.add_top_level_symbol(handler, name, context.mod_prefix),
            ty,
            span: (context.span_from)(l, r),
        };
        context.current_ii().new_types.push(new_type_decl);
    }
}

MacroName: Ident = IdentFromToken<"macro_name">;

pub MacroDecl: () = {
    "macro" <l:@L> <mut name:MacroName> "("
        <params:MacroParamList>
    ")" <r:@R>
    <body:"macro_body"> => {
        // Prefix the name with the module.  We can't use `add_top_level_symbol()` to do this as we
        // must avoid the regular name clash error we'd get with variadic macros.
        name.name = context.mod_prefix.to_string() + &name.name;
        context.macros.push(MacroDecl {
            name,
            params: params.0,
            pack: params.1,
            body,
            sig_span: (context.span_from)(l, r),
        });
    }
}

MacroParamList: (Vec<Ident>, Option<Ident>) = {
    <mut v: (<MacroParam> ",")*> <e:MacroParam>
    <p:("," <IdentFromToken<"macro_param_pack">>)?> ","? => {
        v.push(e);
        (v, p)
    }
}

MacroParam: Ident = IdentFromToken<"macro_param">;

MacroCallDecl: () = {
    MacroCallExpr => (),
}

pub MacroBody: Option<ExprKey> = {
    "{" DeclBarringMacro* <Expr?> "}"
}

FnParam: (Ident, Type)  = {
    <name:Ident> ":" <ty:Type> => (name, ty)
}

FnSig: FnSig = {
    <l:@L> "fn" <name:Ident> "(" <params:SepList<FnParam, ",">> ")"  "->" <return_type:Type> <r:@R> => {
        FnSig {
            name,
            params,
            return_type,
            span: (context.span_from)(l, r),
        }
    }
}

/////////////
/// Types ///
/////////////

pub Type: Type = {
    <ArrayType>,
    <TypeAtom>,
};

TypeAtom: Type = {
    <l:@L> <kind:PrimitiveType> <r:@R> => Type::Primitive {
        kind,
        span: (context.span_from)(l, r),
    },
    <l:@L> "{" <fields:TupleFields> "}" <r:@R> => {
        Type::Tuple {
            fields,
            span: (context.span_from)(l, r),
        }
    },
    <l:@L> "{" "}" <r:@R> => {
        let span = (context.span_from)(l, r);
        handler.emit_err(Error::Parse {
            error: ParseError::EmptyTupleType { span: span.clone() },
        });

        // Recover with a malformed type
        Type::Error(span)
    },
    <l:@L> <path:Path> <r:@R> => Type::Custom {
        path,
        span: (context.span_from)(l, r),
    },
};

ArrayType: Type = {
    <l:@L> <ty:TypeAtom> <ranges: ("[" <Expr> "]")+ > <r:@R> => {
        // Multi-dimensional arrays have their innermost dimension on the far
        // right. Hence, we need to reverse the iterator.
        // For example, `int[3][5]` is actually an array of size 3 that
        // contains arrays of size 5 of `int`s.
        ranges.iter().rev().fold(ty, |acc, range| Type::Array {
            ty: Box::new(acc),
            range: *range,
            size: None,
            span: (context.span_from)(l, r),
        })
    },
    <l:@L> <ty:TypeAtom> "[" "]" <r:@R> => {
        let span = (context.span_from)(l, r);
        handler.emit_err(Error::Parse {
            error: ParseError::EmptyArrayType { span: span.clone() },
        });

        // Recover with a malformed type
        Type::Error(span)
    },
};

PrimitiveType: PrimitiveKind = {
    "int_ty" => PrimitiveKind::Int,
    "real_ty" => PrimitiveKind::Real,
    "bool_ty" => PrimitiveKind::Bool,
    "string_ty" => PrimitiveKind::String,
    "b256_ty" => PrimitiveKind::B256,
}

TupleFields: Vec<(Option<Ident>, Type)> = {
    <field:TupleField> => vec![field],
    <Sep1List<TupleField, ",">>,
};

TupleField: (Option<Ident>, Type) = {
    <id:(<Ident> ":")?> <ty:Type> => (id, ty),
};

/////////////////////
/// Storage Types ///
/////////////////////

MapType: Type = {
    <l:@L> "(" <ty_from:Type> "=>" <ty_to:StorageVarType> ")" <r:@R> => Type::Map {
        ty_from: Box::new(ty_from),
        ty_to: Box::new(ty_to),
        span: (context.span_from)(l, r),
    }
}

VecType: Type = {
    <l:@L> <ty:StorageVarType> "[" "]" <r:@R> => Type::Vector {
        ty: Box::new(ty),
        span: (context.span_from)(l, r),
    }
}

pub StorageVarType: Type = {
    <MapType>,
    <VecType>,
    <TypeAtom>,
}

///////////////////
/// Expressions ///
///////////////////

pub Expr: ExprKey = {
    <LogicalOrOp>,
};

LogicalOrOp: ExprKey = {
    <l:@L> <lhs:LogicalOrOp> "||" <rhs:LogicalAndOp> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(Expr::BinaryOp {
            op: BinaryOp::LogicalOr,
            lhs,
            rhs,
            span,
        })
    },
    <LogicalAndOp>,
};

LogicalAndOp: ExprKey = {
    <l:@L> <lhs:LogicalAndOp> "&&" <rhs:Comparison> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(Expr::BinaryOp {
            op: BinaryOp::LogicalAnd,
            lhs,
            rhs,
            span,
        })
    },
    <Comparison>,
};

Comparison: ExprKey = {
    <l:@L> <lhs:Comparison> <op:RelOpOp> <rhs:InOp> <r:@R> => {
        let span = (context.span_from)(l, r);
        context
            .current_ii()
            .exprs
            .insert(Expr::BinaryOp { op, lhs, rhs, span })
    },
    <InOp>,
};

RelOpOp: BinaryOp = {
    "==" => BinaryOp::Equal,
    "!=" => BinaryOp::NotEqual,
    "<" => BinaryOp::LessThan,
    "<=" => BinaryOp::LessThanOrEqual,
    ">" => BinaryOp::GreaterThan,
    ">=" => BinaryOp::GreaterThanOrEqual,
};

InOp: ExprKey = {
     <l:@L> <value:InOp> "in" <collection:Additive> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(Expr::In {
            value,
            collection,
            span,
        })
     },
     <l:@L> <value:InOp> "in" <collection:Range> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(Expr::In {
            value,
            collection,
            span,
        })
     },
    <Additive>,
};

Additive: ExprKey = {
    <l:@L> <lhs:Additive> <op:AddOpOp> <rhs:Multiplicative> <r:@R> => {
        let span = (context.span_from)(l, r);
        context
            .current_ii()
            .exprs
            .insert(Expr::BinaryOp { op, lhs, rhs, span })
    },
    <Multiplicative>,
};

AddOpOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

Multiplicative: ExprKey = {
    <l:@L> <lhs:Multiplicative> <op:MultOpOp> <rhs:AsOp> <r:@R> => {
        let span = (context.span_from)(l, r);
        context
            .current_ii()
            .exprs
            .insert(Expr::BinaryOp { op, lhs, rhs, span })
    },
    <AsOp>,
};

MultOpOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
};

AsOp: ExprKey = {
     <l:@L> <value:AsOp> "as" <ty:Type> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(Expr::Cast {
            value,
            ty: Box::new(ty),
            span,
        })
     },
    <TupleFieldOp>,
};

TupleFieldOp: ExprKey = {
    <l:@L> <tuple:TupleFieldOp> "." <name:Ident> <r:@R> => {
        context.handle_tuple_field_op_with_ident(tuple, name, (l, r))
    },
    <l:@L> <tuple:TupleFieldOp> "." <m:@L> <num_str:"int_lit"> <r:@R> => {
        context.handle_tuple_field_op_with_int(handler, tuple, num_str, (l, m, r))
    },
    <l:@L> <tuple:TupleFieldOp> "." <m:@L> <num_str:"real_lit"> <r:@R> => {
        context.handle_tuple_field_op_with_real(handler, tuple, num_str, (l, m, r))
    },
    <IndexOp>,
};

IndexOp: ExprKey = {
    <l:@L> <expr:IndexOp> "[" <index:Expr> "]" <r:@R> => {
        let span = (context.span_from)(l, r);
        context
            .current_ii()
            .exprs
            .insert(Expr::Index { expr, index, span })
    },
    <l:@L> <expr:IndexOp> "[" "]" <r:@R> => {
        let span = (context.span_from)(l, r);
        handler.emit_err(Error::Parse {
            error: ParseError::EmptyIndexAccess { span: span.clone() },
        });

        // Recover with a malformed expression
        context.current_ii().exprs.insert(Expr::Error(span))
    },
    <PrimeOp>,
};

PrimeOp: ExprKey = {
    <l:@L> <expr:PrimeOp> "'" <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(Expr::UnaryOp {
            op: UnaryOp::NextState,
            expr,
            span,
        })
    },
    <UnaryOp>,
}

UnaryOp: ExprKey = {
    <l:@L> <op:UnaryOpOp> <expr:UnaryOp> <r:@R> => {
        let span = (context.span_from)(l, r);
        context
            .current_ii()
            .exprs
            .insert(Expr::UnaryOp { op, expr, span })
    },
    <Term>,
};

UnaryOpOp: UnaryOp = {
    <l:@L> "+" <r:@R> => {
        handler.emit_err(Error::Parse {
            error: ParseError::UnsupportedLeadingPlus {
                span: (context.span_from)(l, r),
            },
        });
        UnaryOp::Error
    },
    "-" => UnaryOp::Neg,
    "!" => UnaryOp::Not,
};

Term: ExprKey = {
    <e:TermInner> => context.current_ii().exprs.insert(e),
    <MacroCallExpr>,
    <CondExpr>,
    "(" <Expr> ")",
    <BlockExpr>,
};

TermInner: Expr = {
    <l:@L> <imm:Immediate> <r:@R> => {
        Expr::Immediate {
            value: imm,
            span: (context.span_from)(l, r),
        }
    },
    <IfExpr>,
    <GeneratorExpr>,
    <FnCallExpr>,
    <ArrayExpr>,
    <TupleExpr>,
    <l:@L> <path:Path> <r:@R> => Expr::PathByName(path, (context.span_from)(l, r)),
};

BlockExpr: ExprKey = {
    "{" (ConstraintDecl ";")* <Expr> "}"
};

GeneratorRange: (Ident, ExprKey) = {
    <index:Ident> "in" <range:Range> => {
        // Generators for `forall`/`exists` are always `int`s and need to be saved in the ephemeral list.
        let mod_prefix = context.mod_prefix;
        let _ = context.current_ii().insert_ephemeral(
            handler,
            mod_prefix,
            &index,
            Type::Primitive {
                kind: PrimitiveKind::Int,
                span: index.span.clone(),
            },
        );
        (index, range)
    }
}

GeneratorExpr: Expr = {
    <l:@L> "forall" <gen_ranges:Sep1ListNoTrail<GeneratorRange, ",">>
            <conditions: ("where" <Sep1ListNoTrail<Expr, ",">>)?>
            "{" <body:Expr> "}" <r:@R> => {
        Expr::Generator {
            kind: GeneratorKind::ForAll,
            gen_ranges,
            conditions: conditions.unwrap_or_default(),
            body,
            span: (context.span_from)(l, r),
        }
    },
    <l:@L> "exists" <gen_ranges:Sep1ListNoTrail<GeneratorRange, ",">>
            <conditions: ("where" <Sep1ListNoTrail<Expr, ",">>)?>
            "{" <body:Expr> "}" <r:@R> => {
        Expr::Generator {
            kind: GeneratorKind::Exists,
            gen_ranges,
            conditions: conditions.unwrap_or_default(),
            body,
            span: (context.span_from)(l, r),
        }
    }
}

IfExpr: Expr = {
    <l:@L> "if" <condition:Expr> <then_block:BlockExpr> "else" <else_block:BlockExpr> <r:@R> => {
        Expr::If {
            condition,
            then_block,
            else_block,
            span: (context.span_from)(l, r),
        }
    }
}

CondBranch: (ExprKey, ExprKey) = {
    <condition:Expr> "=>" <result:Expr> "," => (condition, result)
};

ElseBranch: ExprKey = {
    "else" "=>" <else_result:Expr> ","? => else_result
};

CondExpr: ExprKey = {
    <l:@L> "cond" "{" <cond_branches: (<CondBranch>)*> <else_branch: ElseBranch> "}" <r:@R> => {
        // De-sugar a `cond` into an `if/else` chain.
        //
        // Build the `if/else` chain starting with the else branch and going up,
        // hence the need to reverse the iterator below.
        cond_branches
            .iter()
            .rev()
            .fold(else_branch, |acc, (condition, result)| {
                let span = (context.span_from)(l, r);
                context.current_ii().exprs.insert(Expr::If {
                    condition: *condition,
                    then_block: *result,
                    else_block: acc,
                    span,
                })
            })
    }
};

MacroCallExpr: ExprKey = {
    <l:@L> <name:MacroPath> <tag:"macro_tag"?> <args:"macro_call_args"> <r:@L> => {
        let call_key = context.current_ii().calls.insert(name.clone());
        let span = (context.span_from)(l, r);
        let call_data = MacroCall {
            name,
            mod_path: context.mod_path.to_vec(),
            args,
            span: span.clone(),
            parent_tag: tag.flatten(),
        };
        let call_expr_key = context.current_ii().exprs.insert(Expr::MacroCall {
            call: call_key,
            span,
        });
        context
            .macro_calls
            .get_mut(context.current_ii)
            .unwrap()
            .insert(call_key, (call_expr_key, call_data));
        call_expr_key
    },
};

FnCallExpr: Expr = {
    <l:@L> <path:Path> "(" <args:SepList<Expr, ",">> ")" <r:@R> => {
        Expr::FnCall {
            name: path,
            args,
            span: (context.span_from)(l, r),
        }
    },
};

ArrayExpr: Expr = {
    <l:@L> "[" <il:@L> <elements:SepList<Expr, ",">> <ir:@R> "]" <r:@R> => {
        let span = (context.span_from)(il, ir);
        let range_expr = context.current_ii().exprs.insert(Expr::Immediate {
            value: Immediate::Int(elements.len() as i64),
            span,
        });
        Expr::Array {
            elements,
            range_expr,
            span: (context.span_from)(l, r),
        }
    },
};

TupleExpr: Expr = {
    <l:@L> "{" <fields:TupleExprFields> "}" <r:@R> => {
        Expr::Tuple {
            fields,
            span: (context.span_from)(l, r),
        }
    },
    <l:@L> "{" "}" <r:@R> => {
        let span = (context.span_from)(l, r);
        handler.emit_err(Error::Parse {
            error: ParseError::EmptyTupleExpr { span: span.clone() },
        });

        Expr::Error(span)
    },

};

TupleExprFields: Vec<(Option<Ident>, ExprKey)> = {
    <id:Ident> ":" <expr:Expr> => {
        // Special case for a single field with a field label which does not require the trailing
        // comma to distinguish it from a block expression.
        vec![(Some(id), expr)]
    },
    <Sep1List<TupleExprField, ",">>,
};

TupleExprField: (Option<Ident>, ExprKey) = {
    <id:(<Ident> ":")?> <expr:Expr> => (id, expr),
};

pub Range: ExprKey = {
    <l:@L> <lb:Additive> ".." <ub:Additive> <r:@R> => {
        let span = (context.span_from)(l, r);
        context
            .current_ii()
            .exprs
            .insert(Expr::Range { lb, ub, span })
    }
}

pub Path: Path = {
    <PathWithLast<Ident>>,
};

MacroPath: Path = {
    <PathWithLast<IdentFromToken<"macro_name">>>,
};

PathWithLast<Last>: Path = {
    <l:@L> "::" <els:(<Ident> "::")*> <last:Last> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.handle_absolute_path(els, last, true, span)
    },
    <l:@L> <els:(<Ident> "::")*> <last:Last> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.handle_relative_path(els, last, true, span)
    }
};

pub Immediate: Immediate = {
    ImmediateInt,
    <s:"real_lit"> => Immediate::Real(s.parse().unwrap()),
    "true" => Immediate::Bool(true),
    "false" => Immediate::Bool(false),
    <s:"str_lit"> => Immediate::String(s),
};

ImmediateInt: Immediate = {
    <l:@L> <s:"int_lit"> <r:@R>=> {
        let span = (context.span_from)(l, r);
        match s.chars().nth(1) {
            Some('b') => {
                let digits = s.len() - 2;
                match digits {
                    1..=63 => Immediate::Int(i64::from_str_radix(&s[2..], 2).unwrap()),
                    64 => {
                        // Full 64 bits are specified: check the MSB which represents the sign bit,
                        // and parse accordingly.
                        if &s[2..3] == "1" {
                            // Negative integer. Parse as `u64` then convert to `i64`.
                            Immediate::Int(u64::from_str_radix(&s[2..], 2).unwrap() as i64)
                        } else {
                            // Positive integer. Parse as `i64` directly.
                            Immediate::Int(i64::from_str_radix(&s[2..], 2).unwrap())
                        }
                    }
                    256 => {
                        let offset = 2;
                        Immediate::B256([
                            u64::from_str_radix(&s[offset..offset + 64], 2).unwrap(),
                            u64::from_str_radix(&s[offset + 64..offset + 128], 2).unwrap(),
                            u64::from_str_radix(&s[offset + 128..offset + 192], 2).unwrap(),
                            u64::from_str_radix(&s[offset + 192..offset + 256], 2).unwrap(),
                        ])
                    }
                    _ => {
                        handler.emit_err(Error::Parse {
                            error: ParseError::BinaryLiteralLength {
                                digits,
                                span: span.clone(),
                            },
                        });
                        Immediate::Error
                    }
                }
            }
            Some('x') => {
                let digits = s.len() - 2;
                match digits {
                    1..=15 => Immediate::Int(i64::from_str_radix(&s[2..], 16).unwrap()),
                    16 => {
                        // Full 16 hex digits are specified: check the MSB which represents the sign
                        // bit, and parse accordingly.
                        match &s[2..3] {
                            // Negative integer. Parse as `u64` then convert to `i64`.
                            "8" | "9" | "a" | "A" | "b" | "B" | "c" | "C" | "d" | "D" | "e"
                            | "E" | "f" | "F" => {
                                Immediate::Int(u64::from_str_radix(&s[2..], 16).unwrap() as i64)
                            }
                            // Positive integer. Parse as `i64` directly.
                            _ => Immediate::Int(i64::from_str_radix(&s[2..], 16).unwrap()),
                        }
                    }
                    64 => {
                        let offset = 2;
                        Immediate::B256([
                            u64::from_str_radix(&s[offset..offset + 16], 16).unwrap(),
                            u64::from_str_radix(&s[offset + 16..offset + 32], 16).unwrap(),
                            u64::from_str_radix(&s[offset + 32..offset + 48], 16).unwrap(),
                            u64::from_str_radix(&s[offset + 48..offset + 64], 16).unwrap(),
                        ])
                    }
                    _ => {
                        handler.emit_err(Error::Parse {
                            error: ParseError::HexLiteralLength {
                                digits,
                                span: span.clone(),
                            },
                        });
                        Immediate::Error
                    }
                }
            }
            _ => match s.parse::<i64>() {
                Ok(val) => Immediate::Int(val),
                Err(_) => {
                    handler.emit_err(Error::Parse {
                        error: ParseError::IntLiteralTooLarge { span: span.clone() },
                    });
                    Immediate::Error
                }
            },
        }
    }
};

pub Ident: Ident = {
    <l:@L> <id:"ident"> <r:@R> => Ident {
        name: id.0.to_string(),
        hygienic: id.1,
        span: (context.span_from)(l, r),
    }
}

IdentFromToken<Tok>: Ident = {
    <l:@L> <id:Tok> <r:@R> => Ident {
        name: id.to_string(),
        hygienic: false,
        span: (context.span_from)(l, r),
    }
}

//////////////////////////////////
/// Storage Access Expressions ///
//////////////////////////////////

pub StateInit: ExprKey = {
    <StorageTupleFieldOp>,
    <call:FnCallExpr> => context.current_ii().exprs.insert(call),
}

StorageTupleFieldOp: ExprKey = {
    <l:@L> <tuple:StorageTupleFieldOp> "." <name:Ident> <r:@R> => {
        context.handle_tuple_field_op_with_ident(tuple, name, (l, r))
    },
    <l:@L> <tuple:StorageTupleFieldOp> "." <m:@L> <num_str:"int_lit"> <r:@R> => {
        context.handle_tuple_field_op_with_int(handler, tuple, num_str, (l, m, r))
    },
    <l:@L> <tuple:StorageTupleFieldOp> "." <m:@L> <num_str:"real_lit"> <r:@R> => {
        context.handle_tuple_field_op_with_real(handler, tuple, num_str, (l, m, r))
    },
    <StorageIndexOp>
}

pub StorageIndexOp: ExprKey = {
    // Even though we don't allow complex types in storage maps just yet, this does support indexing
    // into a map of maps.
    <l:@L> <expr:StorageIndexOp> "[" <index:Expr> "]" <r:@R> => {
        let span = (context.span_from)(l, r);
        context
            .current_ii()
            .exprs
            .insert(Expr::Index { expr, index, span })
    },
    <l:@L> <expr:StorageIndexOp> "[" "]" <r:@R> => {
        let span = (context.span_from)(l, r);
        handler.emit_err(Error::Parse {
            error: ParseError::EmptyIndexAccess { span: span.clone() },
        });

        // Recover with a malformed expression
        context.current_ii().exprs.insert(Expr::Error(span))
    },
    <StorageAccess>,
};

StorageAccess: ExprKey = {
    <l:@L> "storage" "::" <name:Ident> <r:@R> => {
        let span = (context.span_from)(l, r);
        let expr = if !context.mod_path.is_empty() {
            // `storage` blocks in sub-modules are not allowed
            handler.emit_err(Error::Parse {
                error: ParseError::StorageAccessMustBeTopLevel { span: span.clone() },
            });
            Expr::Error(span)
        } else {
            Expr::StorageAccess(name.to_string(), span)
        };
        context.current_ii().exprs.insert(expr)
    },
    <l:@L> "::" <els:(<Ident> "::")*> <last:Ident> <r1:@R> "::" "storage" "::" <name:Ident> <r2:@R> => {
        let path_span = (context.span_from)(l, r1);
        let extern_path = context.handle_absolute_path(els, last, false, path_span);

        let span = (context.span_from)(l, r2);
        context
            .current_ii()
            .exprs
            .insert(Expr::ExternalStorageAccess {
                extern_path,
                name: name.to_string(),
                span,
            })
    },
    <l:@L> <els:(<Ident> "::")*> <last:Ident> <r1:@R> "::" "storage" "::" <name:Ident> <r2:@R> => {
        let path_span = (context.span_from)(l, r1);
        let extern_path = context.handle_relative_path(els, last, false, path_span);

        let span = (context.span_from)(l, r2);
        context
            .current_ii()
            .exprs
            .insert(Expr::ExternalStorageAccess {
                extern_path,
                name: name.to_string(),
                span,
            })
    }
}

/////////////
/// Utils ///
/////////////

// List of zero or more Ty separated by Sep, allowing a trailing Sep.
SepList<Ty, Sep>: Vec<Ty> = {
    <mut v: (<Ty> Sep)*> <e:Ty?> => {
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

// List of one or more Ty separated by Sep, allowing a trailing Sep.  The separator is required in
// the single element case.
Sep1List<Ty, Sep>: Vec<Ty> = {
    <mut v: (<Ty> Sep)+> <e:Ty?> => {
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

// List of one or more Ty separated by Sep, disallowing a trailing Sep.
Sep1ListNoTrail<Ty, Sep>: Vec<Ty> = {
    <mut v: (<Ty> Sep)*> <e:Ty> => {
        v.push(e);
        v
    }
};

/////////////
/// Lexer ///
/////////////

extern {
    type Location = usize;
    type Error = ParseError;

    enum lexer::Token {
        ":" => lexer::Token::Colon,
        "::" => lexer::Token::DoubleColon,
        ";" => lexer::Token::Semi,
        "," => lexer::Token::Comma,
        "=" => lexer::Token::Eq,

        "==" => lexer::Token::EqEq,
        "!=" => lexer::Token::NotEq,
        "<" => lexer::Token::Lt,
        "<=" => lexer::Token::LtEq,
        ">" => lexer::Token::Gt,
        ">=" => lexer::Token::GtEq,

        "&&" => lexer::Token::DoubleAmpersand,
        "||" => lexer::Token::DoublePipe,

        "*" => lexer::Token::Star,
        "/" => lexer::Token::Div,
        "%" => lexer::Token::Mod,

        "+" => lexer::Token::Plus,
        "-" => lexer::Token::Minus,
        "!" => lexer::Token::Bang,
        "'" => lexer::Token::SingleQuote,

        "(" => lexer::Token::ParenOpen,
        ")" => lexer::Token::ParenClose,
        "{" => lexer::Token::BraceOpen,
        "}" => lexer::Token::BraceClose,
        "[" => lexer::Token::BracketOpen,
        "]" => lexer::Token::BracketClose,
        "->" => lexer::Token::Arrow,
        "=>" => lexer::Token::HeavyArrow,
        "." => lexer::Token::Dot,
        ".." => lexer::Token::TwoDots,
        "|" => lexer::Token::Pipe,

        "int_ty" => lexer::Token::Int,
        "real_ty" => lexer::Token::Real,
        "bool_ty" => lexer::Token::Bool,
        "string_ty" => lexer::Token::String,
        "b256_ty" => lexer::Token::B256,

        "int_lit" => lexer::Token::IntLiteral(<String>),
        "real_lit" => lexer::Token::RealLiteral(<String>),
        "str_lit" => lexer::Token::StringLiteral(<String>),

        "true" => lexer::Token::True,
        "false" => lexer::Token::False,

        "fn" => lexer::Token::Fn,
        "if" => lexer::Token::If,
        "else" => lexer::Token::Else,
        "cond" => lexer::Token::Cond,

        "use" => lexer::Token::Use,
        "self" => lexer::Token::SelfTok,
        "let" => lexer::Token::Let,
        "state" => lexer::Token::State,
        "storage" => lexer::Token::Storage,
        "extern" => lexer::Token::Extern,
        "enum" => lexer::Token::Enum,
        "type" => lexer::Token::Type,
        "constraint" => lexer::Token::Constraint,
        "as" => lexer::Token::As,
        "intent" => lexer::Token::Intent,

        "solve" => lexer::Token::Solve,
        "satisfy" => lexer::Token::Satisfy,
        "minimize" => lexer::Token::Minimize,
        "maximize" => lexer::Token::Maximize,

        "in" => lexer::Token::In,

        "forall" => lexer::Token::ForAll,
        "exists" => lexer::Token::Exists,
        "where" => lexer::Token::Where,

        "ident" => lexer::Token::Ident(<(String, bool)>),

        "macro" => lexer::Token::Macro,
        "macro_name" => lexer::Token::MacroName(<String>),
        "macro_param" => lexer::Token::MacroParam(<String>),
        "macro_param_pack" => lexer::Token::MacroParamPack(<String>),
        "macro_body" => lexer::Token::MacroBody(<lexer::MacroBody>),
        "macro_call_args" => lexer::Token::MacroCallArgs(<lexer::MacroCallArgs>),
        "macro_tag" => lexer::Token::MacroTag(<Option<usize>>),
    }
}
