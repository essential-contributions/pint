use crate::{
    error::{CompileError, Error, Handler, ParseError},
    expr::*,
    intermediate::{
        BlockStatement, Const, ConstraintDecl, ExprKey, IfDecl, IntentInterface, InterfaceDecl,
        InterfaceInstance, InterfaceVar, IntermediateIntent, Program, ProgramKind, SolveFunc,
        StorageVar,
    },
    lexer,
    macros::{MacroCall, MacroDecl},
    parser::{
        ParserContext,
        UseTree::{self, Path as UseTreePath},
    },
    span::{self, Spanned},
    types::{EnumDecl, NewTypeDecl, Path, PrimitiveKind, Type},
};

grammar<'a>(
    context: &mut ParserContext<'a>,
    handler: &Handler,
);

pub Pint: () = {
    Decl*,
};

////////////////////
/// Declarations ///
////////////////////

Decl: () = {
    DeclBarringMacro,
    IntentDecl,
    MacroDecl,
    StorageDecl,
    Interface,
    ConstDecl ";",
};

DeclBarringMacro: () = {
    UseStatement ";",
    VarDecl ";",
    StateDecl ";",
    ConstraintDecl ";",
    IfDecl,
    SolveDecl ";",
    EnumDecl ";",
    NewTypeDecl ";",
    MacroCallDecl ";",
    InterfaceInstance ";",
    IntentInstance ";",
};

IntentDecl: () = {
    IntentOpen DeclBarringMacro* IntentClose,
}

IntentOpen: () = {
    <l:@L> "intent" <name:Ident> <r:@R> "{" => {
        // To detect name clashes
        let name = context.add_top_level_symbol(
            handler,
            Ident {
                name: name.to_string(),
                hygienic: false,
                span: (context.span_from)(l, r),
            },
            context.mod_prefix,
        );

        // Brand new II in the program
        context
            .program
            .iis
            .insert(name.to_string(), IntermediateIntent::new(name.to_string()));

        // Keep track of the macro call in this new intent
        context
            .macro_calls
            .insert(name.to_string(), slotmap::SecondaryMap::default());

        // The program is now considered stateful
        context.program.kind = ProgramKind::Stateful;

        // Switch the current_ii so that the parser inserts items in the right II until the intent
        // closes
        *context.current_ii = name.to_string();
    }
}

IntentClose: () = {
    "}" => {
        // At the end of the intent declaration, return back to the root II
        *context.current_ii = Program::ROOT_II_NAME.to_string();
    }
}

StorageVar: StorageVar = {
    <l:@L> <name:Ident> ":" <ty:StorageVarType> <r:@R> => {
        context.parse_storage_var(handler, name, ty, (l, r))
    }
}

StorageBlock: Vec<StorageVar> = {
    "storage" "{" <storage_vars:SepList<StorageVar, ",">> "}" => {
        context.parse_storage_block(handler, storage_vars)
    }
}

StorageDecl: () = {
    <l:@L> <storage_vars:StorageBlock> <r:@R> => {
        context.parse_storage_decl(handler, storage_vars, (l, r))
    },
}

InterfaceVar: InterfaceVar = {
    <l:@L> "pub" "var" <name:VarName> ":" <ty:Type> ";" <r:@R> => {
        // This is temporary until we support other types
        if !(ty.is_bool() || ty.is_int() || ty.is_b256()) {
            handler.emit_err(Error::Compile {
                error: CompileError::Internal {
                    msg: "only `bool`, `int` and `b256` are currently support in interface vars",
                    span: span::empty_span(),
                },
            });
        }
        InterfaceVar {
            name: name.0,
            ty,
            span: (context.span_from)(l, r),
        }
    }
}

IntentInterface: IntentInterface = {
    <l:@L> "intent" <name:Ident> "{" <vars:InterfaceVar*> "}" <r:@R> => {
        IntentInterface {
            name,
            vars,
            span: (context.span_from)(l, r),
        }
    },
    <l:@L> "intent" <name:Ident> ";" <r:@R> => {
        IntentInterface {
            name,
            vars: vec![],
            span: (context.span_from)(l, r),
        }
    }
}

InterfaceDecl: InterfaceDecl = {
    <l:@L> <storage_vars:StorageBlock> <r:@R> => {
        InterfaceDecl::StorageDecl((storage_vars, (context.span_from)(l, r)))
    },
    <intent_interface:IntentInterface> => {
        InterfaceDecl::IntentInterface(intent_interface)
    },
}

Interface: () = {
    <l:@L> "interface" <name:Ident> "{" <interface_decls:InterfaceDecl*> "}" <r:@R> => {
        context.parse_interface(handler, name, interface_decls, (l, r));
    }
}

InterfaceInstance: () = {
    <l:@L> "interface" <name:Ident> "=" <interface:Path> "(" <address:Expr> ")" <r:@R> => {
        let interface_instance = InterfaceInstance {
            name: context.add_top_level_symbol(handler, name, context.mod_prefix),
            interface,
            address,
            span: (context.span_from)(l, r),
        };
        context
            .current_ii()
            .interface_instances
            .push(interface_instance);
    }
}

IntentInstance: () = {
    <l:@L> "intent" <name:Ident> "=" <l1:@L> <abs:"::"?> <els:(<Ident> "::")*> <r1:@R> <intent:Ident>
            "(" <address:Expr> ")" <r:@R> => {
        context.parse_intent_instance(
            handler,
            name,
            abs.is_some(),
            els,
            intent,
            address,
            (l, l1, r1, r),
        );
    }
}

UseStatement: () = {
    "use" <l:@L> <abs:"::"?> <ut:UseTree> <r:@R> => {
        context.parse_use_statement(handler, abs.is_some(), ut, (l, r))
    }
};

UsePathIdent: Ident = {
    Ident,
    IdentFromToken<"self">,
    MacroName,
}

UseTree: UseTree = {
    <name:UsePathIdent> => UseTree::Name { name },
    <prefix:UsePathIdent> "::" <suffix:UseTree> => UseTreePath { prefix, suffix: Box::new(suffix) },
    "{" <imports:SepList<UseTree, ",">> "}" => UseTree::Group { imports },
    <name:UsePathIdent> "as" <alias:Ident> => UseTree::Alias { name, alias },
};

VarDecl: () = {
    <l:@L> <r#pub:"pub"?> "var" <name:VarName> ":" <ty:Type> <init:VarInit?> <r:@R> => {
        context.parse_var_decl(handler, r#pub.is_some(), name, Some(ty), init, (l, r));
    },
    <l:@L> <r#pub:"pub"?> "var" <name:VarName> <init:VarInit> <r:@R> => {
        context.parse_var_decl(handler, r#pub.is_some(), name, None, Some(init), (l, r));
    },
    <l:@L> <r#pub:"pub"?> "var" <name:VarName> <r:@R> => {
        context.parse_var_decl(handler, r#pub.is_some(), name, None, None, (l, r));
    }
};

VarName: (Ident, Option<&'a str>) = {
    <l:@L> <id:"ident"> <r:@R> => context.parse_var_name(handler, id, (l, r)),
};

VarInit: ExprKey = {
    "=" <Range>,
    "=" <Expr>,
};

StateDecl: () = {
    <l:@L> "state" <name:Ident> <ty:(":" <Type>)?> "=" <init:StateInit> <r:@R> => {
        // Return the index to the new state in the IntermediateIntent::states Vec.
        let span = (context.span_from)(l, r);
        let mod_prefix = context.mod_prefix;
        let _ = context
            .current_ii()
            .insert_state(handler, mod_prefix, &name, ty, init, span)
            .map(|_| ());
    },
};

ConstDecl: () = {
    <l:@L> "const" <name:Ident> <ty:(":" <Type>)?> "=" <init:Expr> <r:@R> => {
        // consts are all added to the root II.
        if let Ok(full_name) = context.program.root_ii_mut().add_top_level_symbol(
            handler,
            context.mod_prefix,
            None,
            &name,
            name.span.clone(),
        ) {
            let decl_ty = ty.unwrap_or_else(|| Type::Unknown(name.span.clone()));

            context.program.consts.insert(
                full_name,
                Const {
                    expr: init,
                    decl_ty,
                },
            );
        }
    }
};

ConstraintDecl: () = {
    <constraint: Constraint> => context.current_ii().constraints.push(constraint),
};

Constraint: ConstraintDecl = {
    <l:@L> "constraint" <expr:Expr> <r:@R> => {
        ConstraintDecl {
            expr,
            span: (context.span_from)(l, r),
        }
    }
};

BlockStatement: BlockStatement = {
    <constraint: Constraint> ";" => BlockStatement::Constraint(constraint),
    <if_decl: If> => BlockStatement::If(if_decl),
}

ThenBlock: Vec<BlockStatement> = {
    "{" <block_statements:BlockStatement*> "}" => block_statements
};

ElseBlock: Vec<BlockStatement> = {
    "else" "{" <block_statements:BlockStatement*> "}" => block_statements
};

If: IfDecl = {
    <l:@L> "if" <condition:Expr> <then_block:ThenBlock> <else_block:ElseBlock?> <r:@R> => {
        IfDecl {
            condition,
            then_block,
            else_block,
            span: (context.span_from)(l, r),
        }
    }
};

IfDecl: () = {
    <if_decl: If> => context.current_ii().if_decls.push(if_decl)
};

SolveDecl: () = {
    <l:@L> <sd:SolveDeclInner> <r:@R> => {
        let span = (context.span_from)(l, r);
        if let Some((_, prev_span)) = context.current_ii().directives.first() {
            // Multiple `solve` directives are not allowed
            handler.emit_err(Error::Parse {
                error: ParseError::TooManySolveDirectives {
                    span,
                    prev_span: prev_span.clone(),
                },
            });
        } else if !context.mod_path.is_empty() {
            // `solve` directives in sub-modules are not allowed
            handler.emit_err(Error::Parse {
                error: ParseError::SolveDirectiveMustBeTopLevel { span },
            });
        } else if context.current_ii != Program::ROOT_II_NAME {
            // `solve` directives inside an `intent` declaration are not allowed
            handler.emit_err(Error::Parse {
                error: ParseError::SolveDirectiveMustBeOutsideIntent { span },
            });
        } else {
            context.current_ii().directives.push((sd.clone(), span));
        }
    }
}

SolveDeclInner: SolveFunc = {
    "solve" "satisfy" => SolveFunc::Satisfy,
    "solve" "minimize" <e:Expr> => SolveFunc::Minimize(e),
    "solve" "maximize" <e:Expr> => SolveFunc::Maximize(e),
};

EnumDecl: () = {
    <l:@L> "enum" <name:Ident> "=" <variants:Sep1ListNoTrail<Ident, "|">> <r:@R> => {
        let enum_decl = EnumDecl {
            name: context.add_top_level_symbol(handler, name, context.mod_prefix),
            variants,
            span: (context.span_from)(l, r),
        };
        context.current_ii().enums.push(enum_decl);
    }
}

NewTypeDecl: () = {
    <l:@L> "type" <name:Ident> "=" <ty:Type> <r:@R> => {
        let new_type_decl = NewTypeDecl {
            name: context.add_top_level_symbol(handler, name, context.mod_prefix),
            ty,
            span: (context.span_from)(l, r),
        };
        context.current_ii().new_types.push(new_type_decl);
    }
}

MacroName: Ident = IdentFromToken<"macro_name">;

MacroDecl: () = {
    "macro" <l:@L> <mut name:MacroName> "("
        <params:MacroParamList>
    ")" <r:@R>
    <body:"macro_body"> => {
        // Prefix the name with the module.  We can't use `add_top_level_symbol()` to do this as we
        // must avoid the regular name clash error we'd get with variadic macros.
        name.name = context.mod_prefix.to_string() + &name.name;
        context.macros.push(MacroDecl {
            name,
            params: params.0,
            pack: params.1,
            body,
            sig_span: (context.span_from)(l, r),
        });
    }
}

MacroParamList: (Vec<Ident>, Option<Ident>) = {
    <mut v: (<MacroParam> ",")*> <e:MacroParam>
    <p:("," <IdentFromToken<"macro_param_pack">>)?> ","? => {
        v.push(e);
        (v, p)
    },
    // Empty parameter lists
    => (Vec::new(), None),
}

MacroParam: Ident = IdentFromToken<"macro_param">;

MacroCallDecl: () = {
    MacroCallExpr => (),
}

pub MacroBody: Option<ExprKey> = {
    "{" DeclBarringMacro* <Expr?> "}"
}

FnParam: (Ident, Type)  = {
    <name:Ident> ":" <ty:Type> => (name, ty)
}

/////////////
/// Types ///
/////////////

Type: Type = {
    <ArrayType>,
    <TypeAtom>,
};

TypeAtom: Type = {
    <l:@L> <kind:PrimitiveType> <r:@R> => Type::Primitive {
        kind,
        span: (context.span_from)(l, r),
    },
    <l:@L> "{" <fields:TupleFields> "}" <r:@R> => {
        Type::Tuple {
            fields,
            span: (context.span_from)(l, r),
        }
    },
    <l:@L> "{" "}" <r:@R> => {
        let span = (context.span_from)(l, r);
        handler.emit_err(Error::Parse {
            error: ParseError::EmptyTupleType { span: span.clone() },
        });

        // Recover with a malformed type
        Type::Error(span)
    },
    <l:@L> <path:Path> <r:@R> => Type::Custom {
        path,
        span: (context.span_from)(l, r),
    },
};

ArrayType: Type = {
    <l:@L> <ty:TypeAtom> <ranges: ("[" <Expr> "]")+ > <r:@R> => {
        // Multi-dimensional arrays have their innermost dimension on the far
        // right. Hence, we need to reverse the iterator.
        // For example, `int[3][5]` is actually an array of size 3 that
        // contains arrays of size 5 of `int`s.
        ranges.iter().rev().fold(ty, |acc, range| Type::Array {
            ty: Box::new(acc),
            range: Some(*range),
            size: None,
            span: (context.span_from)(l, r),
        })
    },
    <l:@L> <ty:TypeAtom> "[" "]" <r:@R> => {
        let span = (context.span_from)(l, r);
        handler.emit_err(Error::Parse {
            error: ParseError::EmptyArrayType { span: span.clone() },
        });

        // Recover with a malformed type
        Type::Error(span)
    },
};

PrimitiveType: PrimitiveKind = {
    "int_ty" => PrimitiveKind::Int,
    "real_ty" => PrimitiveKind::Real,
    "bool_ty" => PrimitiveKind::Bool,
    "string_ty" => PrimitiveKind::String,
    "b256_ty" => PrimitiveKind::B256,
}

TupleFields: Vec<(Option<Ident>, Type)> = {
    <field:TupleField> => vec![field],
    <Sep1List<TupleField, ",">>,
};

TupleField: (Option<Ident>, Type) = {
    <id:(<Ident> ":")?> <ty:Type> => (id, ty),
};

/////////////////////
/// Storage Types ///
/////////////////////

// Does not yet allow for maps inside maps and is only to be used in storage blocks
MapType: Type = {
    <l:@L> "(" <ty_from:Type> "=>" <ty_to:StorageVarType> ")" <r:@R> => Type::Map {
        ty_from: Box::new(ty_from),
        ty_to: Box::new(ty_to),
        span: (context.span_from)(l, r),
    }
}

StorageVarType: Type = {
    <MapType>,
    <Type>,
}

///////////////////
/// Expressions ///
///////////////////

Expr: ExprKey = {
    <SelectExpr>,
};

SelectExpr: ExprKey = {
    <l:@L> <condition:LogicalOrOp> "?" <then_expr:SelectExpr> ":" <else_expr:SelectExpr> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::Select {
                condition,
                then_expr,
                else_expr,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
    },
    <LogicalOrOp>
}

LogicalOrOp: ExprKey = {
    <l:@L> <lhs:LogicalOrOp> "||" <rhs:LogicalAndOp> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::BinaryOp {
                op: BinaryOp::LogicalOr,
                lhs,
                rhs,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
    },
    <LogicalAndOp>,
};

LogicalAndOp: ExprKey = {
    <l:@L> <lhs:LogicalAndOp> "&&" <rhs:Comparison> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::BinaryOp {
                op: BinaryOp::LogicalAnd,
                lhs,
                rhs,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
    },
    <Comparison>,
};

Comparison: ExprKey = {
    <l:@L> <lhs:Comparison> <op:RelOpOp> <rhs:InOp> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::BinaryOp {
                op,
                lhs,
                rhs,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
    },
    <InOp>,
};

RelOpOp: BinaryOp = {
    "==" => BinaryOp::Equal,
    "!=" => BinaryOp::NotEqual,
    "<" => BinaryOp::LessThan,
    "<=" => BinaryOp::LessThanOrEqual,
    ">" => BinaryOp::GreaterThan,
    ">=" => BinaryOp::GreaterThanOrEqual,
};

InOp: ExprKey = {
     <l:@L> <value:InOp> "in" <collection:Additive> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::In {
                value,
                collection,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
     },
     <l:@L> <value:InOp> "in" <collection:Range> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::In {
                value,
                collection,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
     },
    <Additive>,
};

Additive: ExprKey = {
    <l:@L> <lhs:Additive> <op:AddOpOp> <rhs:Multiplicative> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::BinaryOp {
                op,
                lhs,
                rhs,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
    },
    <Multiplicative>,
};

AddOpOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

Multiplicative: ExprKey = {
    <l:@L> <lhs:Multiplicative> <op:MultOpOp> <rhs:AsOp> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::BinaryOp {
                op,
                lhs,
                rhs,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
    },
    <AsOp>,
};

MultOpOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
};

AsOp: ExprKey = {
     <l:@L> <value:AsOp> "as" <ty:Type> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::Cast {
                value,
                ty: Box::new(ty),
                span: span.clone(),
            },
            Type::Unknown(span),
        )
     },
    <PrimeOp>,
};

PrimeOp: ExprKey = {
    <l:@L> <expr:PrimeOp> "'" <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::UnaryOp {
                op: UnaryOp::NextState,
                expr,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
    },
    <UnaryOp>,
}

UnaryOpOp: UnaryOp = {
    <l:@L> "+" <r:@R> => {
        handler.emit_err(Error::Parse {
            error: ParseError::UnsupportedLeadingPlus {
                span: (context.span_from)(l, r),
            },
        });
        UnaryOp::Error
    },
    "-" => UnaryOp::Neg,
    "!" => UnaryOp::Not,
};

UnaryOp: ExprKey = {
    <l:@L> <op:UnaryOpOp> <expr:UnaryOp> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::UnaryOp {
                op,
                expr,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
    },
    <TupleFieldOpOrIndexOp>,
};

TupleFieldOpOrIndexOp: ExprKey = {
    <l:@L> <expr:TupleFieldOpOrIndexOp> "[" <index:Expr> "]" <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::Index {
                expr,
                index,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
    },
    <l:@L> <expr:TupleFieldOpOrIndexOp> "[" "]" <r:@R> => {
        let span = (context.span_from)(l, r);
        handler.emit_err(Error::Parse {
            error: ParseError::EmptyIndexAccess { span: span.clone() },
        });

        // Recover with a malformed expression
        context
            .current_ii()
            .exprs
            .insert(Expr::Error(span.clone()), Type::Unknown(span))
    },
    <l:@L> <tuple:TupleFieldOpOrIndexOp> "." <name:Ident> <r:@R> => {
        context.parse_tuple_field_op_with_ident(tuple, name, (l, r))
    },
    <l:@L> <tuple:TupleFieldOpOrIndexOp> "." <m:@L> <num_str:"int_lit"> <r:@R> => {
        context.parse_tuple_field_op_with_int(handler, tuple, num_str, (l, m, r))
    },
    <l:@L> <tuple:TupleFieldOpOrIndexOp> "." <m:@L> <num_str:"real_lit"> <r:@R> => {
        context.parse_tuple_field_op_with_real(handler, tuple, num_str, (l, m, r))
    },
    <Term>,
};

Term: ExprKey = {
    <e:TermInner> => {
        let span = e.span().clone();
        context.current_ii().exprs.insert(e, Type::Unknown(span))
    },
    <MacroCallExpr>,
    <CondExpr>,
    "(" <Expr> ")",
};

TermInner: Expr = {
    <l:@L> <imm:Immediate> <r:@R> => {
        Expr::Immediate {
            value: imm,
            span: (context.span_from)(l, r),
        }
    },
    <GeneratorExpr>,
    <IntrinsicCallExpr>,
    <ArrayExpr>,
    <TupleExpr>,
    <l:@L> <path:Path> <r:@R> => Expr::PathByName(path, (context.span_from)(l, r)),
};

GeneratorRange: (Ident, ExprKey) = {
    <index:Ident> "in" <range:Range> => {
        // Generators for `forall`/`exists` are always `int`s and need to be saved in the ephemeral
        // list.
        let mod_prefix = context.mod_prefix;
        let _ = context.current_ii().insert_ephemeral(
            handler,
            mod_prefix,
            &index,
            Type::Primitive {
                kind: PrimitiveKind::Int,
                span: index.span.clone(),
            },
        );
        (index, range)
    }
}

GeneratorExpr: Expr = {
    <l:@L> "forall" <gen_ranges:Sep1ListNoTrail<GeneratorRange, ",">>
            <conditions: ("where" <Sep1ListNoTrail<Expr, ",">>)?>
            "{" <body:Expr> "}" <r:@R> => {
        Expr::Generator {
            kind: GeneratorKind::ForAll,
            gen_ranges,
            conditions: conditions.unwrap_or_default(),
            body,
            span: (context.span_from)(l, r),
        }
    },
    <l:@L> "exists" <gen_ranges:Sep1ListNoTrail<GeneratorRange, ",">>
            <conditions: ("where" <Sep1ListNoTrail<Expr, ",">>)?>
            "{" <body:Expr> "}" <r:@R> => {
        Expr::Generator {
            kind: GeneratorKind::Exists,
            gen_ranges,
            conditions: conditions.unwrap_or_default(),
            body,
            span: (context.span_from)(l, r),
        }
    }
}

CondBranch: (ExprKey, ExprKey) = {
    <condition:Expr> "=>" <result:Expr> "," => (condition, result)
};

ElseBranch: ExprKey = {
    "else" "=>" <else_result:Expr> ","? => else_result
};

CondExpr: ExprKey = {
    <l:@L> "cond" "{" <cond_branches: (<CondBranch>)*> <else_branch: ElseBranch> "}" <r:@R> => {
        // De-sugar a `cond` into a select chain.
        //
        // Build the select chain starting with the else branch and going up,
        // hence the need to reverse the iterator below.
        cond_branches
            .iter()
            .rev()
            .fold(else_branch, |acc, (condition, result)| {
                let span = (context.span_from)(l, r);
                context.current_ii().exprs.insert(
                    Expr::Select {
                        condition: *condition,
                        then_expr: *result,
                        else_expr: acc,
                        span: span.clone(),
                    },
                    Type::Unknown(span),
                )
            })
    }
};

MacroCallExpr: ExprKey = {
    <l:@L> <name:MacroPath> <tag:"macro_tag"?> <args:"macro_call_args"> <r:@L> => {
        let call_key = context.current_ii().calls.insert(name.clone());
        let span = (context.span_from)(l, r);
        let call_data = MacroCall {
            name,
            mod_path: context.mod_path.to_vec(),
            args,
            span: span.clone(),
            parent_tag: tag.flatten(),
        };
        let call_expr_key = context.current_ii().exprs.insert(
            Expr::MacroCall {
                call: call_key,
                span: span.clone(),
            },
            Type::Unknown(span),
        );
        context
            .macro_calls
            .get_mut(context.current_ii)
            .unwrap()
            .insert(call_key, (call_expr_key, call_data));
        call_expr_key
    },
};

IntrinsicCallExpr: Expr = {
    <l:@L> <ident:IntrinsicName> "(" <args:SepList<Expr, ",">> ")" <r:@R> => {
        Expr::IntrinsicCall {
            name: ident,
            args,
            span: (context.span_from)(l, r),
        }
    },
};

ArrayExpr: Expr = {
    <l:@L> "[" <il:@L> <elements:SepList<Expr, ",">> <ir:@R> "]" <r:@R> => {
        let span = (context.span_from)(il, ir);
        let range_expr = context.current_ii().exprs.insert(
            Expr::Immediate {
                value: Immediate::Int(elements.len() as i64),
                span: span.clone(),
            },
            Type::Unknown(span),
        );
        Expr::Array {
            elements,
            range_expr,
            span: (context.span_from)(l, r),
        }
    },
};

TupleExpr: Expr = {
    <l:@L> "{" <fields:TupleExprFields> "}" <r:@R> => {
        Expr::Tuple {
            fields,
            span: (context.span_from)(l, r),
        }
    },
    <l:@L> "{" "}" <r:@R> => {
        let span = (context.span_from)(l, r);
        handler.emit_err(Error::Parse {
            error: ParseError::EmptyTupleExpr { span: span.clone() },
        });

        Expr::Error(span)
    },
};

TupleExprFields: Vec<(Option<Ident>, ExprKey)> = {
    <id:Ident> ":" <expr:Expr> => {
        // Special case for a single field with a field label which does not require the trailing
        // comma to distinguish it from a block expression.
        vec![(Some(id), expr)]
    },
    <expr:Expr> => {
        // Special case for a single field which does not require the trailing
        // comma to distinguish it from a block expression.
        vec![(None, expr)]
    },
    <Sep1List<TupleExprField, ",">>,
};

TupleExprField: (Option<Ident>, ExprKey) = {
    <id:(<Ident> ":")?> <expr:Expr> => (id, expr),
};

Range: ExprKey = {
    <l:@L> <lb:Additive> ".." <ub:Additive> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::Range {
                lb,
                ub,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
    }
}

Path: Path = {
    <PathWithLast<Ident>>,
};

MacroPath: Path = {
    <PathWithLast<IdentFromToken<"macro_name">>>,
};

PathWithLast<Last>: Path = {
    <l:@L> "::" <els:(<Ident> "::")*> <last:Last> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.parse_absolute_path(els, last, true, span)
    },
    <l:@L> <els:(<Ident> "::")*> <last:Last> <r:@R> => {
        let span = (context.span_from)(l, r);
        context.parse_relative_path(els, last, true, span)
    }
};

Immediate: Immediate = {
    <l:@L> <s:"int_lit"> <r:@R>=> context.parse_int_immediate(handler, s, (l, r)),
    <s:"real_lit"> => Immediate::Real(s.replace('_', "").parse().unwrap()),
    "true" => Immediate::Bool(true),
    "false" => Immediate::Bool(false),
    "nil" => Immediate::Nil,
    <s:"str_lit"> => Immediate::String(s),
};

Ident: Ident = {
    <l:@L> <id:"ident"> <r:@R> => {
        let name = id.0.to_string();
        let span = (context.span_from)(l, r);
        if name.starts_with("__") {
            handler.emit_err(Error::Parse {
                error: ParseError::LeadingUnderscoresInIdent {
                    span: span.clone(),
                    name: name.clone(),
                },
            });
        }
        Ident {
            name,
            hygienic: id.1,
            span,
        }
    }
}

IntrinsicName: Ident = {
    <l:@L> <id:"ident"> <r:@R> => Ident {
        name: id.0.to_string(),
        hygienic: id.1,
        span: (context.span_from)(l, r),
    }
}

IdentFromToken<Tok>: Ident = {
    <l:@L> <id:Tok> <r:@R> => Ident {
        name: id.to_string(),
        hygienic: false,
        span: (context.span_from)(l, r),
    }
}

//////////////////////////////////
/// Storage Access Expressions ///
//////////////////////////////////

StateInit: ExprKey = {
    <StorageTupleFieldOp>,
    <call:IntrinsicCallExpr> => {
        let span = call.span().clone();
        context.current_ii().exprs.insert(call, Type::Unknown(span))
    },
}

StorageTupleFieldOp: ExprKey = {
    <l:@L> <tuple:StorageTupleFieldOp> "." <name:Ident> <r:@R> => {
        context.parse_tuple_field_op_with_ident(tuple, name, (l, r))
    },
    <l:@L> <tuple:StorageTupleFieldOp> "." <m:@L> <num_str:"int_lit"> <r:@R> => {
        context.parse_tuple_field_op_with_int(handler, tuple, num_str, (l, m, r))
    },
    <l:@L> <tuple:StorageTupleFieldOp> "." <m:@L> <num_str:"real_lit"> <r:@R> => {
        context.parse_tuple_field_op_with_real(handler, tuple, num_str, (l, m, r))
    },
    <StorageIndexOp>
}

StorageIndexOp: ExprKey = {
    // Even though we don't allow complex types in storage maps just yet, this does support indexing
    // into a map of maps.
    <l:@L> <expr:StorageIndexOp> "[" <index:Expr> "]" <r:@R> => {
        let span = (context.span_from)(l, r);
        context.current_ii().exprs.insert(
            Expr::Index {
                expr,
                index,
                span: span.clone(),
            },
            Type::Unknown(span),
        )
    },
    <l:@L> <expr:StorageIndexOp> "[" "]" <r:@R> => {
        let span = (context.span_from)(l, r);
        handler.emit_err(Error::Parse {
            error: ParseError::EmptyIndexAccess { span: span.clone() },
        });

        // Recover with a malformed expression
        context
            .current_ii()
            .exprs
            .insert(Expr::Error(span.clone()), Type::Unknown(span))
    },
    <StorageAccess>,
};

StorageAccess: ExprKey = {
    <l:@L> "storage" "::" <name:Ident> <r:@R> => {
        context.parse_storage_access(handler, false, None, name, (l, l, r))
    },
    <l:@L> <abs:"::"?> <els:(<Ident> "::")*> <last:Ident> <m:@R> "::"
           "storage" "::" <name:Ident> <r:@R> => {
        context.parse_storage_access(handler, abs.is_some(), Some((els, last)), name, (l, m, r))
    },
}

/////////////
/// Utils ///
/////////////

// List of zero or more Ty separated by Sep, allowing a trailing Sep.
SepList<Ty, Sep>: Vec<Ty> = {
    <mut v: (<Ty> Sep)*> <e:Ty?> => {
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

// List of one or more Ty separated by Sep, allowing a trailing Sep.  The separator is required in
// the single element case.
Sep1List<Ty, Sep>: Vec<Ty> = {
    <mut v: (<Ty> Sep)+> <e:Ty?> => {
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

// List of one or more Ty separated by Sep, disallowing a trailing Sep.
Sep1ListNoTrail<Ty, Sep>: Vec<Ty> = {
    <mut v: (<Ty> Sep)*> <e:Ty> => {
        v.push(e);
        v
    }
};

pub(crate) TestDelegate: crate::parser::TestWrapper = {
    "test_expr" <Expr> => crate::parser::TestWrapper::Expr(<>),
    "test_range" <Range> => crate::parser::TestWrapper::Expr(<>),
    "test_type" <Type> => crate::parser::TestWrapper::Type(<>),
    "test_sv_type" <StorageVarType> => crate::parser::TestWrapper::Type(<>),
    "test_ident" <Ident> => crate::parser::TestWrapper::Ident(<>),
    "test_intrinsic" <IntrinsicName> => crate::parser::TestWrapper::Ident(<>),
    "test_usetree" <UseTree> => crate::parser::TestWrapper::UseTree(<>),
    "test_state" <StateInit> => crate::parser::TestWrapper::Expr(<>),
};

/////////////
/// Lexer ///
/////////////

extern {
    type Location = usize;
    type Error = ParseError;

    enum lexer::Token {
        ":" => lexer::Token::Colon,
        "::" => lexer::Token::DoubleColon,
        ";" => lexer::Token::Semi,
        "," => lexer::Token::Comma,
        "=" => lexer::Token::Eq,
        "?" => lexer::Token::QuestionMark,

        "==" => lexer::Token::EqEq,
        "!=" => lexer::Token::NotEq,
        "<" => lexer::Token::Lt,
        "<=" => lexer::Token::LtEq,
        ">" => lexer::Token::Gt,
        ">=" => lexer::Token::GtEq,

        "&&" => lexer::Token::DoubleAmpersand,
        "||" => lexer::Token::DoublePipe,

        "*" => lexer::Token::Star,
        "/" => lexer::Token::Div,
        "%" => lexer::Token::Mod,

        "+" => lexer::Token::Plus,
        "-" => lexer::Token::Minus,
        "!" => lexer::Token::Bang,
        "'" => lexer::Token::SingleQuote,

        "(" => lexer::Token::ParenOpen,
        ")" => lexer::Token::ParenClose,
        "{" => lexer::Token::BraceOpen,
        "}" => lexer::Token::BraceClose,
        "[" => lexer::Token::BracketOpen,
        "]" => lexer::Token::BracketClose,
        "->" => lexer::Token::Arrow,
        "=>" => lexer::Token::HeavyArrow,
        "." => lexer::Token::Dot,
        ".." => lexer::Token::TwoDots,
        "|" => lexer::Token::Pipe,

        "int_ty" => lexer::Token::Int,
        "real_ty" => lexer::Token::Real,
        "bool_ty" => lexer::Token::Bool,
        "string_ty" => lexer::Token::String,
        "b256_ty" => lexer::Token::B256,

        "int_lit" => lexer::Token::IntLiteral(<String>),
        "real_lit" => lexer::Token::RealLiteral(<String>),
        "str_lit" => lexer::Token::StringLiteral(<String>),

        "true" => lexer::Token::True,
        "false" => lexer::Token::False,
        "nil" => lexer::Token::Nil,

        "fn" => lexer::Token::Fn,
        "if" => lexer::Token::If,
        "else" => lexer::Token::Else,
        "cond" => lexer::Token::Cond,

        "pub" => lexer::Token::Pub,
        "use" => lexer::Token::Use,
        "self" => lexer::Token::SelfTok,
        "var" => lexer::Token::Var,
        "state" => lexer::Token::State,
        "const" => lexer::Token::Const,
        "storage" => lexer::Token::Storage,
        "interface" => lexer::Token::Interface,
        "enum" => lexer::Token::Enum,
        "type" => lexer::Token::Type,
        "constraint" => lexer::Token::Constraint,
        "as" => lexer::Token::As,
        "intent" => lexer::Token::Intent,

        "solve" => lexer::Token::Solve,
        "satisfy" => lexer::Token::Satisfy,
        "minimize" => lexer::Token::Minimize,
        "maximize" => lexer::Token::Maximize,

        "in" => lexer::Token::In,

        "forall" => lexer::Token::ForAll,
        "exists" => lexer::Token::Exists,
        "where" => lexer::Token::Where,

        "ident" => lexer::Token::Ident(<(String, bool)>),

        "macro" => lexer::Token::Macro,
        "macro_name" => lexer::Token::MacroName(<String>),
        "macro_param" => lexer::Token::MacroParam(<String>),
        "macro_param_pack" => lexer::Token::MacroParamPack(<String>),
        "macro_body" => lexer::Token::MacroBody(<lexer::MacroBody>),
        "macro_call_args" => lexer::Token::MacroCallArgs(<lexer::MacroCallArgs>),
        "macro_tag" => lexer::Token::MacroTag(<Option<usize>>),

        "test_expr" => lexer::Token::TestMarkerExpr,
        "test_range" => lexer::Token::TestMarkerRange,
        "test_type" => lexer::Token::TestMarkerType,
        "test_sv_type" => lexer::Token::TestMarkerSVType,
        "test_ident" => lexer::Token::TestMarkerIdent,
        "test_intrinsic" => lexer::Token::TestMarkerIntrinsic,
        "test_usetree" => lexer::Token::TestMarkerUseTree,
        "test_state" => lexer::Token::TestMarkerStateInit,
    }
}
